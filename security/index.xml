<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.62 Maintainer: progcom Status: stopped -->
 <chapter id="security.index">
  <title>보안</title>

  <simpara>
   PHP는 강력한 언어와 인터프리터입니다. 웹서버 모듈로 포함하거나
   별도의 <acronym>CGI</acronym> 바이너리로 실행해서, 서버에서
   파일에 접근하거나, 명령을 실행하거나, 네트워크 연결을 열 수 있게
   해줍니다. 기본적으로 이러한 기능은 웹서버의 보안을 위협합니다.
   PHP는 펄이나 C로 쓰여진 CGI 프로그램에 비해서 더욱 안전한 언어로
   설계되었습니다. 컴파일 시와 실행시 환경 설정 옵션의 적절한 선택과
   충분한 코딩 능력은 자유와 보안의 조합을 얻을 수 있을 것입니다.
  </simpara>
  <simpara>
   PHP를 이용하는 다른 방법들에 따라, 실행을 조절하는 많은 환경
   설정 옵션이 존재합니다. 많은 옵션의 선택은 PHP를 여러 목적으로
   사용할 수 있게 보장해주지만, 이러한 옵션과 서버 환경 설정의 조합에
   따라서는 보안을 위협하는 결과를 가져올 수도 있습니다.
  </simpara>
  <simpara>
   PHP 환경 설정의 유연성은 코드의 유연성과 상대적이 됩니다. PHP는
   쉘 유저의 모든 권한을 가지는 완벽한 서버 어플리케이션을 작성할 수도
   있고, 강력히 제어된 환경에서 적은 위험으로 단순한 서버측 포함으로
   사용할 수도 있습니다. 어떻게 환경을 구축하고, 어떻게 보안을 유지하는
   지는, 많은 부분이 PHP 개발자에 의존하고 있습니다.
  </simpara>
  <simpara>
   이 챕터에서는 몇가지 일반적인 보안 조언으로 시작해서, 서로 다른
   환경 설정 옵션의 조합과 안전하게 사용할 수 있는 상황, 그리고 보안
   단계에 따른 코딩에서 고려할 점에 대해서 설명합니다.
  </simpara>

  <sect1 id="security.general">
   <title>일반적인 고려 사항</title>
   <simpara>
    완벽한 보안 시스템은 불가능에 가깝기에, 보안 대책의 지향점은 보통
    위험성과 사용성의 조화점입니다. 유저가 송신하는 모든 변수가 두가지
    형태의 생물학적 인증(망막 스캔이나 지문 등)이 필요하다면, 매우 높은
    수준의 보안을 얻을 수 있습니다. 그러나 이 방법은 매우 복잡한 폼을
    채우기 위해 30여분의 시간을 필요로 할 것이며, 유저가 보안을 그냥
    넘어갈 수 있는 방법을 찾도록 노력하게 할 것입니다.
   </simpara>
   <simpara>
    The best security is often inobtrusive enough to suit the
    requirements without the user being prevented from accomplishing
    their work, or over-burdening the code author with excessive
    complexity. Indeed, some security attacks are merely exploits of
    this kind of overly built security, which tends to erode over time.
   </simpara>
   <simpara>
    A phrase worth remembering: A system is only as good as the weakest
    link in a chain. If all transactions are heavily logged based on
    time, location, transaction type, etc. but the user is only
    verified based on a single cookie, the validity of tying the users
    to the transaction log is severely weakened.
   </simpara>
   <simpara>
    테스트를 할 때, 가장 간단한 페이지라 할지라도 모든 가능성을 테스트할
    수는 없다는 것을 명심하십시오. 화가 난 고용인이나, 엄청난 시간을 가진
    크랙커, 혹은 키보드 위를 걸어가는 고양이 등에 의해 기대했던 입력값과는
    완전히 무관하게 될 수도 있습니다. 이것이 기대하지 않는 데이터를 분별하고,
    그 뒤에 어떻게 변경하고, 줄이고, 늘릴지에 대해 논리적 관점에서 코드를
    바라보아야 할 이유입니다.
   </simpara>
   <simpara>
    The Internet is filled with people trying to make a name for
    themselves by breaking your code, crashing your site, posting
    inappropriate content, and otherwise making your day interesting.
    It doesn't matter if you have a small or large site, you are
    a target by simply being online, by having a server that can be
    connected to. Many cracking programs do not discern by size, they
    simply trawl massive IP blocks looking for victims. Try not to
    become one.
   </simpara>
  </sect1>

  <sect1 id="security.cgi-bin">
   <title>CGI 바이너리로 설치</title>

   <sect2 id="security.cgi-bin.attacks">
    <title>가능한 공격</title>
    <simpara>
     몇가지 이유로 인해 PHP를 서버 소프트웨어(아파치 등)의 모듈로
     사용하지 않거나, 다른 종류의 CGI wrappers로 스크립트에 대해
     안전한 chroot와 setuid 환경을 제공하기 위해 <acronym>CGI</acronym>
     바이너리로 PHP를 사용하는 것을 선택할 수 있습니다.
     이 설치는 보통 실행 가능한 PHP 바이너리를 웹서버 cgi-bin 디렉토리에
     두는 것입니다. CERT 권고 <ulink url="&url.cert;">CA-96.11</ulink>는
     어떠한 인터프리터도 cgi-bin에 두지 않을 것을 권장합니다. PHP 바이너리는
     독립 인터프리터로 사용할 수 있지만, 이러한 방법의 설치가 가능하도록 하는
     몇가지 공격을 방지하도록 설계되어 있습니다.
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       시스템 파일에의 접근: <filename
       role="url">http://my.host/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
       URL 후의 물음표(?)에 존재하는 질의 정보는 CGI 인터페이스에 의해
       인터프리터에 명령줄 인자로 전해집니다. 보통 인터프리터는
       명령줄의 첫 인자에 지정한 파일을 열고 실행합니다.
      </simpara>
      <simpara>
       CGI 바이너리로 호출할 때, PHP는 명령줄 인자를 해석하는 것을
       거절합니다.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       서버의 어떠한 웹 문서로의 접근: <filename
       role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
       PHP 바이너리 이름 뒤의 URL의 경로 정보 부분,
       <filename role="uri">/secret/doc.html</filename>는 일반적으로
       <acronym>CGI</acronym> 프로그램에 의해 그 이름의 파일을
       열고 해석하도록 사용합니다. 보통 몇몇 웹 서버 환경 설정
       지시자(아파치: Action)는 PHP 인터프리터에 <filename
       role="url">http://my.host/secret/script.php</filename> 등의
       요청으로 리다이렉트하도록 합니다. 이러한 설치로는, 웹 서버는
       우선 디렉토리 <filename role="uri">/secret</filename>에 대해
       접근 권한을 확인하고, 리다이렉트된 요청 <filename
       role="url">http://my.host/cgi-bin/php/secret/script.php</filename>을
       생성합니다. 불행하게도, 이러한 형식으로 요청이 주어지면,
       <filename role="uri">/secret/script.php</filename>에 대한 접근 확인은
       이루어지지 않고, 단순히 <filename role="uri">/cgi-bin/php</filename>
       파일만을 확인합니다. 이 방법으로 <filename
       role="uri">/cgi-bin/php</filename>에 접근할 수 있는 어떠한 유저라도
       웹 서버로 보호된 어떠한 문서라도 접근할 수 있습니다.
      </simpara>
      <simpara>
       PHP에서는, 서버 문서 트리에 접근 제한을 가진 어떠한 디렉토리가
       존재한다면, 컴파일시의 환경설정 옵션 <link
       linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>,
       실행시 환경설정 지시자 <link
       linkend="ini.doc-root">doc_root</link>와 <link
       linkend="ini.user-dir">user_dir</link>를 사용하여 이 공격을
       방지할 수 있습니다. 여러가지 조합에 관한 자세한 설명은 아래쪽을
       참고하십시오.
      </simpara>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2 id="security.cgi-bin.default">
    <title>방법 1: 공개 파일만을 제공</title>
    <simpara>
     서버가 패스워드나 IP 기반 접근 컨트롤로 제한하는 콘텐츠를 가지고
     있지 않다면, 이러한 환경 설정 옵션을 사용할 필요가 없습니다.
     웹 서버가 리다이렉트를 허용하지 않거나, 안전하게 리다이렉트된
     요청에 대해서 PHP 바이너리와 통신할 방법을 가지고 있지 않다면,
     설정 스크립트에 <link
     linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
     옵션을 지정할 수 있습니다. 하지만, 여전히 PHP 스크립트를
     호출하는 방법으로 직접 호출 <filename
     role="php">http://my.host/cgi-bin/php/dir/script.php</filename>이나
     리다이렉션 호출 <filename
     role="php">http://my.host/dir/script.php</filename>에
     의존하고 있지 않음을 확인해야 할 것입니다.
    </simpara>
    <simpara>
     아파치에서 리다이렉션은 AddHandler와 Action 지시자를 통해서
     설정할 수 있습니다. (아래 참조)
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.force-redirect">
    <title>방법 2: --enable-force-cgi-redirect 사용</title>
    <simpara>
     이 컴파일시의 옵션은 누구라도 <filename
     role="php">http://my.host/cgi-bin/php/secretdir/script.php</filename>와
     같은 URL을 통해서 PHP를 직접 호출할 수 없게 합니다.
     대신, 이 모드에서 PHP는 웹서버의 리다이렉트 규칙에 따를 때만
     해석을 시도할 것입니다.
    </simpara>
    <simpara>
     아파치에서 리다이렉션의 설정은 다음과 같은 지시자로 설정합니다:
    </simpara>
    <programlisting role="apache-conf">
<![CDATA[
Action php-script /cgi-bin/php
AddHandler php-script .php
]]>
    </programlisting>
    <simpara>
     이 옵션은 아파치 웹 서버에만 테스트되었고, 리다이렉트된 요청에 대해
     아파치가 비표준 CGI 환경 변수 <envar>REDIRECT_STATUS</envar>를
     설정하게 합니다. 웹 서버가 요청이 직접적인지 리다이렉트된 것인지의
     구분을 제공하지 않는다면, 이 옵션을 사용할 수 없고, 이 문서에
     제시된 다른 방법의 CGI 실행 방법을 이용해야 합니다.
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.doc-root">
    <title>방법 3: doc_root나 user_dir을 설정</title>
    <simpara>
     스크립트나 실행 파일과 같은 활동적인 콘텐츠를 웹서버 디렉토리에
     놓는 것은 때때로 비보안적인 행동으로 생각됩니다. 몇몇 환경 설정의
     실수로 스크립트가 실행되지 않고 보통의 HTML 문서로 보여진다면,
     지적 재산이나 패스워드와 같은 보안 정보를 노출시키는 결과를 가져올
     수 있습니다. 그러므로 많은 시스템 관리자는 파일이 항상 해석이 되고
     어떤 방법으로도 표시되어지지 않도록, PHP CGI를 통해서만 접근할 수 있는
     스크립트를 위한 또 다른 디렉토리 구조를 만드는 것을 선호합니다.
    </simpara>
    <simpara>
     Also if the method for making sure the requests are not
     redirected, as described in the previous section, is not
     available, it is necessary to set up a script doc_root that is
     different from web document root.
    </simpara>
    <simpara>
     You can set the PHP script document root by the configuration
     directive <link linkend="ini.doc-root">doc_root</link> in the
     <link linkend="configuration.file">configuration file</link>, or
     you can set the environment variable
     <envar>PHP_DOCUMENT_ROOT</envar>.  If it is set, the CGI version
     of PHP will always construct the file name to open with this
     <parameter>doc_root</parameter> and the path information in the
     request, so you can be sure no script is executed outside this
     directory (except for <parameter>user_dir</parameter>
     below).
    </simpara>
    <simpara>
     Another option usable here is <link
     linkend="ini.user-dir">user_dir</link>.  When user_dir is unset,
     only thing controlling the opened file name is
     <parameter>doc_root</parameter>.  Opening an url like <filename
     role="url">http://my.host/~user/doc.php</filename> does not
     result in opening a file under users home directory, but a file
     called <filename role="uri">~user/doc.php</filename> under
     doc_root (yes, a directory name starting with a tilde
     [<literal>~</literal>]).
    </simpara>
    <simpara>
     If user_dir is set to for example <filename
     role="dir">public_php</filename>, a request like <filename
     role="url">http://my.host/~user/doc.php</filename> will open a
     file called <filename>doc.php</filename> under the directory
     named <filename role="dir">public_php</filename> under the home
     directory of the user.  If the home of the user is <filename
     role="dir">/home/user</filename>, the file executed is
     <filename>/home/user/public_php/doc.php</filename>.
    </simpara>
    <simpara>
     <parameter>user_dir</parameter> expansion happens regardless of
     the <parameter>doc_root</parameter> setting, so you can control
     the document root and user directory access
     separately.
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.shell">
    <title>방법 4: 웹 트리 외부의 PHP 파서</title>
    <para>
     매우 안전한 옵션은 PHP 파서 바이너리를 웹트리 밖에 위치시키는
     것입니다. 예를 들면, <filename role="dir">/usr/local/bin</filename> 안에.
     이 방법의 단 한가지 단점은 다음과 같은 줄을 PHP 태그를 포함하는
     모든 파일의 첫번째 줄에 넣어야 한다는 점입니다:
     <informalexample>
      <programlisting>
<![CDATA[
#!/usr/local/bin/php
]]>
      </programlisting>
     </informalexample>
     또한 파일을 실행 가능하게 해 둘 필요가 있습니다. 이것은 정확하게
     실행을 위해서 <literal>#!</literal> 쉘 이스케이핑 메카니즘을 사용하는
     펄이나 sh, 혹은 다른 일반적인 스크립팅 언어로 쓰여진 CGI 스크립트와
     동일하게 취급합니다.
    </para>
    <para>
     이 방법을 사용할 때, PHP가 <envar>PATH_INFO</envar>와
     <envar>PATH_TRANSLATED</envar>를 올바르게 다룰 수 있게 하기 위해서는
     PHP 파서를 컴파일 할 때,
     <link linkend="install.configure.enable-discard-path">--enable-discard-path</link>
     옵션을 주어야 합니다.
    </para>
   </sect2>

  </sect1>

  <sect1 id="security.apache">
   <title>아파치 모듈로 설치</title>
   <simpara>
    When PHP is used as an Apache module it inherits Apache's user
    permissions (typically those of the "nobody" user). This has several
    impacts on security and authorization. For example, if you are using
    PHP to access a database, unless that database has built-in access
    control, you will have to make the database accessible to the
    "nobody" user. This means a malicious script could access and modify
    the database, even without a username and password. It's entirely
    possible that a web spider could stumble across a database
    administrator's web page, and drop all of your databases. You can
    protect against this with Apache authorization, or you can design
    your own access model using LDAP, &htaccess; files, etc. and include
    that code as part of your PHP scripts.
   </simpara>
   <simpara>
    Often, once security is established to the point where the PHP user
    (in this case, the apache user) has very little risk attached to it,
    it is discovered that PHP is now prevented from writing any files
    to user directories. Or perhaps it has been prevented from accessing
    or changing databases. It has equally been secured from writing
    good and bad files, or entering good and bad database transactions.
   </simpara>
   <simpara>
    A frequent security mistake made at this point is to allow apache
    root permissions, or to escalate apache's abilitites in some other
    way.
   </simpara>
   <simpara>
    Escalating the Apache user's permissions to root is extremely
    dangerous and may compromise the entire system, so sudo'ing,
    chroot'ing, or otherwise running as root should not be considered by
    those who are not security professionals.
   </simpara>
   <simpara>
    There are some simpler solutions. By using
    <link linkend="ini.open-basedir">open_basedir</link> you can control and restrict what
    directories are allowed to be used for PHP. You can also set up
    apache-only areas, to restrict all web based activity to non-user,
    or non-system, files.
   </simpara>
  </sect1>

  <sect1 id="security.filesystem">
   <title>파일시스템 보안</title>
   <simpara>
    PHP is subject to the security built into most server systems with
    respect to permissions on a file and directory basis. This allows
    you to control which files in the filesystem may be read. Care
    should be taken with any files which are world readable to ensure
    that they are safe for reading by all users who have access to that
    filesystem.
   </simpara>
   <simpara>
    Since PHP was designed to allow user level access to the filesystem,
    it's entirely possible to write a PHP script that will allow you
    to read system files such as /etc/passwd, modify your ethernet
    connections, send massive printer jobs out, etc. This has some
    obvious implications, in that you need to ensure that the files
    that you read from and write to are the appropriate ones.
   </simpara>
   <simpara>
    Consider the following script, where a user indicates that they'd
    like to delete a file in their home directory. This assumes a
    situation where a PHP web interface is regularly used for file
    management, so the Apache user is allowed to delete files in
    the user home directories.
   </simpara>
   <para>
    <example>
     <title>Poor variable checking leads to....</title>
     <programlisting role="php">
<![CDATA[
<?php
// remove a file from the user's home directory
$username = $_POST['user_submitted_name'];
$homedir = "/home/$username";
$file_to_delete = "$userfile";
unlink ("$homedir/$userfile");
echo "$file_to_delete has been deleted!";
?>
]]>
     </programlisting>
    </example>
   Since the username is postable from a user form, they can submit
   a username and file belonging to someone else, and delete files.
   In this case, you'd want to use some other form of authentication.
   Consider what could happen if the variables submitted were
   "../etc/" and "passwd". The code would then effectively read:
    <example>
     <title>... A filesystem attack</title>
     <programlisting role="php">
<![CDATA[
<?php
// removes a file from anywhere on the hard drive that
// the PHP user has access to. If PHP has root access:
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd has been deleted!";
?>
]]>
     </programlisting>
    </example>
    There are two important measures you should take to prevent these
    issues.
    <itemizedlist>
     <listitem>
      <simpara>
       Only allow limited permissions to the PHP web user binary.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Check all variables which are submitted.
      </simpara>
     </listitem>
    </itemizedlist>
    Here is an improved script:
    <example>
     <title>More secure file name checking</title>
     <programlisting role="php">
<![CDATA[
<?php
// removes a file from the hard drive that
// the PHP user has access to.
$username = $_SERVER['REMOTE_USER']; // using an authentication mechanisim

$homedir = "/home/$username";

$file_to_delete = basename("$userfile"); // strip paths
unlink ($homedir/$file_to_delete);

$fp = fopen("/home/logging/filedelete.log","+a"); //log the deletion
$logstring = "$username $homedir $file_to_delete";
fputs ($fp, $logstring);
fclose($fp);

echo "$file_to_delete has been deleted!";
?>
]]>
     </programlisting>
    </example>
    However, even this is not without it's flaws. If your authentication
    system allowed users to create their own user logins, and a user
    chose the login "../etc/", the system is once again exposed. For
    this reason, you may prefer to write a more customized check:
    <example>
     <title>More secure file name checking</title>
     <programlisting role="php">
<![CDATA[
<?php
$username = $_SERVER['REMOTE_USER']; // using an authentication mechanisim
$homedir = "/home/$username";

if (!ereg('^[^./][^/]*$', $userfile))
     die('bad filename'); //die, do not process

if (!ereg('^[^./][^/]*$', $username))
     die('bad username'); //die, do not process
//etc...
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Depending on your operating system, there are a wide variety of files
    which you should be concerned about, including device entries (/dev/
    or COM1), configuration files (/etc/ files and the .ini files),
    well known file storage areas (/home/, My Documents), etc. For this
    reason, it's usually easier to create a policy where you forbid
    everything except for what you explicitly allow.
   </para>
  </sect1>

  <sect1 id="security.database">
   <title>데이터베이스 보안</title>
   <simpara>
    Nowadays, databases are cardinal components of any web based application by
    enabling websites to provide varying dynamic content. Since very sensitive
    or secret informations  can be stored in such database, you should strongly
    consider to protect them somehow.
   </simpara>
   <simpara>
    To retrieve or to store any information you need to connect to the database,
    send a legitimate query, fetch the result, and close the connecion.
    Nowadays, the commonly used query language in this interaction is the
    Structured Query Language (SQL). See how an attacker can <link
    linkend="security.database.sql-injection">tamper with an SQL query</link>.
   </simpara>
   <simpara>
    As you can realize, PHP cannot protect your database by itself. The
    following sections aim to be an introduction into the very basics of how to
    access and manipulate databases within PHP scripts.
   </simpara>
   <simpara>
    Keep in mind this simple rule: defence in depth. In the more place you
    take the more action to increase the protection of your database, the less
    probability of that an attacker succeeds, and exposes or abuse any stored
    secret information. Good design of the database schema and the application
    deals with your greatest fears.
   </simpara>

   <sect2 id="security.database.design">
    <title>데이터베이스 디자인</title>
     <simpara>
      The first step is always to create the database, unless you want to use
      an existing third party's one. When a database is created, it is
      assigned to an owner, who executed the creation statement. Usually, only
      the owner (or a superuser) can do anything with the objects in that
      database, and in order to allow other users to use it, privileges must be
      granted.
     </simpara>
     <simpara>
      Applications should never connect to the database as its owner or a
      superuser, because these users can execute any query at will, for
      example, modifying the schema (e.g. dropping tables) or deleting its
      entire content.
     </simpara>
     <simpara>
      You may create different database users for every aspect of your
      application with very limited rights to database objects. The most
      required privileges should be granted only, and avoid that the same user
      can interact with the database in different use cases. This means that if
      intruders gain access to your database using one of these credentials,
      they can only effect as many changes as your application can.
     </simpara>
     <simpara>
      You are encouraged not to implement all the business logic in the web
      application (i.e. your script), instead to do it in the database schema
      using views, triggers or rules. If the system evolves, new ports will be
      intended to open to the database, and you have to reimplement the logic
      in each separate database client. Over and above, triggers can be used
      to transparently and automatically handle fields, which often provides
      insight when debugging problems with your application or tracing back
      transactions.
     </simpara>
   </sect2>

   <sect2 id="security.database.connection">
    <title>데이터베이스 접속</title>
    <simpara>
     You may want to estabilish the connections over SSL to encrypt
     client/server communications for increased security, or you can use ssh
     to encrypt the network connection between clients and the database server.
     If either of them is done, then monitoring your traffic and gaining
     informations in this way will be a hard work.
    </simpara>
    <!--simpara>
     If your database server has native SSL support, consider to use <link
     linkend="ref.openssl">OpenSSL functions</link> in communication between
     PHP and database via SSL.
    </simpara-->
   </sect2>

   <sect2 id="security.database.storage">
    <title>암호화 저장 모델</title>
    <simpara>
     SSL/SSH protects data travelling from the client to the server, SSL/SSH
     does not protect the persistent data stored in a database. SSL is an
     on-the-wire protocol.
    </simpara>
    <simpara>
     Once an attacker gains access to your database directly (bypassing the
     webserver), the stored sensitive data may be exposed or misused, unless
     the information is protected by the database itself. Encrypting the data
     is a good way to mitigate this threat, but very few databases offer this
     type of data encryption.
    </simpara>
    <simpara>
     The easiest way to work around this problem is to first create your own
     encryption package, and then use it from within your PHP scripts. PHP
     can assist you in this case with its several extensions, such as <link
     linkend="ref.mcrypt">Mcrypt</link> and <link
     linkend="ref.mhash">Mhash</link>, covering a wide variety of encryption
     algorithms. The script encrypts the data be stored first, and decrypts
     it when retrieving. See the references for further examples how
     encryption works.
    </simpara>
    <simpara>
     In case of truly hidden data, if its raw representation is not needed
     (i.e. not be displayed), hashing may be also taken into consideration.
     The well-known example for the hashing is storing the MD5 hash of a
     password in a database, instead of the password itself. See also
     <function>crypt</function> and <function>md5</function>.
    </simpara>
    <example>
     <title>Using hashed password field</title>
     <programlisting role="php">
<![CDATA[
// storing password hash
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

// querying if user submitted the right password
$query = sprintf("SELECT 1 FROM users WHERE name='%s' AND pwd='%s';",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

if (pg_numrows($result) > 0) {
    echo "Welcome, $username!";
}
else {
    echo "Authentication failed for $username.";
}
]]>
     </programlisting>
    </example>
   </sect2>

   <sect2 id="security.database.sql-injection">
    <title>SQL 인젝션</title>
    <simpara>
     Many web developers are unaware of how SQL queries can be tampered with,
     and assume that an SQL query is a trusted command. It means that SQL
     queries are able to circumvent access controls, thereby bypassing standard
     authentication and authorization checks, and sometimes SQL queries even
     may allow access to host operating system level commands.
    </simpara>
    <simpara>
     Direct SQL Command Injection is a technique where an attacker creates or
     alters existing SQL commands to expose hidden data, or to override valuable
     ones, or even to execute dangerous system level commands on the database
     host. This is accomplished by the application taking user input and
     combining it with static parameters to build a SQL query. The following
     examples are based on true stories, unfortunately.
    </simpara>
    <para>
     Owing to the lack of input validation and connecting to the database on
     behalf of a superuser or the one who can create users, the attacker
     may create a superuser in your database.
     <example>
      <title>
       Splitting the result set into pages ... and making superusers
       (PostgreSQL and MySQL)
      </title>
      <programlisting role="php">
<![CDATA[
$offset = argv[0]; // beware, no input validation!
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
// with PostgreSQL 
$result = pg_exec($conn, $query);
// with MySQL
$result = mysql_query($query);
]]>
      </programlisting>
     </example>
      Normal users click on the 'next', 'prev' links where the <varname>$offset</varname>
      is encoded into the URL. The script expects that the incoming
      <varname>$offset</varname> is decimal number. However, someone tries to
      break in with appending <function>urlencode</function>'d form of the
      following to the URL 
      <informalexample>
       <programlisting>
<![CDATA[
// in case of PostgreSQL
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--

// in case of MySQL
0;
UPDATE user SET Password=PASSWORD('crack') WHERE user='root';
FLUSH PRIVILEGES;
]]>
       </programlisting>
      </informalexample>
      If it happened, then the script would present a superuser access to him.
      Note that <literal>0;</literal> is to supply a valid offset to the
      original query and to terminate it.
    </para>
    <note>
     <para>
      It is common technique to force the SQL parser to ignore the rest of the
      query written by the developer with <literal>--</literal> which is the
      comment sign in SQL.
     </para>
    </note>
    <para>
     A feasible way to gain passwords is to circumvent your search result pages.
     What the attacker needs only is to try if there is any submitted variable
     used in SQL statement which is not handled properly. These filters can be set 
     commonly in a preceding form to customize <literal>WHERE, ORDER BY, 
     LIMIT</literal> and <literal>OFFSET</literal> clauses in <literal>SELECT</literal>
     statements. If your database supports the <literal>UNION</literal> construct, 
     the attacker may try to append an entire query to the original one to list 
     passwords from an arbitrary table. Using encrypted password fields is 
     strongly encouraged.
     <example>
      <title>
       Listing out articles ... and some passwords (any database server)
      </title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT id, name, inserted, size FROM products
                  WHERE size = '$size'
                  ORDER BY $order LIMIT $limit, $offset;";
$result = odbc_exec($conn, $query);
]]>
      </programlisting>
     </example>
     The static part of the query can be combined with another
     <literal>SELECT</literal> statement which reveals all passwords:
     <informalexample>
      <programlisting>
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </informalexample>
     If this query (playing with the <literal>'</literal> and
     <literal>--</literal>) were assigned to one of the variables used in
     <varname>$query</varname>, the query beast awakened.
    </para>
    <para>
     SQL UPDATEs are also subject to attacking your database. These queries are
     also threatened by chopping and appending an entirely new query to it. But
     the attacker might fiddle with the <literal>SET</literal> clause. In this
     case some schema information must be possessed to manipulate the query
     successfully. This can be acquired by examining the form variable names, or
     just simply brute forcing. There are not so many naming convention for
     fields storing passwords or usernames.
     <example>
     <title>
      From resetting a password ... to gaining more privileges (any database server)
     </title>
      <programlisting role="php">
<![CDATA[
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
]]>
      </programlisting>
     </example>
     But a malicious user sumbits the value
     <literal>' or uid like'%admin%'; --</literal> to <varname>$uid</varname> to
     change the admin's password, or simply sets <varname>$pwd</varname> to
     <literal>"hehehe', admin='yes', trusted=100 "</literal> (with a trailing
     space) to gain more privileges. Then, the query will be twisted:
     <informalexample>
      <programlisting role="php">
<![CDATA[
// $uid == ' or uid like'%admin%'; --
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$query = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;"
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     A frightening example how operating system level commands can be accessed
     on some database hosts.
     <example>
     <title>Attacking the database host's operating system (MSSQL Server)</title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);
]]>
      </programlisting>
     </example>
     If attacker submits the value
     <literal>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</literal>
     to <varname>$prod</varname>, then the <varname>$query</varname> will be:
     <informalexample>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$result = mssql_query($query);
]]>
      </programlisting>
     </informalexample>
     MSSQL Server executes the SQL statements in the batch including a command
     to add a new user to the local accounts database. If this application
     were running as <literal>sa</literal> and the MSSQLSERVER service is
     running with sufficient privileges, the attacker would now have an
     account with which to access this machine.
    </para>
    <note>
     <para>
      Some of the examples above is tied to a specific database server. This
      does not mean that a similar attack is impossible against other products.
      Your database server may be so vulnerable in other manner.
     </para>
    </note>

    <sect3 id="security.database.avoiding">
     <title>회피 테크닉</title>
     <simpara>
      You may plead that the attacker must possess a piece of information
      about the database schema in most examples. You are right, but you
      never know when and how it can be taken out, and if it happens,
      your database may be exposed. If you are using an open source, or
      publicly available database handling package, which may belong to a
      content management system or forum, the intruders easily produce
      a copy of a piece of your code. It may be also a security risk if it
      is a poorly designed one.
     </simpara>
     <simpara>
      These attacks are mainly based on exploiting the code not being written
      with security in mind. Never trust on any kind of input, especially
      which comes from the client side, even though it comes from a select box,
      a hidden input field or a cookie. The first example shows that such a
      blameless query can cause disasters.
     </simpara>

     <itemizedlist>
      <listitem>
       <simpara>
        Never connect to the database as a superuser or as the database owner.
        Use always customized users with very limited privileges.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Check if the given input has the expected data type. PHP has
        a wide range of input validating functions, from the simplest ones
        found in <link linkend="ref.variables">Variable Functions</link> and
        in <link linkend="ref.ctype">Character Type Functions</link>
        (e.g. <function>is_numeric</function>, <function>ctype_digit</function>
        respectively) onwards the
        <link linkend="ref.pcre">Perl compatible Regular Expressions</link>
        support.
       </simpara>
      </listitem>
      <listitem>
       <para>
        If the application waits for numerical input, consider to verify data
        with <function>is_numeric</function>, or silently change its type
        using <function>settype</function>, or use its numeric representation
        by <function>sprintf</function>.
        <example>
         <title>A more secure way to compose a query for paging</title>
         <programlisting role="php">
<![CDATA[
settype($offset, 'integer');
$query = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";

// please note %d in the format string, using %s would be meaningless
$query = sprintf("SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET %d;",
                 $offset);
]]>
         </programlisting>
        </example>
       </para>
      </listitem>
      <listitem>
       <simpara>
        Quote each non numeric user input which is passed to the database with
        <function>addslashes</function> or <function>addcslashes</function>.
        See <link linkend="security.database.storage">the first example</link>.
        As the examples shows, quotes burnt into the static part of the query
        is not enough, and can be easily hacked.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Do not print out any database specific information, especially
        about the schema, by fair means or foul. See also <link
        linkend="security.errors">Error Reporting</link> and <link
        linkend="ref.errorfunc">Error Handling and Logging Functions</link>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        You may use stored procedures and previously defined cursors to abstract
        data access so that users do not directly access tables or views, but
        this solution has another impacts.
       </simpara>
      </listitem>
     </itemizedlist>

     <simpara>
      Besides these, you benefit from logging queries either within your script
      or by the database itself, if it supports. Obviously, the logging is unable
      to prevent any harmful attempt, but it can be helpful to trace back which
      application has been circumvented. The log is not useful by itself, but
      through the information it contains. The more detail is generally better.
     </simpara>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="security.errors">
   <title>에러 리포팅</title>
   <para>
    With PHP security, there are two sides to error reporting. One is
    beneficial to increasing security, the other is detrimental.
   </para>
   <para>
    A standard attack tactic involves profiling a system by feeding
    it improper data, and checking for the kinds, and contexts, of the
    errors which are returned. This allows the system cracker to probe
    for information about the server, to determine possible weaknesses.
    For example, if an attacker had gleaned information about a page
    based on a prior form submission, they may attempt to override
    variables, or modify them:
    <example>
     <title>Attacking Variables with a custom HTML page</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="attacktarget?username=badfoo&password=badfoo">
<input type="hidden" name="username" value="badfoo">
<input type="hidden" name="password" value="badfoo">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    The PHP errors which are normally returned can be quite helpful to a
    developer who is trying to debug a script, indicating such things
    as the function or file that failed, the PHP file it failed in,
    and the line number which the failure occured in. This is all
    information that can be exploited.  It is not uncommon for a php
    developer to use <function>show_source</function>,
    <function>highlight_string</function>, or
    <function>highlight_file</function> as a debugging measure, but in
    a live site, this can expose hidden variables, unchecked syntax,
    and other dangerous information. Especially dangerous is running
    code from known sources with built-in debugging handlers, or using
    common debugging techniques. If the attacker can determine what
    general technique you are using, they may try to brute-force a page,
    by sending various common debugging strings:
    <example>
     <title>Exploiting common debugging variables</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="attacktarget?errors=Y&amp;showerrors=1&amp;debug=1">
<input type="hidden" name="errors" value="Y">
<input type="hidden" name="showerrors" value="1">
<input type="hidden" name="debug" value="1">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Regardless of the method of error handling, the ability to probe a
    system for errors leads to providing an attacker with more
    information.
   </para>
   <para>
    For example, the very style of a generic PHP error indicates a system
    is running PHP. If the attacker was looking at an .html page, and
    wanted to probe for the back-end (to look for known weaknesses in
    the system), by feeding it the wrong data they may be able to
    determine that a system was built with PHP.
   </para>
   <para>
    A function error can indicate whether a system may be running a
    specific database engine, or give clues as to how a web page or
    programmed or designed. This allows for deeper investigation into
    open database ports, or to look for specific bugs or weaknesses
    in a web page. By feeding different pieces of bad data, for example,
    an attacker can determine the order of authentication in a script,
    (from the line number errors) as well as probe for exploits that
    may be exploited in different locations in the script.
   </para>
   <para>
    A filesystem or general PHP error can indicate what permissions
    the webserver has, as well as the structure and organization of
    files on the web server. Developer written error code can aggravate
    this problem, leading to easy exploitation of formerly "hidden"
    information.
   </para>
   <para>
    There are three major solutions to this issue. The first is to
    scrutinize all functions, and attempt to compensate for the bulk
    of the errors. The second is to disable error reporting entirely
    on the running code. The third is to use PHP's custom error
    handling functions to create your own error handler. Depending
    on your security policy, you may find all three to be applicable
    to your situation.
   </para>
   <para>
    One way of catching this issue ahead of time is to make use of
    PHP's own <function>error_reporting</function>, to help you
    secure your code and find variable usage that may be dangerous.
    By testing your code, prior to deployment, with E_ALL, you can
    quickly find areas where your variables may be open to poisoning
    or modification in other ways. Once you are ready for deployment,
    by using E_NONE, you insulate your code from probing.
    <example>
     <title>Finding dangerous variables with E_ALL</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($username) {  // Not initialized or checked before usage
    $good_login = 1;
}
if ($good_login == 1) { // If above test fails, not initialized or checked before usage
    readfile ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="security.registerglobals">
   <title>전역 등록(Register Globals) 사용</title>
   <para>
    Perhaps the most controversial change in PHP is when the default value
    for the PHP directive <link linkend="ini.register-globals">
    register_globals</link> went from ON to OFF in PHP 
    <ulink url="&url.php.release4.2.0;">4.2.0</ulink>.  Reliance on this
    directive was quite common and many people didn't even know it existed
    and assumed it's just how PHP works.  This page will explain how one can
    write insecure code with this directive but keep in mind that the
    directive itself isn't insecure but rather it's the misuse of it.
   </para>
   <para>
    When on, register_globals will inject (poison) your scripts will all
    sorts of variables, like request variables from html forms.  This
    coupled with the fact that PHP doesn't require variable initialization
    means writing insecure code is that much easier.  It was a difficult
    decision, but the PHP community decided to disable this directive by 
    default.  When on, people use variables yet really don't know for sure
    where they come from and can only assume.  Internal variables that are
    defined in the script itself get mixed up with request data sent by
    users and disabling register_globals changes this.  Let's demonstrate
    with an example misuse of register_globals: 
   </para>
   <para>
    <example>
     <title>Example misuse with register_globals = on</title>
     <programlisting role="php">
<![CDATA[
<?php
// define $authorized = true only if user is authenticated
if (authenticated_user()) {
    $authorized = true;
}

// Because we didn't first initialize $authorized as false, this might be
// defined through register_globals, like from GET auth.php?authorized=1 
// So, anyone can be seen as authenticated!
if ($authorized) {
    include "/highly/sensitive/data.php";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    When register_globals = on, our logic above may be compromised.  When
    off, <varname>$authorized</varname> can't be set via request so it'll
    be fine, although it really is generally a good programming practice to 
    initialize variables first.  For example, in our example above we might
    have first done <literal>$authorized = false</literal>.  Doing this
    first means our above code would work with register_globals on or off as 
    users by default would be unauthorized.
   </para>
   <para>
    Another example is that of <link linkend="ref.session">sessions</link>.
    When register_globals = on, we could also use
    <varname>$username</varname> in our example below but again you must
    realize that <varname>$username</varname> could also come from other
    means, such as GET (through the URL).  
   </para>
   <para>
    <example>
     <title>Example use of sessions with register_globals on or off</title>
     <programlisting role="php">
<![CDATA[
<?php
// We wouldn't know where $username came from but do know $_SESSION is 
// for session data 
if (isset($_SESSION['username'])) {
    
    echo "Hello <b>{$_SESSION['username']}</b>";

} else {
    
    echo "Hello <b>Guest</b><br />";
    echo "Would you like to login?";

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    It's even possible to take preventative measures to warn when forging is
    being attempted. If you know ahead of time exactly where a variable
    should be coming from, you can check to see if the submitted data is
    coming from an inappropriate kind of submission.  While it doesn't
    guarantee that data has not been forged, it does require an attacker to
    guess the right kind of forging.  If you don't care where the request
    data comes from, you can use <varname>$_REQUEST</varname> as it contains
    a mix of GET, POST and COOKIE data.  See also the manual section on
    using <link linkend="language.variables.external">variables from outside
    of PHP</link>. 
   </para>
   <para>
    <example>
     <title>Detecting simple variable poisoning</title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($_COOKIE['MAGIC_COOKIE'])) {
    
    // MAGIC_COOKIE comes from a cookie.
    // Be sure to validate the cookie data!

} elseif (isset($_GET['MAGIC_COOKIE']) || isset($_POST['MAGIC_COOKIE'])) {
   
   mail("admin@example.com", "Possible breakin attempt", $_SERVER['REMOTE_ADDR']);
   echo "Security violation, admin has been alerted.";
   exit;

} else {
   
   // MAGIC_COOKIE isn't set through this REQUEST

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Of course, simply turning off register_globals does not mean your code
    is secure.  For every piece of data that is submitted, it should also be
    checked in other ways.  Always validate your user data and initialize
    your variables!  To check for unitialized variables you may turn up
    <function>error_reporting</function> to show
    <constant>E_NOTICE</constant> level errors.
   </para>
   
   &note.superglobals;

  </sect1>


  <sect1 id="security.variables">
   <title>유저 송신 데이터</title>
   <para>
    The greatest weakness in many PHP programs is not inherent in the
    language itself, but merely an issue of code not being written with
    security in mind. For this reason, you should always take the time
    to consider the implications of a given piece of code, to ascertain
    the possible damage if an unexpected variable is submitted to it.
    <example>
     <title>Dangerous Variable Usage</title>
     <programlisting role="php">
<![CDATA[
<?php
// remove a file from the user's home directory... or maybe
// somebody else's?
unlink ($evil_var);

// Write logging of their access... or maybe an /etc/passwd entry?
fputs ($fp, $evil_var);

// Execute something trivial.. or rm -rf *?
system ($evil_var);
exec ($evil_var);

?>
]]>
     </programlisting>
    </example>
    You should always carefully examine your code to make sure that any
    variables being submitted from a web browser are being properly
    checked, and ask yourself the following questions:
    <itemizedlist>
     <listitem>
      <simpara>
       Will this script only affect the intended files?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Can unusual or undesirable data be acted upon?
      </simpara>
     </listitem>
     <listitem>
     <simpara>
       Can this script be used in unintended ways?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Can this be used in conjunction with other scripts in a negative
       manner?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Will any transactions be adequately logged?
      </simpara>
     </listitem>
    </itemizedlist>
    By adequately asking these questions while writing the script,
    rather than later, you prevent an unfortunate re-write when you
    need to increase your security. By starting out with this mindset,
    you won't guarantee the security of your system, but you can help
    improve it.
   </para>
   <para>
    You may also want to consider turning off register_globals,
    magic_quotes, or other convenience settings which may confuse
    you as to the validity, source, or value of a given variable.
    Working with PHP in error_reporting(E_ALL) mode can also help warn
    you about variables being used before they are checked or
    initialized (so you can prevent unusual data from being
    operated upon).
   </para>
  </sect1>

  <sect1 id="security.hiding">
   <title>PHP 숨기기</title>
   <para>
    In general, security by obscurity is one of the weakest forms of security.
    But in some cases, every little bit of extra security is desirable.
   </para>
   <para>
    A few simple techniques can help to hide PHP, possibly slowing
    down an attacker who is attempting to discover weaknesses in your
    system. By setting expose_php = off in your &php.ini; file, you
    reduce the amount of information available to them.
   </para>
   <para>
    Another tactic is to configure web servers such as apache to
    parse different filetypes through PHP, either with an &htaccess;
    directive, or in the apache configuration file itself. You can
    then use misleading file extensions:
    <example>
     <title>Hiding PHP as another language</title>
     <programlisting role="apache-conf">
<![CDATA[
# Make PHP code look like other code types
AddType application/x-httpd-php .asp .py .pl
]]>
     </programlisting>
    </example>
    Or obscure it completely:
    <example>
     <title>Using unknown types for PHP extensions</title>
     <programlisting role="apache-conf">
<![CDATA[
# Make PHP code look like unknown types
AddType application/x-httpd-php .bop .foo .133t
]]>
     </programlisting>
    </example>
    Or hide it as html code, which has a slight performance hit because
    all html will be parsed through the PHP engine:
    <example>
     <title>Using html types for PHP extensions</title>
     <programlisting role="apache-conf">
<![CDATA[
# Make all PHP code look like html
AddType application/x-httpd-php .htm .html
]]>
     </programlisting>
    </example>
    For this to work effectively, you must rename your PHP files with
    the above extensions. While it is a form of security through
    obscurity, it's a minor preventative measure with few drawbacks.
   </para>
  </sect1>

  <sect1 id="security.current">
   <title>최신 버전 유지</title>
   <simpara>
    PHP, like any other large system, is under constant scrutiny and
    improvement. Each new version will often include both major and
    minor changes to enhance and repair security flaws, configuration
    mishaps, and other issues that will affect the overall security
    and stability of your system.
   </simpara>
   <simpara>
    Like other system-level scripting languages and programs, the best
    approach is to update often, and maintain awareness of the latest
    versions and their changes.
   </simpara>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
