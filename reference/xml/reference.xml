<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.12 Maintainer: progcom Status: working -->
 <reference id="ref.xml">
  <title>XML 파서 함수</title>
  <titleabbrev>XML</titleabbrev>

  <partintro>

   <section id="xml.intro">
    &reftitle.intro;
    <para>
     XML(eXtensible Markup Language)은 웹에서 구조화된 문서 교환을 위한 데이터
     형식입니다. The World Wide Web consortium(W3C)에서 정의한 표준입니다.
     XML과 관련 기술에 대한 정보는 <ulink
     url="&url.xml;">&url.xml;</ulink>에서 볼 수 있습니다.
    </para>
    <para>
     PHP 확장은 James Clark의 <productname>expat</productname>를 사용합니다.
     이 툴킷은 XML 문서를 처리할 수 있게 하지만, 유효성을 검증하지는 않습니다.
     PHP에서도 지원하는 세가지 <link linkend="xml.encoding">문자
     인코딩</link>을 지원합니다: <literal>US_ASCII</literal>,
     <literal>ISO-8859-1</literal>, <literal>UTF-8</literal>.
     <literal>UTF-16</literal>은 지원하지 않습니다.
    </para>
    <para>
     이 확장은 <link linkend="function.xml-parser-create">XML 파서를
     작성</link>하고 여러가지 XML 이벤트에 대한 <emphasis>핸들러</emphasis>를
     정의할 수 있게 합니다. 각각의 XML 파서는 조절할 수 있는 약간의 <link
     linkend="function.xml-parser-set-option">인자</link>를 가집니다.
    </para>
   </section>

   <section id="xml.requirements">
    &reftitle.required;
    <para>
     이 확장은 <ulink url="&url.expat;">&url.expat;</ulink>에서 찾을 수 있는
     <productname>expat</productname>를 사용합니다. expat에 들어있는
     Makefile은 기본값으로 라이브러리를 생성하지 않기 때문에, 다음의 make
     규칙을 사용할 수 있습니다:
     <programlisting role="makefile">
<![CDATA[
libexpat.a: $(OBJS)
    ar -rc $@ $(OBJS)
    ranlib $@
]]>
     </programlisting>
     expat의 소스 RPM 패키지는 <ulink
     url="&url.expat.rpm;">&url.expat.rpm;</ulink>에서 찾을 수 있습니다.
    </para>
   </section>

   &reference.xml.configure;

   <section id="xml.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section id="xml.resources">
    &reftitle.resources;
    <section id="xml.resources.xml">
     <title><literal>xml</literal></title>
     <para>
      <function>xml_parser_create</function>와
      <function>xml_parser_create_ns</function>가 반환하는
      <literal>xml</literal> 자원은 xml 파서 인스탠스를 참조하고, 이 확장이
      제공하는 함수들이 사용합니다.
     </para>
    </section>
   </section>

   &reference.xml.constants;

    <section id="xml.eventhandlers">
     <title>이벤트 핸들러</title>
     <para>
      정의된 XML 이벤트 핸들러는:
      <table>
       <title>지원하는 XML 핸들러</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>핸들러를 설정하는 PHP 함수</entry>
          <entry>이벤트 설명</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><function>xml_set_element_handler</function></entry>
          <entry>
           엘레멘트 이벤트는 XML 파서가 시작과 끝 태그에 도달했을 때
           발생합니다. 시작 태그와 끝 태그에 별도의 핸들러가 존재합니다.
          </entry>
         </row>
         <row>
          <entry>
           <function>xml_set_character_data_handler</function>
          </entry>
          <entry>
           Character data is roughly all the non-markup contents of
           XML documents, including whitespace between tags.  Note
           that the XML parser does not add or remove any whitespace,
           it is up to the application (you) to decide whether
           whitespace is significant.
          </entry>
         </row>
         <row>
          <entry>
           <function>xml_set_processing_instruction_handler</function>
          </entry>
          <entry>
           PHP 프로그래머는 이미 프로세싱 인스트럭션(PIs)에 익숙할 것입니다.
           &lt;?php ?&gt;는 프로세싱 인스트럭션이고,
           <replaceable>php</replaceable>은 "PI 타겟"이라 불립니다. 예약된
           "XML"로 시작하는 PI 타겟들을 제외하면, 이들에 대한 핸들링은
           어플리케이션 특화입니다.
          </entry>
         </row>
         <row>
          <entry><function>xml_set_default_handler</function></entry>
          <entry>
           What goes not to another handler goes to the default
           handler.  You will get things like the XML and document
           type declarations in the default handler.
          </entry>
         </row>
         <row>
          <entry>
           <function>xml_set_unparsed_entity_decl_handler</function>
          </entry>
          <entry>
           This handler will be called for declaration of an unparsed
           (NDATA) entity.
          </entry>
         </row>
         <row>
          <entry>
           <function>xml_set_notation_decl_handler</function>
          </entry>
          <entry>
           This handler is called for declaration of a notation.
          </entry>
         </row>
         <row>
          <entry>
           <function>xml_set_external_entity_ref_handler</function>
          </entry>
          <entry>
           This handler is called when the XML parser finds a
           reference to an external parsed general entity.  This can
           be a reference to a file or URL, for example.  See <link
           linkend="example.xml-external-entity">the external entity
           example</link> for a demonstration.
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
    </section>

    <section id="xml.case-folding">
     <title>케이스 접기</title>
     <para>
      The element handler functions may get their element names
      <glossterm>case-folded</glossterm>.  Case-folding is defined by
      the XML standard as "a process applied to a sequence of
      characters, in which those identified as non-uppercase are
      replaced by their uppercase equivalents".  In other words, when
      it comes to XML, case-folding simply means uppercasing.
     </para>
     <para>
      By default, all the element names that are passed to the handler
      functions are case-folded.  This behaviour can be queried and
      controlled per XML parser with the
      <function>xml_parser_get_option</function> and
      <function>xml_parser_set_option</function> functions,
      respectively.
     </para>
    </section>

    <section id="xml.error-codes">
     <title>오류 코드</title>
     <para>
      다음 상수들이 XML 오류 코드로 정의되어 있습니다
      (<function>xml_parse</function>가 반환합니다):
      <simplelist>
       <member>XML_ERROR_NONE</member>
       <member>XML_ERROR_NO_MEMORY</member>
       <member>XML_ERROR_SYNTAX</member>
       <member>XML_ERROR_NO_ELEMENTS</member>
       <member>XML_ERROR_INVALID_TOKEN</member>
       <member>XML_ERROR_UNCLOSED_TOKEN</member>
       <member>XML_ERROR_PARTIAL_CHAR</member>
       <member>XML_ERROR_TAG_MISMATCH</member>
       <member>XML_ERROR_DUPLICATE_ATTRIBUTE</member>
       <member>XML_ERROR_JUNK_AFTER_DOC_ELEMENT</member>
       <member>XML_ERROR_PARAM_ENTITY_REF</member>
       <member>XML_ERROR_UNDEFINED_ENTITY</member>
       <member>XML_ERROR_RECURSIVE_ENTITY_REF</member>
       <member>XML_ERROR_ASYNC_ENTITY</member>
       <member>XML_ERROR_BAD_CHAR_REF</member>
       <member>XML_ERROR_BINARY_ENTITY_REF</member>
       <member>XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</member>
       <member>XML_ERROR_MISPLACED_XML_PI</member>
       <member>XML_ERROR_UNKNOWN_ENCODING</member>
       <member>XML_ERROR_INCORRECT_ENCODING</member>
       <member>XML_ERROR_UNCLOSED_CDATA_SECTION</member>
       <member>XML_ERROR_EXTERNAL_ENTITY_HANDLING</member>
      </simplelist>
     </para>
    </section>

    <section id="xml.encoding">
     <title>문자 인코딩</title>
     <para>
      PHP의 XML 확장은 <ulink url="&url.unicode;">유니코드</ulink> 문자셋을
      통해 서로 다른 <glossterm>문자 인코딩</glossterm>을 지원합니다. 문자
      인코딩에는 <glossterm>소스 인코딩</glossterm>과 <glossterm>타겟
      인코딩</glossterm>의 두 종류가 존재합니다. PHP 내부에서 문서 표현은
      항상 <literal>UTF-8</literal>로 인코드되어 있습니다.
     </para>
     <para>
      소스 인코딩은 XML 문서가 <link
       linkend="function.xml-parse">parse</link>되었을 때 이루어집니다. <link
       linkend="functoin.xml-parser-create">XML 파서를 작성</link>할 때, 소스
      인코딩을 지정할 수 있습니다. (이 인코딩은 XML 파서가 종료될때까지 변경할
      수 없습니다) 지원하는 소스 인코딩은 <literal>ISO-8859-1</literal>,
      <literal>US-ASCII</literal>, <literal>UTF-8</literal>입니다. 앞쪽의
      두개는 싱글-바이트 인코딩이기에, 각각의 문자는 하나의 바이트로
      표현됩니다. <literal>UTF-8</literal>은 1에서 4바이트 사이에서 다양한
      수의 비트(21까지)를 조합하여 인코드할 수 있습니다. PHP에서 사용하는 기본
      소스 인코딩은 <literal>ISO-8859-1</literal>입니다.
     </para>
     <para>
      타겟 인코딩은 PHP가 XML 핸들러 함수에 데이터를 넘길 때 이루어집니다. XML
      파서를 작성하면, 타겟 인코딩을 소스 인코딩과 동일하게 설정하지만, 이는
      언제라도 변경할 수 있습니다. The target encoding will affect character
      data as well as tag names and processing instruction targets.
     </para>
     <para>
      If the XML parser encounters characters outside the range that
      its source encoding is capable of representing, it will return
      an error.  
     </para>
     <para>
      If PHP encounters characters in the parsed XML document that can
      not be represented in the chosen target encoding, the problem
      characters will be "demoted".  Currently, this means that such
      characters are replaced by a question mark.
     </para>
    </section>

   <section id="xml.examples">
    &reftitle.examples;
    <para>
     XML 문서를 파싱하는 몇몇 예제 PHP 스크립트입니다.
    </para>
    <section id="example.xml-structure">
     <title>XML 엘레멘트 구조 예제</title>
     <para>
      This first example displays the structure of the start elements in
      a document with indentation.
      <example>
       <title>XML 엘레멘트 구조 보기</title>
       <programlisting role="php">
<![CDATA[
<?php
$file = "data.xml";
$depth = array();

function startElement($parser, $name, $attrs) {
    global $depth;
    for ($i = 0; $i < $depth[$parser]; $i++) {
        print "  ";
    }
    print "$name\n";
    $depth[$parser]++;
}

function endElement($parser, $name) {
    global $depth;
    $depth[$parser]--;
}

$xml_parser = xml_parser_create();
xml_set_element_handler($xml_parser, "startElement", "endElement");
if (!($fp = fopen($file, "r"))) {
    die("could not open XML input");
}

while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("XML error: %s at line %d",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
xml_parser_free($xml_parser);
?>
]]>
       </programlisting>
      </example>
     </para>
    </section>

    <section id="example.xml-map-tags">
     <title>XML 태그 매핑 예제</title>
     <para>
      <example>
       <title>XML을 HTML로 Map</title>
       <para>
        This example maps tags in an XML document directly to HTML
        tags.  Elements not found in the "map array" are ignored.  Of
        course, this example will only work with a specific XML
        document type.
       </para>
       <para>
        <programlisting role="php">
<![CDATA[
<?php
$file = "data.xml";
$map_array = array(
    "BOLD"     => "B",
    "EMPHASIS" => "I",
    "LITERAL"  => "TT"
);

function startElement($parser, $name, $attrs) {
    global $map_array;
    if ($htmltag == $map_array[$name]) {
        print "<$htmltag>";
    }
}

function endElement($parser, $name) {
    global $map_array;
    if ($htmltag == $map_array[$name]) {
        print "</$htmltag>";
    }
}

function characterData($parser, $data) {
    print $data;
}

$xml_parser = xml_parser_create();
// use case-folding so we are sure to find the tag in $map_array
xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, true);
xml_set_element_handler($xml_parser, "startElement", "endElement");
xml_set_character_data_handler($xml_parser, "characterData");
if (!($fp = fopen($file, "r"))) {
    die("could not open XML input");
}

while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("XML error: %s at line %d",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
xml_parser_free($xml_parser);
?>
]]>
        </programlisting>
       </para>
      </example>
     </para>
    </section>

    <section id="example.xml-external-entity">
     <title>XML External Entity Example</title>
     <para>
      This example highlights XML code.  It illustrates how to use an
      external entity reference handler to include and parse other
      documents, as well as how PIs can be processed, and a way of
      determining "trust" for PIs containing code.
     </para>
     <para>
      XML documents that can be used for this example are found below
      the example (<filename>xmltest.xml</filename> and
      <filename>xmltest2.xml</filename>.)
     </para>
     <para>
      <example>
       <title>External Entity Example</title>
       <programlisting role="php">
<![CDATA[
<?php
$file = "xmltest.xml";

function trustedFile($file) {
    // only trust local files owned by ourselves
    if (!eregi("^([a-z]+)://", $file) 
        && fileowner($file) == getmyuid()) {
            return true;
    }
    return false;
}

function startElement($parser, $name, $attribs) {
    print "&lt;<font color=\"#0000cc\">$name</font>";
    if (sizeof($attribs)) {
        while (list($k, $v) = each($attribs)) {
            print " <font color=\"#009900\">$k</font>=\"<font 
                   color=\"#990000\">$v</font>\"";
        }
    }
    print "&gt;";
}

function endElement($parser, $name) {
    print "&lt;/<font color=\"#0000cc\">$name</font>&gt;";
}

function characterData($parser, $data) {
    print "<b>$data</b>";
}

function PIHandler($parser, $target, $data) {
    switch (strtolower($target)) {
        case "php":
            global $parser_file;
            // If the parsed document is "trusted", we say it is safe
            // to execute PHP code inside it.  If not, display the code
            // instead.
            if (trustedFile($parser_file[$parser])) {
                eval($data);
            } else {
                printf("Untrusted PHP code: <i>%s</i>", 
                        htmlspecialchars($data));
            }
            break;
    }
}

function defaultHandler($parser, $data) {
    if (substr($data, 0, 1) == "&" && substr($data, -1, 1) == ";") {
        printf('<font color="#aa00aa">%s</font>', 
                htmlspecialchars($data));
    } else {
        printf('<font size="-1">%s</font>', 
                htmlspecialchars($data));
    }
}

function externalEntityRefHandler($parser, $openEntityNames, $base, $systemId,
                                  $publicId) {
    if ($systemId) {
        if (!list($parser, $fp) = new_xml_parser($systemId)) {
            printf("Could not open entity %s at %s\n", $openEntityNames,
                   $systemId);
            return false;
        }
        while ($data = fread($fp, 4096)) {
            if (!xml_parse($parser, $data, feof($fp))) {
                printf("XML error: %s at line %d while parsing entity %s\n",
                       xml_error_string(xml_get_error_code($parser)),
                       xml_get_current_line_number($parser), $openEntityNames);
                xml_parser_free($parser);
                return false;
            }
        }
        xml_parser_free($parser);
        return true;
    }
    return false;
}

function new_xml_parser($file) {
    global $parser_file;

    $xml_parser = xml_parser_create();
    xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, 1);
    xml_set_element_handler($xml_parser, "startElement", "endElement");
    xml_set_character_data_handler($xml_parser, "characterData");
    xml_set_processing_instruction_handler($xml_parser, "PIHandler");
    xml_set_default_handler($xml_parser, "defaultHandler");
    xml_set_external_entity_ref_handler($xml_parser, "externalEntityRefHandler");
    
    if (!($fp = @fopen($file, "r"))) {
        return false;
    }
    if (!is_array($parser_file)) {
        settype($parser_file, "array");
    }
    $parser_file[$xml_parser] = $file;
    return array($xml_parser, $fp);
}

if (!(list($xml_parser, $fp) = new_xml_parser($file))) {
    die("could not open XML input");
}

print "<pre>";
while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("XML error: %s at line %d\n",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
print "</pre>";
print "parse complete\n";
xml_parser_free($xml_parser);

?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      <example>
       <title>xmltest.xml</title>
       <programlisting role="xml">
<![CDATA[
<?xml version='1.0'?>
<!DOCTYPE chapter SYSTEM "/just/a/test.dtd" [
<!ENTITY plainEntity "FOO entity">
<!ENTITY systemEntity SYSTEM "xmltest2.xml">
]>
<chapter>
 <TITLE>Title &plainEntity;</TITLE>
 <para>
  <informaltable>
   <tgroup cols="3">
    <tbody>
     <row><entry>a1</entry><entry morerows="1">b1</entry><entry>c1</entry></row>
     <row><entry>a2</entry><entry>c2</entry></row>
     <row><entry>a3</entry><entry>b3</entry><entry>c3</entry></row>
    </tbody>
   </tgroup>
  </informaltable>
 </para>
 &systemEntity;
 <section id="about">
  <title>About this Document</title>
  <para>
   <!-- this is a comment -->
   <?php print 'Hi!  This is PHP version '.phpversion(); ?>
  </para>
 </section>
</chapter>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      This file is included from <filename>xmltest.xml</filename>:
      <example>
       <title>xmltest2.xml</title>
       <programlisting role="xml">
<![CDATA[
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY testEnt "test entity">
]>
<foo>
   <element attrib="value"/>
   &testEnt;
   <?php print "This is some more PHP code being executed."; ?>
</foo>
]]>
       </programlisting>
      </example>
     </para>
    </section>
   </section>
  </partintro>

&reference.xml.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
