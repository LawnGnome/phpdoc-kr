<?xml version="1.0" encoding="utf-8"?>
<!-- splitted from ./kr/functions/xml.xml, last change in rev 1.3 -->
<!-- last change to 'xml-parse-into-struct' in en/ tree in rev 1.11 -->
	<refentry id="function.xml-parse-into-struct">
		<refnamediv>
			<refname>xml_parse_into_struct</refname>
			<refpurpose>Parse XML data into an array structure</refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>xml_parse_into_struct</methodname>
					<methodparam><type>int</type><parameter>parser</parameter></methodparam>
					<methodparam><type>string</type><parameter>data</parameter></methodparam>
					<methodparam><type>array</type><parameter>&amp;values</parameter></methodparam>
					<methodparam><type>array</type><parameter>&amp;index</parameter></methodparam>
				</methodsynopsis>
			<para>
     This function parses an XML file into 2 parallel array
     structures, one (<parameter>index</parameter>) containing pointers 
     to the location of the appropriate values in the
     <parameter>values</parameter> array. These last two parameters
     must be passed by reference.
    </para>
			<para>
     Below is an example that illustrates the internal structure of
     the arrays being generated by the function. We use a simple
     <literal>note</literal> tag embeded inside a
     <literal>para</literal> tag, and then we parse this an print out
     the structures generated:
     <informalexample>
					<programlisting>
$simple = &quot;&lt;para&gt;&lt;note&gt;simple note&lt;/note&gt;&lt;/para&gt;&quot;;
$p = xml_parser_create();
xml_parse_into_struct($p,$simple,$vals,$index);
xml_parser_free($p);
echo "Index array\n";
print_r($index);
echo "\nVals array\n";
print_r($vals);
      </programlisting>
				</informalexample>
     When we run that code, the output will be:
     <informalexample>
					<programlisting>
Index array
Array
(
    [PARA] =&gt; Array
        (
            [0] =&gt; 0
            [1] =&gt; 2
        )

    [NOTE] =&gt; Array
        (
            [0] =&gt; 1
        )

)

Vals array
Array
(
    [0] =&gt; Array
        (
            [tag] =&gt; PARA
            [type] =&gt; open
            [level] =&gt; 1
        )

    [1] =&gt; Array
        (
            [tag] =&gt; NOTE
            [type] =&gt; complete
            [level] =&gt; 2
            [value] =&gt; simple note
        )

    [2] =&gt; Array
        (
            [tag] =&gt; PARA
            [type] =&gt; close
            [level] =&gt; 1
        )

)
      </programlisting>
				</informalexample>
			</para>
			<para>
     Event-driven parsing (based on the expat library) can get
     complicated when you have an XML document that is complex.
     This function does not produce a DOM style object, but it
     generates structures amenable of being transversed in a tree
     fashion. Thus, we can create objects representing the data
     in the XML file easily. Let's consider the following XML file
     representing a small database of aminoacids information:
     <example>
					<title>moldb.xml - small database of molecular information</title>
					<programlisting>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;moldb&gt;

    &lt;molecule&gt;
        &lt;name&gt;Alanine&lt;/name&gt;
        &lt;symbol&gt;ala&lt;/symbol&gt;
        &lt;code&gt;A&lt;/code&gt;
        &lt;type&gt;hydrophobic&lt;/type&gt;
    &lt;/molecule&gt;

    &lt;molecule&gt;
        &lt;name&gt;Lysine&lt;/name&gt;
        &lt;symbol&gt;lys&lt;/symbol&gt;
        &lt;code&gt;K&lt;/code&gt;
        &lt;type&gt;charged&lt;/type&gt;
    &lt;/molecule&gt;

&lt;/moldb&gt;
      </programlisting>
				</example>
      And some code to parse the document and generate the appropriate
      objects:
      <example>
					<title>
       parsemoldb.php - parses moldb.xml into and array of
       molecular objects
      </title>
					<programlisting role="php">
&lt;?php

class AminoAcid {
    var $name;  // aa name
    var $symbol;    // three letter symbol
    var $code;  // one letter code
    var $type;  // hydrophobic, charged or neutral
    
    function AminoAcid ($aa) {
        foreach ($aa as $k=&gt;$v)
            $this-&gt;$k = $aa[$k];
    }
}

function readDatabase($filename) {
    // read the xml database of aminoacids
    $data = implode(&quot;&quot;,file($filename));
    $parser = xml_parser_create();
    xml_parser_set_option($parser,XML_OPTION_CASE_FOLDING,0);
    xml_parser_set_option($parser,XML_OPTION_SKIP_WHITE,1);
    xml_parse_into_struct($parser,$data,$values,$tags);
    xml_parser_free($parser);

    // loop through the structures
    foreach ($tags as $key=&gt;$val) {
        if ($key == &quot;molecule&quot;) {
            $molranges = $val;
            // each contiguous pair of array entries are the 
            // lower and upper range for each molecule definition
            for ($i=0; $i &lt; count($molranges); $i+=2) {
                    $offset = $molranges[$i] + 1;
                $len = $molranges[$i + 1] - $offset;
                $tdb[] = parseMol(array_slice($values, $offset, $len));
            }
        } else {
            continue;
        }
    }
    return $tdb;
}

function parseMol($mvalues) {
    for ($i=0; $i &lt; count($mvalues); $i++)
        $mol[$mvalues[$i][&quot;tag&quot;]] = $mvalues[$i][&quot;value&quot;];
    return new AminoAcid($mol);
}

$db = readDatabase(&quot;moldb.xml&quot;);
echo "** Database of AminoAcid objects:\n";
print_r($db);

?&gt;
      </programlisting>
				</example>
      After executing <filename>parsemoldb.php</filename>, the variable
      <varname>$db</varname> contains an array of
      <classname>AminoAcid</classname> objects, and the output of the
      script confirms that:
      <informalexample>
					<programlisting>
** Database of AminoAcid objects:
Array
(
    [0] =&gt; aminoacid Object
        (
            [name] =&gt; Alanine
            [symbol] =&gt; ala
            [code] =&gt; A
            [type] =&gt; hydrophobic
        )

    [1] =&gt; aminoacid Object
        (
            [name] =&gt; Lysine
            [symbol] =&gt; lys
            [code] =&gt; K
            [type] =&gt; charged
        )

)
       </programlisting>
				</informalexample>
			</para>
		</refsect1>
	</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
