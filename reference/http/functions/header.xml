<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.19 Maintainer: progcom Status: ok -->
  <refentry id="function.header">
   <refnamediv>
    <refname>header</refname>
    <refpurpose>raw HTTP 헤더를 전송합니다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>설명</title>
     <methodsynopsis>
      <type>int</type><methodname>header</methodname>
      <methodparam><type>string</type><parameter>string</parameter></methodparam>
      <methodparam choice="opt"><type>bool</type><parameter>replace</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>http_response_code</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>header</function>은 raw <acronym>HTTP</acronym> 헤더를 전송하기
     위해 사용합니다. <acronym>HTTP</acronym> 헤더에 관한 자세한 정보는 <ulink
     url="&spec.http1.1;">HTTP/1.1 규격</ulink>을 참고하십시오.
    </para>
    <para>
     선택적인 <parameter>replace</parameter> 인자는 이전의 동일한 헤더를
     교체할지, 혹은 같은 형의 두번째 헤더로 덧붙일 것일지를 지시합니다.
     기본값은 교체이지만, 두번째 인자로 &flase;를 넘겨서 같은 형을 가지는
     복수의 헤더를 지시할 수 있습니다. 예를 들면:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
header('WWW-Authenticate: Negotiate');
header('WWW-Authenticate: NTLM', FALSE);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     두번째 선택적인 <parameter>http_resopnse_code</parameter>는 HTTP 응답
     코드를 지정한 값으로 강제합니다. (이 인자는 PHP 4.3.0 이상에서 사용할 수
     있습니다)
    </para>
    <para>
     두가지 특별한 헤더 호출이 존재합니다. 첫번째는 문자열
     "<literal>HTTP/</literal>"(대소문자는 무관)으로 시작하는, HTTP 상태
     코드를 출력하기 위해 사용하는 헤더입니다. 예를 들어, 아파치가 존재하지
     않는 파일들에 대한 요청을 (<literal>ErrorDocument</literal> 지시어를
     사용하여) PHP 스크립트가 처리하게 했다면, 스크립트가 정확한 상태 코드를
     출력하게 할 수 있습니다.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
header("HTTP/1.0 404 Not Found");
?>
]]>
     </programlisting>
    </informalexample>
   </para>
    <note>
     <para>
      <function>header</function> 호출이 처음이건 아니건에 관계 없이,
      HTTP 상태 헤더줄은 클라이언트에게 항상 처음으로 전송해야 합니다.
      HTTP 헤더가 전송되기 전에는 어떤 때라도 <function>header</function>을
      호출하여 상태를 덮어쓸 수 있습니다.
     </para>
    </note>
    <note>
     <para>
      PHP 3에서, 이는 PHP를 아파치 모듈로 컴파일 했을 때만 작동했습니다. 같은
      효과를 <literal>Status</literal> 헤더를 이용하여 얻을 수 있습니다.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
header("Status: 404 Not Found");
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </note>
    <para>
     두번째 특별한 경우는 "Location:" 헤더입니다. 이 헤더만을 전송할 뿐이
     아니라, 이전에 <literal>3xx</literal> 상태 코드를 설정하지 않는 한
     <literal>REDIERCT</literal> (302) 상태 코드를 브라우저에 반환합니다.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
header("Location: http://www.example.com/"); /* 브라우저 리다이렉트 */

/* 이 아래의 코드는 리다이렉트 되었을때는 실행되지 않습니다. */
exit;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      HTTP/1.1은 <ulink
      url="&spec.http1.1;-sec14.html#sec14.30">Location:</ulink>의 인자로
      scheme, hostname, 절대 경로를 포함하는 절대 <acronym>URI</acronym>를
      요구하고 있지만, 일부 클라이언트는 상대 URI도 받아들입니다. 일반적으로
      <literal>$_SERVER['HTTP_HOST']</literal>,
      <literal>$_SERVER['PHP_SELF']</literal>, <function>dirname</function>을
      사용하여 상대 경로에서 절대 경로를 만들 수 있습니다:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
header("Location: http://".$_SERVER['HTTP_HOST']
                      .dirname($_SERVER['PHP_SELF'])
                      ."/".$relative_url);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </note>
    <para>
     PHP 스크립트는 종종 서버와 클라이언트 브라우저 사이의 어떠한 프록시
     캐쉬나 클라이언트 브라우저가 캐쉬를 해서는 안되는 동적인 내용을
     생성합니다. 많은 프록시와 클라이언트에 캐쉬를 비활성화 시킬 수 있습니다:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// 과거의 날짜
header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");

// 항상 변경됨
header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT");
 
// HTTP/1.1
header("Cache-Control: no-store, no-cache, must-revalidate");
header("Cache-Control: post-check=0, pre-check=0", false);

// HTTP/1.0
header("Pragma: no-cache");
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      페이지가 위의 모든 헤더를 출력하지 않아도 캐쉬가 되지 않을 수 있습니다.
      사용자가 브라우저의 기본 캐쉬 방침을 바꿀 수 있는 수많은 옵션이
      존재합니다. 위의 헤더들을 전송해서, 어떠한 설정도 덮어씌워야 합니다.
      그렇지 않으면 스크립트의 출력이 캐쉬될 수 있습니다.
     </para>
     <para>
      추가적으로, <function>session_cache_limiter</function>과
      <literal>session.cache_limiter</literal> 설정으로 세션을 사용할 때
      자동적으로 적합한 캐쉬 관련 헤더를 생성할 수 있습니다.
     </para>
    </note>
    <para>
     <function>header</function>는 보통의 HTML 태그, 파일의 빈 줄, PHP 생성을
     포함하여 어떠한 출력도 전송되기 전에 호출해야 합니다.
     <function>header</function> 호출이 이루어지기 전에
     <function>include</function>, <function>require</function>, 혹은 다른
     파일 접근 함수를 이용할 때 공백이나 빈 줄을 출력해버리는건 매우 자주 있는
     에러입니다. 같은 문제는 하나의 PHP/HTML 파일을 사용할 때도 존재합니다.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<html>
<?php
/* 에러가 납니다. header() 호출 전에
 * 위의 출력이 있는 점에 주의하십시오.
header('Location: http://www.example.com/');
?>
]]>
      </programlisting>
     </informalexample>
    </para>    
    <note>
     <para>
      PHP 4에서, 전송하기 전까지 브라우저에 대한 모든 출력 오버헤드를 서버
      버퍼에 넣는 출력 버퍼링을 사용하여 이 함수를 호출 하기 전에 출력을 보낼
      수 있습니다. 스크립트에서 <function>ob_start</function>와
      <function>ob_end_flush</function>를 호출하거나, &php.ini;나 서버 설정
      파일에서 <literal>output_buffering</literal>을 설정해서 이를 사용할 수
      있습니다.
     </para>
    </note>
    <para>
     사용자에게 생성한 PDF 파일 등의 전송한 데이터를 저장할지를 묻게 하고
     싶다면, <ulink url="&url.rfc;2183">Content-Disposition</ulink> 헤더로
     권장 파일 이름을 제공하고 브라우저가 저장 다이얼로그를 표시하게 할 수
     있습니다.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// PDF를 출력합니다.
header("Content-type: application/pdf");

// download.pdf로 불립니다.
header("Content-Disposition: attachment; filename=downloaded.pdf");

// PDF 소스는 original.pdf
readfile('original.pdf');
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Microsoft Internet Explorer 4.01은 버그로 인해 작동하지 않습니다.
      해결책은 없습니다. Microsoft Internet Explorer 5.5 역시 이를 다루는
      부분에 버그가 존재하며, 서비스팩 2 이후로 업그레이드해서 해결할 수
      있습니다.
     </para>
    </note>
    <note>
     <simpara>
      <link linkend="ini.safe-mode">안전모드</link>에서는
      <literal>WWW-Authenticate</literal> 헤더(HTTP 인증에 사용)를 설정하면
      스크립트의 uid가 <literal>realm</literal> 부분에 추가됩니다.
     </simpara>
    </note>
    <para>
     참고: <function>headers_sent</function>,
     <function>setcookie</function>,
     <link linkend="features.http-auth">HTTP 인증</link> 섹션.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

