<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.21 Maintainer: progcom Status: ready -->
<!-- CREDITS: fuzzy74 -->

 <reference xml:id="ref.oci8" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>오라클 함수</title>
  <titleabbrev>OCI8</titleabbrev>

  <partintro>
   <section xml:id="oci8.intro">
    &reftitle.intro;
    <para>
     이 함수는 Oracle Call Interface (OCI)를 사용하여 오라클 10, 오라클 9,
     오라클 8, 오라클 7 데이터베이스에 접근할 수 있도록 해줍니다. PHP 변수를
     오라클 위치보유자에 넣을 수 있고, LOB, FILE, ROWID를 완전히 지원하며,
     사용자 지정 변수를 사용할 수 있게 해줍니다.
    </para>
   </section>

   <section xml:id="oci8.requirements">
    &reftitle.required;
    <para>
     이 확장을 사용하려면 오라클 클라이언트 라이브러리가 필요합니다. 윈도우
     사용자는 <filename>php_oci8.dll</filename>을 사용하기 위해서 버전 10
     이상의 라이브러리가 필요합니다.
    </para>
    <para>
     필요한 모든 파일을 설치하는 가장 편리한 방법은 오라클 인스턴트
     클라이언트를 사용하는 것으로, 다음 위치에서 받을 수 있습니다: <link
      xlink:href="&url.oracle.instant.client;">&url.oracle.instant.client;</link>
     "기본" 버전의 오라클 인스턴트 클라이언트로도 OCI8 모듈을 사용하기에
     충분합니다. 인스턴트 클라이언트는 ORACLE_SID나 ORACLE_HOME 환경 변수를
     설정할 필요가 없습니다. 그러나 LD_LIBRARY_PATH와 NLS_LANG은 설정해야
     합니다.
    </para>
    <para>
     이 확장을 사용하기 전에, 오라클 사용자와 웹 데몬 사용자에 대하여 오라클
     환경 변수를 정확하게 지정했는지 확인해야 합니다. 이 변수는 웹 서버를
     시작하기 <emphasis>전에</emphasis> 설정해야 합니다. 설정해야할 변수는
     다음과 같습니다:
     <itemizedlist>
      <listitem>
       <simpara>
        ORACLE_HOME
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        ORACLE_SID
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        LD_PRELOAD
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        LD_LIBRARY_PATH
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        NLS_LANG
       </simpara>
      </listitem>
     </itemizedlist>
     TNS_ADMIN, TWO_TASK, ORA_TZFILE처럼 자주 사용하지 않는 오라클 환경 변수와
     ORA_NLS33, ORA_NLS10, NLS_* 등과 같은 다양한 오라클 세계화 설정은 오라클
     문서를 참고하십시오.
    </para>
    <para>
     웹 서버 사용자에 맞게 환경 변수를 적용한 후에, 오라클 그룹에도 웹 서버
     사용자(nobody, www)를 추가해야 합니다.
    </para>
    <note>
     <title>웹서버가 시작되지 않거나 시작 시에 충돌하면</title>
     <para>
      아파치가 pthread 라이브러리에 링크되어있는지 확인:
     </para>
     <para>
      <informalexample>
       <screen>
<![CDATA[
# ldd /www/apache/bin/httpd 
    libpthread.so.0 => /lib/libpthread.so.0 (0x4001c000)
    libm.so.6 => /lib/libm.so.6 (0x4002f000)
    libcrypt.so.1 => /lib/libcrypt.so.1 (0x4004c000)
    libdl.so.2 => /lib/libdl.so.2 (0x4007a000)
    libc.so.6 => /lib/libc.so.6 (0x4007e000)
    /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
]]>
       </screen>
      </informalexample>
     </para>
     <para>
      libpthread가 보이지 않으면 아파치를 다시 설치해야 합니다:
     </para>
     <para>
      <informalexample>
       <screen>
<![CDATA[
# cd /usr/src/apache_1.3.xx
# make clean
# LIBS=-lpthread ./config.status
# make
# make install
]]>
       </screen>
      </informalexample>
     </para>
     <para>
      UnixWare 같은 몇몇 시스템에서는 libpthread 대신에 libthread를
      사용합니다. PHP와 아파치는 EXTRA_LIBS=-lthread로 설정해야 합니다.
     </para>
    </note>
   </section>

   &reference.oci8.ini;

   &reference.oci8.constants;

   <section xml:id="oci8.examples">
    &reftitle.examples;
    <para>
     <example>
      <title>기본 쿼리</title>
      <programlisting role="php">
<![CDATA[
<?php

  $conn = oci_connect('hr', 'hr', 'orcl');
  if (!$conn) {
    $e = oci_error();
    print htmlentities($e['message']);
    exit;
  }

  $query = 'SELCT * FROM DEPARTMENTS';

  $stid = oci_parse($conn, $query);
  if (!$stid) {
    $e = oci_error($stid);
    echo htmlentities($e['message']);
    exit;
  }

  print '<table border="1">';
  while ($row = oci_fetch_array($stid, OCI_RETURN_NULLS)) {
    print '<tr>';
       foreach ($row as $item) {
         print '<td>'.($item?htmlentities($itme):'&nbsp;').'</td>';
       }
       print '</tr>';
  }
  print '</table>';

  oci_close($conn);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>바인드 변수로 삽입하기</title>
      <programlisting role="php">
<![CDATA[
<?php

  // 실행하기 전에 테이블을 만듭니다:
  //   CREATE TABLE MYTABLE (mid NUMBER, myd VARCHAR2(20));

  $conn = oci_connect('scott', 'tiger', 'orcl');

  $query = 'INSERT INTO MYTABLE VALUES(:myid, :mydata)';

  $stid = oci_parse($conn, $query);

  $id = 60;
  $data = 'Sime data';

  oci_bind_by_name($stid, ':myid', $id);
  oci_bind_by_name($stid, ':mydata', $data);

  $r = oci_execute($stid);

  if ($r)
    print "한 줄이 삽입되었습니다";

  oci_close($conn);

?>
]]>
      </programlisting>
     </example>
    </para>


    <para>
     <example>
      <title>CLOB 컬럼에 데이터 넣기</title>
      <programlisting role="php">
<![CDATA[
<?php

// 실행하기 전에 테이블을 만듭니다:
//     CREATE TABLE MYTABLE (mykey NUMBER, myclob CLOB);

$conn = oci_connnect('scott', 'tiger', 'orcl');

$mykey = 12343;  // 예제를 위한 임시 키입니다;

$sql = "INSERT INTO mytable (mykey, myclob)
        VALUES (:mykey, EMPTY_CLOB())
        RETURNING myclob INTO :myclob";

$stid = oci_parse($conn, $sql);
$clob = oci_new_descriptor($conn, OCI_D_LOB);
oci_bind_by_name($stid, ":mykey", $mykey, 5);
oci_bind_by_name($stid, ":myclob", $clob, -1, OCI_B_CLOB);
oci_execute($stid, OCI_DEFAULT);
$clob->save("매우 긴 문자열");

oci_commit($conn);

// CLOB 데이터 가져오기

$query = 'SELECT myclob FROM mytable WHERE mykey = :mykey';

$stid = oci_parse ($conn, $query);
oci_bind_by_name($stid, ":mykey", $mykey, 5);
oci_execute($stid, OCI_DEFAULT);

print '<table border="1">';
while ($row = oci_fetch_array($stid, OCI_ASSOC)) {
   $result = $row['MYCLOB']->load();
   print '<tr><td>'.$result.'</td></tr>';
}
print '</table>';

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     명령줄에서 실행하는 것과 동일한 방법으로, 쉽게 저장된 프로시져에 접근할 수
     있습니다.
     <example>
      <title>저장된 프로시져 사용하기</title>
      <programlisting role="php">
<![CDATA[
<?php
// webmaster at remoterealty dot com에 의해
$sth = oci_parse($dbh, "begin sp_newaddress( :address_id, '$firstname',
 '$lastname', '$company', '$address1', '$address2', '$city', '$state',
 '$postalcode', '$country', :error_code );end;");

// :address_id를 in/out 변수로, :error_code를 out 변수로 하여 저장된
// 프로시져 sp_newaddress를 호출합니다.
// 그 후에 바인드를 합니다:

   oci_bind_by_name($sth, ":address_id", $addr_id, 10);
   oci_bind_by_name($sth, ":error_code", $errorcode, 10);
   oci_execute($sth);

?>
]]>
      </programlisting>
     </example>
    </para>
   </section>

   <section xml:id="oci8.connection">
    <title>접속 다루기</title>
    <para>
     OCI8 확장은 오라클에 접속하는 세가지 함수를 제공합니다. 어플리케이션에서
     가장 적합한 함수를 사용할 수 있고, 이 섹션에 그 선택을 도울 수 있는
     정보가 있습니다.
    </para>
    <para>
     오라클 서버에 접속하는 것은 완료될때까지 시간이 걸리는 꽤 비싼
     연산입니다. <function>oci_pconnect</function> 함수는 접속에 대한 지속적인
     캐시를 사용하여 서로 다른 스크립트의 요청에 대하여 접속을 재사용할 수
     있습니다. 이 방법은 PHP 프로세스(혹은 아파치 프로세스) 별로 한번의 접속
     오버헤드만을 가지게 됩니다.
    </para>
    <para>
     어플리케이션이 각 웹 사용자에 대하여 서로 다른 자격을 필요로 한다면,
     <function>oci_pconnect</function>의 지속적인 캐시는 사용자 수가 늘어남에
     따라서 효율이 줄어듭니다. 오히려 오라클 서버가 너무 많은 휴지 접속을
     다뤄야 하기에 전체적인 성능이 떨어질 수도 있습니다. 어플리케이션이 이런
     구조로 작성되어 있다면, 어플리케이션이 <link
      linkend="ini.oci8.max_persistent">oci.max_persistent</link>와 <link
      linkend="ini.oci8.persistent_timeout">oci8.persistent_timeout</link>
     설정을 사용하게 하거나(지속 접속의 캐시 크기와 유효 시간을 제어합니다),
     <function>oci_connect</function>로 대체합니다.
    </para>
    <para>
     <function>oci_connect</function>와 <function>oci_pconnect</function> 모두
     접속 캐시를 사용합니다; 한 스크립트에서 동일한 매개변수로
     <function>oci_connect</function>를 여러 번 호출할 경우, 두번째
     호출부터는 존재하는 접속 핸들을 반환합니다.
     <function>oci_connect</function>가 사용하는 캐시는 스크립트 실행이
     끝났거나 명시적으로 접속 핸들을 닫았을 때, 지워집니다.
     <function>oci_pconnect</function>도 비슷한 동작을 하지만, 캐시는 요청
     사이에서 별개로 분리되어 관리됩니다.
    </para>
    <para>
     캐시 기능은 꼭 기억해야 합니다. 이로 인하여 두 핸들이 트랜젝션에서
     독립되지 않기 때문입니다(동일한 접속 핸들이기에, 사실상 독립할 방법이
     없습니다) 어플리케이션이 두개의 분리된 트랜젝션에서 독립된 접속이
     필요하다면, <function>oci_new_load</function>를 사용해야 합니다.
    </para>
    <para>
     <function>oci_new_connect</function>는 다른 접속의 존재 여부에 관계 없이
     오라클 서버에 새로운 접속을 합니다. 높은 트래픽의 웹 어플리케이션은
     <function>oci_new_connect</function>를 사용하는 것을 피하는 것이
     좋습니다. 어플리케이션에서 가장 바쁜 섹션이 됩니다.
    </para>
   </section>

   <section xml:id="oci8.datatypes">
    <title>자료형은 드라이버에서 지원합니다</title>
    <table>
     <title>이 드라이버는 <function>oci_bind_by_name</function> 함수를
      사용하여 바인드 할 때 다음 타입을 지원합니다:</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>타입</entry>
        <entry>매핑</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>SQLT_NTY</entry>
        <entry><function>oci_new_collection</function>으로 만든 PHP 콜렉션
         객체에서 네이티브 콜렉션형으로 매핑합니다.</entry>
       </row>
       <row>
        <entry>SQLT_BFILEE</entry>
        <entry><function>oci_new_descriptor</function>로 만들어진 것을
         네이티브 디스크립터로 매핑합니다.</entry>
       </row>
       <row>
        <entry>SQLT_CFILEE</entry>
        <entry><function>oci_new_descriptor</function>로 만들어진 것을
         네이티브 디스크립터로 매핑합니다.</entry>
       </row>
       <row>
        <entry>SQLT_CLOB</entry>
        <entry><function>oci_new_descriptor</function>로 만들어진 것을
         네이티브 디스크립터로 매핑합니다.</entry>
       </row>
       <row>
        <entry>SQLT_BLOB</entry>
        <entry><function>oci_new_descriptor</function>로 만들어진 것을
         네이티브 디스크립터로 매핑합니다.</entry>
       </row>
       <row>
        <entry>SQLT_RDD</entry>
        <entry><function>oci_new_descriptor</function>로 만들어진 것을
         네이티브 디스크립터로 매핑합니다.</entry>
       </row>
       <row>
        <entry>SQLT_NUM</entry>
        <entry>PHP 매개변수를 'C' long형으로 변환하여 그 값을
         바인드합니다.</entry>
       </row>
       <row>
        <entry>SQLT_RSET</entry>
        <entry><function>oci_parse</function>로 만들었거나 OCI 쿼리로 가져온
         것을 네이티브 구문 핸들에 매핑합니다.</entry>
       </row>
       <row>
        <entry>SQLT_CHR과 기타 타입</entry>
        <entry>PHP 매개변수를 string형으로 변환하여 문자열로
         바인드합니다.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table>
     <title>다음 타입은 결과셋에서 컬럼을 가져올 때 지원합니다:</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>타입</entry>
        <entry>매핑</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>SQLT_RSET</entry>
        <entry>현재 커서를 표현하는 OCI 구문 자원을 만듭니다.</entry>
       </row>
       <row>
        <entry>SQLT_RDD</entry>
        <entry>ROWID 객체를 만듭니다.</entry>
       </row>
       <row>
        <entry>SQLT_BLOB</entry>
        <entry>LOB 객체를 만듭니다.</entry>
       </row>
       <row>
        <entry>SQLT_CLOB</entry>
        <entry>LOB 객체를 만듭니다.</entry>
       </row>
       <row>
        <entry>SQLT_BFILE</entry>
        <entry>LOB 객체를 만듭니다.</entry>
       </row>
       <row>
        <entry>SQLT_LNG</entry>
        <entry>SQLT_CHR로 바운드하여, 문자열로 반환합니다.</entry>
       </row>
       <row>
        <entry>SQLT_LBI</entry>
        <entry>SQLT_BIN으로 바운드하여, 문자열로 반환합니다.</entry>
       </row>
       <row>
        <entry>기타 타입</entry>
        <entry>SQLT_CHR로 바운드하여, 문자열로 반환합니다.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </section>

  </partintro>

  &reference.oci8.entities.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
