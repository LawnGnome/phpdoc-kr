<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.10 $ -->
<!-- EN-Revision: 1.23 Maintainer: fuzzy74 Status: ready -->
<appendix xml:id="migration" xmlns="http://docbook.org/ns/docbook">
 <title>PHP/FI 2 에서 PHP 3로 이주하기</title>

 <section xml:id="migration.about">
  <title>3.0의 비호환성</title>

  <simpara>
   PHP 3.0은 밑바닥부터 다시 작성되었다. 이 버전은 2.0보다 튼튼하고
   견고한 해석기를 갖고 있다. 3.0은 또한 속도가 매우 빠르고 메모리를 거의
   사용하지 않는다. 그러나, 이런 기능향상을 위해서는 문법과 기능 모두에
   대해서 호환성을 위한 변경이 필요하다.
  </simpara>

  <simpara>
   추가로, PHP 개발자는 PHP 3.0의 문법과 의미변화 모두에 대해 완벽하게
   이해하도록 노력해야 한다. 이 두가지도 비호환성을 일으킬수 있다. 긴
   안목으로 보면, 이런 변화들로 인해 더욱 낳아질거라고 확신한다.
  </simpara>

  <simpara>
   이 챕터는 PHP/FI 2.0에서 PHP 3.0으로 이주할때 빠질수도 있는 비호환성에
   대해서 설명하고 그 문제들을 해결하도록 도와주려고 한다. 새로운 기능은
   필요치않으면 여기서 언급하지 않는다.
  </simpara>

  <simpara>
   구버전의 PHP/FI 2.0스크립트를 자동으로 변환하는 프로그램이 제공된다.
   그 프로그램은 PHP 3.0 배포판의 하위디렉토리인 
   <filename class="directory">convertor</filename>에서 찾을수 있다.
   이 프로그램은 문법적인 변화만 변경할 뿐이기 때문에, 어쨋든 이 챕터를
   주의깊게 읽어야 할것이다.
  </simpara>
 </section>

 <section xml:id="migration.old-function">
  <title><literal>old_function</literal></title>
  <simpara>
   <literal>old_function</literal> 구문은 PHP/FI2와 동일한 문법을 사용하는
   함수를 선언하도록 해준다. ('function'을 'old_function'으로 
   변경하는것만 빼고)
  </simpara>
  <simpara>
   이것은 사라져가는 기능이고, PHP/FI2->PHP 3변환기만으로 사용해야 한다.
  </simpara>
  <warning>
   <para>
    <literal>old_function</literal>으로 선언된 함수는 PHP의 내부 코드에서
    호출될수 없다. 이 말의 의미는 <function>usort</function>, 
    <function>array_walk</function>, <function>register_shutdown_function</function>과 
    같은 함수 안에서 이 함수를 사용할수 없다는것이다.
    <literal>old_function</literal>을 호출하기 위해 래퍼함수(일반적인 
    PHP 3 형태)를 작성함으로써 이런 제한을 극복할수 있다.
   </para>
  </warning>
 </section>
 
 <section xml:id="migration.startendtags">
  <title>Start/end tags</title>

  <para>
   주의해야할 첫번째 사실은 PHP의 시작과 끝 태그가 변경되었다는 것이다.
   구버전의 <literal>&lt;? &gt;</literal> 형태는 세가지 사용가능한 새 형태로
   변경되었다:
   <example>
    <title>이주: 구버전의 시작/끝 태그</title>
    <programlisting role="php">
<![CDATA[
<? echo "This is PHP/FI 2.0 code.\n"; ?>
]]>
    </programlisting>
   </example>
   버전 2.0의 PHP/FI는 이런 변종도 지원한다:
   <example>
    <title>이주: 첫번째 새로운 시작/끝 태그</title>
    <programlisting role="php">
<![CDATA[
<? echo "This is PHP 3.0 code!\n"; ?>
]]>
    </programlisting>
   </example>

   끝 태그는 현재 단순히 보다-크다(&gt;) 문자대신에 물음표와 
   보다-크다(&gt;) 문자로 구성되어있다. 하지만, 서버에 XML을 사용할
   계획이라면, 첫번째 새로운 변종으로는 문제가 발생할것이다. 왜냐하면
   PHP는 XML 문서에 XML 마크업을 PHP 코드로 실행하려 할수 있기 때문이다.
   이와 같은 이유로, 다음 변종이 제공된다:

   <example>
    <title>이주: 두번째 새로운 시작/끝 태그</title>
    <programlisting role="php">
<![CDATA[
<?php echo "This is PHP 3.0 code!\n"; ?>
]]>
    </programlisting>
   </example>

   일부사람들은 이런 태그를 처리명령 태그로 전혀 이해할수 없는 에디터를
   사용하기 때문에 문제가 발생한다. 마이크로소프트 프론트페이지는 그런
   에디터 중 하나이고, 이런 문제를 피하는 방법으로서 다음과 같은 변종도
   함께 제공된다:

   <example>
    <title>이주: 세번째 새로운 시작/끝 태그</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "This is PHP 3.0 code!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.if-endif">
  <title>if..endif 문법</title>

  <para>
   if/elseif/else 구문을 작성하는 '부차적인' 방법인,
   if(); elseif(); else; endif; 는 3.0 해석기의 거대한 복잡성을 추가하지
   않고는 효과적으로 구현될수 없다. 이런 이유때문에, 문법이 변경되었다:
   <example>
    <title>이주: 구버전의 if..endif 문법</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "yep\n";
elseif ($bar);
    echo "almost\n";
else;
    echo "nope\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>이주: 새로운 if..endif 문법</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "yep\n";
elseif ($bar):
    echo "almost\n";
else:
    echo "nope\n";
endif;
]]>
    </programlisting>
   </example>

   구문을 종료하는 하나(endif)를 제외하고 구문 전체에서 세미콜론이
   콜론으로 변경되었다는것에 주의한다.
  </para>
 </section>

 <section xml:id="migration.while">
  <title>while 문법</title>
  <para>
   if..endif 와 비슷하게, while..endwhile 문법도 변경되었다:
   <example>
    <title>이주: 구버전의 while..endwhile 문법</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>이주: 새로운 while..endwhile 문법</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    PHP 3.0에서 구버전의 while..endwhile 문법을 사용한다면,
    루프를 결코 끝낼수 없을것이다.
   </simpara>
  </warning>
 </section>

 <section xml:id="migration.expr">
  <title>표현식 타입</title>
  <simpara>
   PHP/FI 2.0은 결과값이 무슨 타입이 되어야 할지 결정하기 위해 표현식의
   좌변을 사용한다. PHP 3.0은 결과 타입을 결정하는데 양변 모두를 취할
   수 있다. 그리고 이런 형태는 2.0 스크립트가 3.0에서 기대하는대로 
   동작하지 않게 할수 있다.
  </simpara>
  <para>
   다음 예제 코드를 보자:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   PHP/FI 2.0에서, 이 예제코드는 $a의 인덱스를 출력할것이다. PHP 3.0에서는
   아무것도 출력되지 않을것이다. 그 이유는 PHP 2.0 안에서 좌측 인자의 타입이
   문자열이고, 문자열 비교가 수행되고, <literal>""</literal>는 <literal>"0"</literal>과
   같지 않아서 루프를 계속 돌기 때문이다. PHP 3.0에서는, 문자열이 정수와
   비교될때, 정수 비교가 수행된다(문자열은 정수로 변환됨). 
   <literal>0</literal>이 되는 <literal>atoi("")</literal>와 비교되는데
   <literal>variablelist</literal>도 <literal>0</literal>이 있어서,
   <literal>0==0</literal>이기 때문에, 루프는 한번도 수행되지 않는다.
  </para>
  <para>
   이것에 대한 변경은 간단하다. 다음과 같은 while 구문으로 변경한다:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$key != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section xml:id="migration.errors">
  <title>변경된 에러 메시지</title>
  <simpara>
   PHP 3.0의 에러 메시지는 대체로 2.0보다는 정확하다. 그러나 에러를 일으키는
   코드 파편을 더이상 볼수 없다. 대신에, 에러가 발생하는 파일명과 라인 번호가 제공될
   것이다.
  </simpara>
 </section>

 <section xml:id="migration.booleval">
  <title>짧은-순환 논리 비교</title>
  <simpara>
   PHP 3.0의 논리 비교는 짧은-순환이다. 이 말은 의미는 
   <literal>(1 || test_me())</literal>와 같은 표현식에서, 
   <function>test_me</function> 함수는 <literal>1</literal>다음의 
   표현식이 결과값을 변경하지 않기 때문에 수행되지 않을것이다.
  </simpara>

  <simpara>
   이것은 미세한 호환성 문제이지만, 기대치 않는 사이드-이펙트를
   발생시킬것이다.
  </simpara>
 </section>

 <section xml:id="migration.truefalse">
  <title>함수 &true;/&false; 리턴 값</title>
  <simpara>
   대부분의 내장함수들은 성공하면 &true;를 실패하면 &false;를 리턴하도록
   재작성되었다. PHP/FI 2.0은 각각 0과 -1을 리턴하는것과 반대된다. 
   이 새로운 동작은 <literal>$fp = fopen("/your/file")나 fail("darn!");</literal>같은
   좀더 논리적인 코드를 작성할수 있도록 해준다. PHP/FI 2.0은 함수가
   실패했을때 무엇을 리턴해야 하는지에 대한 명확한 규칙이 없기때문에,
   대부분의 이런 스크립트들은 2.0에서 3.0으로의 변환기를 사용한 후에
   수작업으로 확인해야 할것이다.
  </simpara>
  <para>
   <example>
    <title>2.0으로부터의 이주: 리턴 값, 구버전의 코드</title>
    <programlisting role="php">
<![CDATA[
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Could not open $file for reading<br>\n");
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>2.0으로부터의 이주: 리턴 값, 새로운 코드</title>
    <programlisting role="php">
<![CDATA[
$fp = @fopen($file, "r") or print("Could not open $file for reading<br>\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.other">
  <title>다른 비호환성</title>

  <itemizedlist>
   <listitem><simpara>
    PHP 3.0의 아파치 모듈은 더이상 아파치 1.2 이전 버전을 지원하지
    않는다. 아파치 1.2 이후 버전이 필요하다.
   </simpara></listitem>

   <listitem><simpara>
    <function>echo</function>는 더이상 포맷화된 문자열을 지원하지 않는다.
    대신 <function>printf</function> 함수를 사용하도록 한다.
   </simpara></listitem>

   <listitem><simpara>
    PHP/FI 2.0에서, 구현상의 사이드-이펙트는 <literal>$foo</literal>와
    같은 결과를 내기 위해서 <literal>$foo[0]</literal>를 사용한다. 
    이런 구현은 PHP 3.0에서는 사용되지 않는다.
   </simpara></listitem>

   <listitem>
    <simpara>
     <literal>$array[]</literal>로 배열을 읽는것은 더이상 지원되지 않는다.
    </simpara>
    <simpara>
     즉, <literal>$data = $array[]</literal>를 수행하는 루프를 통해서
     배열을 돌아다닐수는 없다. 대신 <function>current</function>와
     <function>next</function>를 사용한다.
    </simpara>
    <simpara>
     <literal>$array1[] = $array2</literal>는 <literal>$array1</literal>에
     <literal>$array2</literal>값을 추가하지 않는다. 그러나 
     <literal>$array1</literal>의 마지막 구성요소로서 <literal>$array2</literal>을
     추가한다. 다차원 배열 지원에 대한 것도 참고할것.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal>는 그 인자를 숫자로 변환하고 숫자 덧셈을 
     수행하는 것 외의 문자열의 결합 연산자로 더이상 오버로드되지 않는다. 
     대신 <literal>"."</literal>을 사용하자.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>2.0으로부터의 이주: 문자열의 결합</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para> 
    PHP 2.0에서 이 코드는 11을 echo하지만, PHP 3.0에서는
    대신 2를 echo한다:
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    이 코드는 PHP 2.0과 3.0 모두 2를 echo한다.
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
    이 코드는 PHP 3.0에서 11을 echo한다.
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
