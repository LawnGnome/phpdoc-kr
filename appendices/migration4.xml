<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.34 -->
 <appendix id="migration4">
  <title>PHP 3 에서 PHP 4로 이주</title>
	
  <section id='migration4.changes'>
   <title>PHP 4에서 바뀐것</title>
   <para>
    PHP 4 와 젠드 엔진은 PHP의 성능과 기능을 크게 향상시켰다.
    그러면서도 기존의 코드가 잘 작동할수 있도록 하기위해 주의를 많이
    기울였다. PHP 3에서 4로 이주하는 것은 PHP/FI 2에서 PHP 3로 이주하는
    것보다는 훨씬 쉽다. 기존의 많은 PHP 3 코드를 변경없이 동작시킬수 
    있다. 그러나 아직은 약간의 차이를 알아야 하고, 개발 환경에서 버전을
    전환하기 전에 코드를 테스트하는데 주의를 기울여야 한다. 다음글은
    무엇에 주의해야 하는지에 대한 몇가지 힌트를 보여줄것이다.
   </para>
  </section>

  <section id="migration4.php4.with.php3">
   <title>PHP 3와 PHP 4를 동시에 작동시키기 </title>
   <simpara>
    최근 운영 체제는 버전관리(versioning)와 영역관리(scoping) 기능을
    제공한다. 이런 기능은 PHP 3와 PHP 3가 아파치 서버에서 동시에
    동작하는 모듈로 운영될수 있게 해준다.
   </simpara>
   <simpara>
    이 기능은 다음의 플랫폼에서 작동하는것으로 알려져있다:
   </simpara>
   <itemizedlist>
     <listitem><simpara>최신판의 binutils를 갖는 리눅스 (binutils 2.9.1.0.25가 테스트됨) </simpara></listitem>
     <listitem><simpara>Solaris 2.5 이상</simpara></listitem>
     <listitem><simpara>FreeBSD (3.2, 4.0 에서 테스트됨)</simpara></listitem>
   </itemizedlist>
   <para>
    이 기능을 활성화시키려면, APXS(--with-apxs)와 필수 링크 확장(--enable-versioning)을
    사용하여 PHP3와 PHP4를 설정한다. 그렇지 않으면, 모든 표준 설치
    명령이 적용된다. 예를 들면:
    <informalexample>
     <programlisting role="configure">
<![CDATA[
$ ./configure \
  --with-apxs=/apache/bin/apxs \
  --enable-versioning \
  --with-mysql \
  --enable-track-vars
]]>
		 </programlisting>
		</informalexample>
   </para>
  </section>

  <section id="migration4.configuration">
   <title>설정파일 이주하기</title>
   <para>
    전역 설정 파일, <filename>php3.ini</filename>, 는 &php.ini;로 
    이름이 변경되었다.
   </para>
   <para>
    아파치 설정 파일에서는 약간의 변화가 생겼다. PHP 모듈에 의해
    인식되는 MIME 타입이 변경되었다.
    <informalexample>
		 <programlisting role="apache">
<![CDATA[
application/x-httpd-php3        -->    application/x-httpd-php
application/x-httpd-php3-source -->    application/x-httpd-php-source
]]>
		 </programlisting>
		</informalexample>
   </para>
   <para>
    두가지 버전의 PHP와 함께 작동하는 설정 파일을 만들수 있다(서버에
    현재 결합되어있는 버전에 따라). 다음과 같은 문법을 사용한다.
    <informalexample>
		 <programlisting>
<![CDATA[
AddType  application/x-httpd-php3        .php3
AddType  application/x-httpd-php3-source .php3s

AddType  application/x-httpd-php         .php
AddType  application/x-httpd-php-source  .phps
]]>
     </programlisting>
		</informalexample>
   </para>
   <simpara>
    추가로, 아파치에 대한 PHP 디렉티브 이름도 변경되었다.
   </simpara>
   <para>
    PHP 4.0부터는, 4가지의 아파치 디렉티브만이 PHP와 관련되어있다.
    <informalexample>
		 <programlisting role="apache">
<![CDATA[
php_value [PHP directive name] [value]
php_flag [PHP directive name] [On|Off]
php_admin_value [PHP directive name] [value]
php_admin_flag [PHP directive name] [On|Off]
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    There are two differences between the Admin values and the non admin values:
    admin이 있는 디렉티브 값과 admin이 없는 값 사이에는 두가지 차이가 있다:
   </simpara>
   <itemizedlist>
    <listitem>
     <simpara>
      Admin 값(또는 플래그)는 서버-전반에 영향을 미치는 
      아파치 설정파일(e.g., &httpd.conf;)에만 존재한다.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      일반 값(또는 플래그)는 일부 PHP 디렉티브를 제어할수 없다. 예를 들면:
      &safemode; ( &htaccess;에서 안전모드(safe mode) 설정을 덮어쓴다면,
      &safemode;의 목적에 어긋나게 할것이다) . 이와 대조적으로, Admin 값은
      모든 PHP 디렉티브의 값을 변경할수 있다.
     </simpara>
    </listitem>
   </itemizedlist>
   <simpara>
    변경 처리를 좀더 쉽게 하기 위해, PHP 4에서는 PHP 3와 PHP 4가 함께 동작하는
    아파치 설정과 &htaccess; 파일을 자동으로 변환해주는 스크립트를 함께 제공한다.
    이 스크립트는 mime타입 라인을 변경하지 않는다! 이 부분은 직접 변환해야 한다.
   </simpara>
   <para>
    아파치 설정 파일을 변경하기 위해서는, apconf-conv.sh 스크립트
    (scripts/apache/ 디렉토리에 위치함)를 실행한다. 예를 들면:
    <informalexample>
		 <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  ./apconf-conv.sh /usr/local/apache/conf/httpd.conf
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    원래 설정 파일은 httpd.conf.orig로 저장될것이다.
   </simpara>
   <para>
    &htaccess; 파일을 변환하기 위해서는, 
    <filename>aphtaccess-conv.sh</filename> 스크립트
    (<filename>scripts/apache/</filename> 디렉토리에도 위치)를 
    실행한다:
    <informalexample>
		 <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  find / -name .htaccess -exec ./aphtaccess-conv.sh {} \;
]]>
	 </programlisting>
    </informalexample>
   </para>
   <simpara>
    이것도 구버전의 &htaccess; 파일을 .orig 어미가 붙어 저장할것이다.
   </simpara>
   <simpara>
    변환 스크립트가 작동하기 위해서는 awk가 설치되어있어야 한다.
   </simpara>
  </section>

  <section id='migration4.parser'>
   <title>해석기(Parser) 동작</title>
   <para>
    해석과 실행은 현재 두 단계로 완전히 따로 분리되어있다. 파일 코드의 실행은
    그 파일전체와 그 파일이 필요로 하는 모든 것들이 성공적으로 해석되고나서야
    비로소 이루어진다.
   </para>
   <para>
    이런 분리를 위해 새로이 필요하게 된것 중 하나는 require와 include된
    파일이 문법적으로 완벽해야 한다는 것이다. 이제 더이상 여러 파일간에
    제어 구조의 서로 다른 제어 부분을 나눌수 없다. 
    어떤 파일 안에서 <literal>for</literal>나 <literal>while</literal>루프,
    <literal>if</literal> 구문이나 <literal>switch</literal> 블록으로 시작하거나
    또 다른 파일 안에서 <literal>else</literal>, <literal>endif</literal>,
    <literal>case</literal> 나 <literal>break</literal>구문을 갖을수 없다.
   </para>
   <para>
    루프나 다른 제어 구조안에서 추가코드를 include하는 것은 아직은 완전히
    유효하다. 단, 제어 핵심어와 닫힌 중괄호 <literal>{...}</literal> 는 동일한
    통합 유닛(파일이나 <function>eval</function>이 적용된 문자열)안에 있어야
    한다.
   </para>
   <para>
    이와 같은 분리된 코드는 어쨋든 매우 나쁜 스타일이긴 하지만
    크게 해를 끼치지는 않을것이다.
   </para>
   <para>
    더이상 유효하지 않은 또다른 특징은 PHP 3 코드에서는 거의 보이지는 않지만
    require된 파일로부터 리턴받는 값이다. include된 파일로부터 값을 리턴받는것은
    아직까지는 유효하다.
   </para>
  </section>

  <section id='migration4.error-reporting'>
   <title>에러 보고</title>
	 
   <section id='migration4.error-reporting.config'>
    <title>변경된 설정</title>
    <para>
     PHP 3에서 에러 보고 레벨은 단순하게 숫자값으로 설정되었다.
     이런 숫자값은 다른 에러 레벨과 관련된 숫자를 합쳐서 구성된다.
     이용가능한 값중에 15는 모든 에러를 보고하고 7은 나쁜 스타일에
     대한것과 이와 비슷한 것들을 보고하는 단순한 경고메시지를 제외한
     모든 것을 보고하는데 사용된다.
    </para>
    <para>
     PHP 4는 에러/경고 레벨을 다량 보유하고 있고 이는 의도된 동작을 위한
     설정에 사용되는 심볼릭 상수를 허용하는 설정 해석기로 인해 추가되었다.
    </para>
    <para>
     현재의 에러 보고 레벨은 심볼릭 상수 <literal>E_ALL</literal>에서 원하지
     않는 경고 레벨값을 x-or 연산을 수행하여 에러 메시지를 생성시키고 싶지 않은 
     경고 레벨을 명시적으로 제거하도록 설정해야 한다. 복잡해 보이는가?
     자, 에러 보고시스템에게 심볼릭 상수 <literal>E_NOTICE</literal>로 
     분류되어있는 단순한 스타일 경고를 제외한 모든것을 보고하도록
     해보자. &php.ini;에 다음 설정을 넣어야 할것이다:
     <literal>error_reporting = E_ALL &amp; ~ ( E_NOTICE )</literal>.
     이진수를 사용하거나 연산자 '|'를 사용하여 괄호 안에 적절한 상수를 
     추가함으로써 다른 경고도 감출수 있다:
     <literal>error_reporting= E_ALL &amp; ~ ( E_NOTICE | E_WARNING)</literal>.
    </para>
    <warning>
     <para>
      PHP 3에서 PHP 4로 코드나 서버를 업그레이드할때 이 설정을 체크해야 하고
      <function>error_reporting</function>를 호출하거나 
      새로운 에러 타입인 E_COMPILE_ERROR로 에러 보고를 비활성화시킬수 있다.
      이 기능은 무슨일이 일어났고 문제가 발생한 장소가 어디인지에 대한
      피드백 없이 비어있는 문서를 보여줄것이다.
     </para>
    </warning>
    <warning>
     <para>
      에러 보고를 설정하기 위해 구버전의 7과 15 값을 사용하는 것은 좋은
      생각이 아니다. 왜냐하면 이 값들은 해석 에러를 포함한 새로 추가된
      에러의 일부도 보이지 않게 하기 때문이다. 이 값들은 매우 이상한
      동작으로 유도할수 있는데 스크립트가 모든 장소에서 에러 메시지를
      보이며 작동할것이다.
     </para>
     <para>
      과거에 잘못 설정된 에러 보고 시스템 때문에 require된 파일 안에 
      '}' 같은 것을 빠뜨렸을 경우를 &true;로 보고 해석기가 보고하지 않아서
      추적할수 없었던 스크립트 엔진의 문제점이 보고되었는데,
      이것은 이런 버그 레포트가 더이상 생기지 않도록 해주었다.
     </para>
     <para>
      그래서 에러 보고 설정을 체크하는것은 스크립트를 조용하게 die시킬때
      우선적으로 해야할 일이다. 젠드 엔진은 현재 이런 종류의 이상한
      동작을 발생시키지 않을만큼 충분히 성숙돼 있다고 판단된다.
     </para>
    </warning>
   </section>

   <section id='migration4.error-reporting.additions'>
    <title>추가된 경고 메시지</title>
    <para>
     기존의 많은 PHP 3 코드는 좋지 않은 스타일의 언어 구조를 사용하였다.
     이 코드는 다른 장소의 코드 변화에 의해 쉽게 파괴될수 있다.
     PHP 4는 그런 상황에서 PHP 3에서 하지않았던 많은 경고 
     메시지를 출력할것이다. 이런 경고메시지를 고치려면 단지
     E_NOTICE 메시지를 꺼놓아도 되지만, 대신 그 코드를 고치는것이
     더 좋은 생각이다.
    </para>
    <para>
     현재 경고메시지를 발생할수 있는 가장 일반적인 경우가 따옴표로 
     둘러싸지않고 문자열 상수를 배열의 인덱스로 사용하는 것이다. PHP 3와
     PHP 4 모두 이것이 그 이름으로 선언된 상수나 키워드가 아니면 
     문자열로 해석하게 될것이다. 그러나 그 코드이외의 곳에서 그 이름을
     갖는 상수가 선언되기만 하면 그 스크립트를 제대로 작동할수 없게 할수 있다.
     그 스크립트에서 침입자에게 주어서는 안될 권한을 줄수 있게 하는 방법으로
     침입자가 문자열 상수를 재선언할수만 있다면 보안적인 위험이 될수도 있다.
     그래서 PHP 4는 현재 따옴표로 둘러싸지 않은 문자열 상수를 사용할때마다
     경고를 하게 될것이다. <literal>$_SERVER[REQUEST_METHOD]</literal>와 같은 
     예를 들수 있다. 이것을 <literal>$_SERVER['REQUEST_METHOD']</literal>으로
     변경하면 해석기도 편해지고 스타일과 보안을 크게 향상시킬것이다.
    </para>
    <para>
     PHP 4가 경고 할 수 있는 다른 것이 초기화되지 않은
     변수나 배열 구성요소의 사용이다.
    </para>
   </section>
   
  </section>

  <section id='migration4.initializers'>
   <title>초기화</title>
   <para>
    static 변수와 클래스 멤버 초기화는 오직 스칼라 값만을 허용한다.
    반면에 PHP 3에서는 모든 유효 표현식이 허용된다. 이것은
    ,다시 한번 말하지만, 해석과 실행이 분리되었기 때문이다. 
    즉 해석기가 생성자를 볼때는 아무 코드도 아직 실행되어 있지
    않은 상태에 있다.
   </para>
   <para>
    클래스에서는 멤버 변수를 초기화하기 위해 생성자를 사용해야
    한다. 단순한 static 값을 제외한 모든 static 변수는 이것과는 거의
    상관이 없다.
   </para>
  </section>

  <section id='migration4.empty'>
   <title><literal>empty("0")</literal></title>
   <para>
    아마도 동작에 있어서 가장 쟁점이 되었던 변화가
    <function>empty</function>의 동작에 대한 것이다. 문자 '0' (제로) 만을
    내포하는 문자열은 현재 비어있다고 본다. 반면에 PHP 3는 그렇지 않았다.
   </para>
   <para> 
    이런 새로운 동작은 숫자 입력이 요구될지라도 문자열을 리턴하는 입력
    필드를 갖고, 자동으로 타입 변환을 하는 기능이 있는 PHP의
    웹 응용프로그램에서는 적절하다. 그러나 다른면에서는 적절한 방식의
    코드를 제대로 동작시키지 않을수도 있다. 무엇을 찾아야할지 알수 없다면
    이런 잘못된 동작을 유도하는것을 추적하기 힘들것이다.
   </para>
  </section>

  <section id='migration4.missing'>
   <title>Missing functions</title>
   <para>
    While PHP 4 comes with a lot of new features, functions and
    extensions, you may still find some functions from version 3
    missing. A small number of core functions has vanished because
    they do not work with the new scheme of splitting parsing and
    execution as introduced into 4 with the Zend engine.  Other
    functions and even complete extensions have become obsolete as
    newer functions and extensions serve the same task better and/or
    in a more general way. Some functions just simply haven't been
    ported yet and finally some functions or extensions may be missing
    due to license conflicts.
   </para>

   <section id='migration4.missing.concept'>
    <title>Functions missing due to conceptual changes</title>
    <para>
     As PHP 4 now separates parsing from execution it is no longer
     possible to change the behavior of the parser (now embedded in
     the Zend engine) at runtime as parsing already happened by
     then. So the function <function>short_tags</function> no longer
     exists. You can still change the parsers behavior by setting
     appropriate values in the &php.ini; file.
    </para>
    <para>
     Another feature of PHP 3 that is not a part of PHP 4 is the bundled
     debugging interface. There are third-party add-ons for the Zend engine
     which add similar functionality.
    </para>
   </section>

   <section id='migration4.deprecate'>
    <title>Deprecate functions and extensions</title>
    <para>
     The Adabas and Solid database extensions are no more. Long live
     the unified ODBC extension instead.
    </para>
   </section>

   <section id='migration4.unset'>
    <title>Changed status for <function>unset</function></title>
    <para>
     <function>unset</function>, although still available, is
     implemented as a language construct rather than a function.
    </para>
    <para>
     This does not have any consequences on the behavior of
     <function>unset</function>, but testing for "unset" using
     <function>function_exists</function> will return &false; as it would with
     other language constructs that look like functions such as
     <function>echo</function>.
    </para>
    <para>
     Another more practical change is that it is no longer possible to
     call <function>unset</function> indirectly, that is
     <literal>$func="unset"; $func($somevar)</literal> won't work
     anymore.
    </para>
   </section>
  </section>

  <section id='migration4.extensions'>
   <title>PHP 3 extension</title>
   <para>
    Extensions written for PHP 3 will not work with PHP 4, neither as binaries
    nor at the source level. It is not difficult to port extensions to PHP 4
    if you have access to the original source. A detailed description of the
     actual porting process is not part of this text.
   </para>
  </section>

  <section id='migration4.strings'>
   <title>Variable substitution in strings</title>
   <para>
    PHP 4 adds a new mechanism to variable substitution in
    strings. You can now finally access object member variables and
    elements from multidimensional arrays within strings.
   </para>
   <para>
    To do so you have to enclose your variables with curly braces with
    the dollar sign immediately following the opening brace:
    <literal>{$...}</literal>
   </para>
   <para>
    To embed the value of an object member variable into a string you
    simply write <literal>"text {$obj-&gt;member} text"</literal> while
    in PHP 3 you had to use something like <literal>"text
    ".$obj-&gt;member." text"</literal>.
   </para>
   <para>
    This should lead to more readable code, while it may break
    existing scripts written for PHP 3. But you can easily check for
    this kind of problem by checking for the character combination
    <literal>{$</literal> in your code and by replacing it with
    <literal>\{$</literal> with your favorite search-and-replace
    tool.
   </para>
  </section>

  <section id='migration4.cookies'>
   <title>Cookies</title>
   <para>
    PHP 3 had the bad habit of setting cookies in the reverse order
    of the <function>setcookie</function> calls in your code. PHP 4
    breaks with this habit and creates the cookie header lines in
    exactly the same order as you set the cookies in the code.
   </para>
   <para>
    This might break some existing code, but the old behaviour was so
    strange to understand that it deserved a change to prevent further
    problems in the future.
   </para>
  </section>

  <section id='migration4.variables'>
   <title>Handling of global variables</title>
   <para>
    While handling of global variables had the focus on to be easy in
    PHP 3 and early versions of PHP 4, the focus has changed to be more
    secure. While in PHP 3 the following example worked fine, in PHP 4 it
    has to be unset($GLOBALS["id"]);. This is only one issue of global
    variable handling. You should always have used $GLOBALS, with
    newer versions of PHP 4 you are forced to do so in most cases.
    Read more on this subject in the <link linkend="references.global">
    <literal>global</literal> references section</link>.
   </para>
   <example>
    <title>Migration of global variables</title>
    <programlisting role="php">
<![CDATA[
<?php
$id = 1;
function test()
{
    global $id;
    unset($id);
}
test();
echo($id); // This will print out 1 in PHP 4
?>
]]>
    </programlisting>
   </example>
  </section>

 </appendix>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
