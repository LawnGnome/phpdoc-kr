<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.34 Maintainer: fuzzy74 Status: ready -->
 <appendix id="migration4">
  <title>PHP 3 에서 PHP 4로 이주</title>
	
  <section id='migration4.changes'>
   <title>PHP 4에서 바뀐것</title>
   <para>
    PHP 4 와 젠드 엔진은 PHP의 성능과 기능을 크게 향상시켰다.
    그러면서도 기존의 코드가 잘 작동할수 있도록 하기위해 주의를 많이
    기울였다. PHP 3에서 4로 이주하는 것은 PHP/FI 2에서 PHP 3로 이주하는
    것보다는 훨씬 쉽다. 기존의 많은 PHP 3 코드를 변경없이 동작시킬수 
    있다. 그러나 아직은 약간의 차이를 알아야 하고, 개발 환경에서 버전을
    전환하기 전에 코드를 테스트하는데 주의를 기울여야 한다. 다음글은
    무엇에 주의해야 하는지에 대한 몇가지 힌트를 보여줄것이다.
   </para>
  </section>

  <section id="migration4.php4.with.php3">
   <title>PHP 3와 PHP 4를 동시에 작동시키기 </title>
   <simpara>
    최근 운영 체제는 버전관리(versioning)와 영역관리(scoping) 기능을
    제공한다. 이런 기능은 PHP 3와 PHP 3가 아파치 서버에서 동시에
    동작하는 모듈로 운영될수 있게 해준다.
   </simpara>
   <simpara>
    이 기능은 다음의 플랫폼에서 작동하는것으로 알려져있다:
   </simpara>
   <itemizedlist>
     <listitem><simpara>최신판의 binutils를 갖는 리눅스 (binutils 2.9.1.0.25가 테스트됨) </simpara></listitem>
     <listitem><simpara>Solaris 2.5 이상</simpara></listitem>
     <listitem><simpara>FreeBSD (3.2, 4.0 에서 테스트됨)</simpara></listitem>
   </itemizedlist>
   <para>
    이 기능을 활성화시키려면, APXS(--with-apxs)와 필수 링크 확장(--enable-versioning)을
    사용하여 PHP3와 PHP4를 설정한다. 그렇지 않으면, 모든 표준 설치
    명령이 적용된다. 예를 들면:
    <informalexample>
     <programlisting role="configure">
<![CDATA[
$ ./configure \
  --with-apxs=/apache/bin/apxs \
  --enable-versioning \
  --with-mysql \
  --enable-track-vars
]]>
		 </programlisting>
		</informalexample>
   </para>
  </section>

  <section id="migration4.configuration">
   <title>설정파일 이주하기</title>
   <para>
    전역 설정 파일, <filename>php3.ini</filename>, 는 &php.ini;로 
    이름이 변경되었다.
   </para>
   <para>
    아파치 설정 파일에서는 약간의 변화가 생겼다. PHP 모듈에 의해
    인식되는 MIME 타입이 변경되었다.
    <informalexample>
		 <programlisting role="apache">
<![CDATA[
application/x-httpd-php3        -->    application/x-httpd-php
application/x-httpd-php3-source -->    application/x-httpd-php-source
]]>
		 </programlisting>
		</informalexample>
   </para>
   <para>
    두가지 버전의 PHP와 함께 작동하는 설정 파일을 만들수 있다(서버에
    현재 결합되어있는 버전에 따라). 다음과 같은 문법을 사용한다.
    <informalexample>
		 <programlisting>
<![CDATA[
AddType  application/x-httpd-php3        .php3
AddType  application/x-httpd-php3-source .php3s

AddType  application/x-httpd-php         .php
AddType  application/x-httpd-php-source  .phps
]]>
     </programlisting>
		</informalexample>
   </para>
   <simpara>
    추가로, 아파치에 대한 PHP 디렉티브 이름도 변경되었다.
   </simpara>
   <para>
    PHP 4.0부터는, 4가지의 아파치 디렉티브만이 PHP와 관련되어있다.
    <informalexample>
		 <programlisting role="apache">
<![CDATA[
php_value [PHP directive name] [value]
php_flag [PHP directive name] [On|Off]
php_admin_value [PHP directive name] [value]
php_admin_flag [PHP directive name] [On|Off]
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    There are two differences between the Admin values and the non admin values:
    admin이 있는 디렉티브 값과 admin이 없는 값 사이에는 두가지 차이가 있다:
   </simpara>
   <itemizedlist>
    <listitem>
     <simpara>
      Admin 값(또는 플래그)는 서버-전반에 영향을 미치는 
      아파치 설정파일(e.g., &httpd.conf;)에만 존재한다.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      일반 값(또는 플래그)는 일부 PHP 디렉티브를 제어할수 없다. 예를 들면:
      &safemode; ( &htaccess;에서 안전모드(safe mode) 설정을 덮어쓴다면,
      &safemode;의 목적에 어긋나게 할것이다) . 이와 대조적으로, Admin 값은
      모든 PHP 디렉티브의 값을 변경할수 있다.
     </simpara>
    </listitem>
   </itemizedlist>
   <simpara>
    변경 처리를 좀더 쉽게 하기 위해, PHP 4에서는 PHP 3와 PHP 4가 함께 동작하는
    아파치 설정과 &htaccess; 파일을 자동으로 변환해주는 스크립트를 함께 제공한다.
    이 스크립트는 mime타입 라인을 변경하지 않는다! 이 부분은 직접 변환해야 한다.
   </simpara>
   <para>
    아파치 설정 파일을 변경하기 위해서는, apconf-conv.sh 스크립트
    (scripts/apache/ 디렉토리에 위치함)를 실행한다. 예를 들면:
    <informalexample>
		 <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  ./apconf-conv.sh /usr/local/apache/conf/httpd.conf
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    원래 설정 파일은 httpd.conf.orig로 저장될것이다.
   </simpara>
   <para>
    &htaccess; 파일을 변환하기 위해서는, 
    <filename>aphtaccess-conv.sh</filename> 스크립트
    (<filename>scripts/apache/</filename> 디렉토리에도 위치)를 
    실행한다:
    <informalexample>
		 <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  find / -name .htaccess -exec ./aphtaccess-conv.sh {} \;
]]>
	 </programlisting>
    </informalexample>
   </para>
   <simpara>
    이것도 구버전의 &htaccess; 파일을 .orig 어미가 붙어 저장할것이다.
   </simpara>
   <simpara>
    변환 스크립트가 작동하기 위해서는 awk가 설치되어있어야 한다.
   </simpara>
  </section>

  <section id='migration4.parser'>
   <title>해석기(Parser) 동작</title>
   <para>
    해석과 실행은 현재 두 단계로 완전히 따로 분리되어있다. 파일 코드의 실행은
    그 파일전체와 그 파일이 필요로 하는 모든 것들이 성공적으로 해석되고나서야
    비로소 이루어진다.
   </para>
   <para>
    이런 분리를 위해 새로이 필요하게 된것 중 하나는 require와 include된
    파일이 문법적으로 완벽해야 한다는 것이다. 이제 더이상 여러 파일간에
    제어 구조의 서로 다른 제어 부분을 나눌수 없다. 
    어떤 파일 안에서 <literal>for</literal>나 <literal>while</literal>루프,
    <literal>if</literal> 구문이나 <literal>switch</literal> 블록으로 시작하거나
    또 다른 파일 안에서 <literal>else</literal>, <literal>endif</literal>,
    <literal>case</literal> 나 <literal>break</literal>구문을 갖을수 없다.
   </para>
   <para>
    루프나 다른 제어 구조안에서 추가코드를 include하는 것은 아직은 완전히
    유효하다. 단, 제어 핵심어와 닫힌 중괄호 <literal>{...}</literal> 는 동일한
    통합 유닛(파일이나 <function>eval</function>이 적용된 문자열)안에 있어야
    한다.
   </para>
   <para>
    이와 같은 분리된 코드는 어쨋든 매우 나쁜 스타일이긴 하지만
    크게 해를 끼치지는 않을것이다.
   </para>
   <para>
    더이상 유효하지 않은 또다른 특징은 PHP 3 코드에서는 거의 보이지는 않지만
    require된 파일로부터 리턴받는 값이다. include된 파일로부터 값을 리턴받는것은
    아직까지는 유효하다.
   </para>
  </section>

  <section id='migration4.error-reporting'>
   <title>에러 보고</title>
	 
   <section id='migration4.error-reporting.config'>
    <title>변경된 설정</title>
    <para>
     PHP 3에서 에러 보고 레벨은 단순하게 숫자값으로 설정되었다.
     이런 숫자값은 다른 에러 레벨과 관련된 숫자를 합쳐서 구성된다.
     이용가능한 값중에 15는 모든 에러를 보고하고 7은 나쁜 스타일에
     대한것과 이와 비슷한 것들을 보고하는 단순한 경고메시지를 제외한
     모든 것을 보고하는데 사용된다.
    </para>
    <para>
     PHP 4는 에러/경고 레벨을 다량 보유하고 있고 이는 의도된 동작을 위한
     설정에 사용되는 심볼릭 상수를 허용하는 설정 해석기로 인해 추가되었다.
    </para>
    <para>
     현재의 에러 보고 레벨은 심볼릭 상수 <literal>E_ALL</literal>에서 원하지
     않는 경고 레벨값을 x-or 연산을 수행하여 에러 메시지를 생성시키고 싶지 않은 
     경고 레벨을 명시적으로 제거하도록 설정해야 한다. 복잡해 보이는가?
     자, 에러 보고시스템에게 심볼릭 상수 <literal>E_NOTICE</literal>로 
     분류되어있는 단순한 스타일 경고를 제외한 모든것을 보고하도록
     해보자. &php.ini;에 다음 설정을 넣어야 할것이다:
     <literal>error_reporting = E_ALL &amp; ~ ( E_NOTICE )</literal>.
     이진수를 사용하거나 연산자 '|'를 사용하여 괄호 안에 적절한 상수를 
     추가함으로써 다른 경고도 감출수 있다:
     <literal>error_reporting= E_ALL &amp; ~ ( E_NOTICE | E_WARNING)</literal>.
    </para>
    <warning>
     <para>
      PHP 3에서 PHP 4로 코드나 서버를 업그레이드할때 이 설정을 체크해야 하고
      <function>error_reporting</function>를 호출하거나 
      새로운 에러 타입인 E_COMPILE_ERROR로 에러 보고를 비활성화시킬수 있다.
      이 기능은 무슨일이 일어났고 문제가 발생한 장소가 어디인지에 대한
      피드백 없이 비어있는 문서를 보여줄것이다.
     </para>
    </warning>
    <warning>
     <para>
      에러 보고를 설정하기 위해 구버전의 7과 15 값을 사용하는 것은 좋은
      생각이 아니다. 왜냐하면 이 값들은 해석 에러를 포함한 새로 추가된
      에러의 일부도 보이지 않게 하기 때문이다. 이 값들은 매우 이상한
      동작으로 유도할수 있는데 스크립트가 모든 장소에서 에러 메시지를
      보이며 작동할것이다.
     </para>
     <para>
      과거에 잘못 설정된 에러 보고 시스템 때문에 require된 파일 안에 
      '}' 같은 것을 빠뜨렸을 경우를 &true;로 보고 해석기가 보고하지 않아서
      추적할수 없었던 스크립트 엔진의 문제점이 보고되었는데,
      이것은 이런 버그 레포트가 더이상 생기지 않도록 해주었다.
     </para>
     <para>
      그래서 에러 보고 설정을 체크하는것은 스크립트를 조용하게 die시킬때
      우선적으로 해야할 일이다. 젠드 엔진은 현재 이런 종류의 이상한
      동작을 발생시키지 않을만큼 충분히 성숙돼 있다고 판단된다.
     </para>
    </warning>
   </section>

   <section id='migration4.error-reporting.additions'>
    <title>추가된 경고 메시지</title>
    <para>
     기존의 많은 PHP 3 코드는 좋지 않은 스타일의 언어 구조를 사용하였다.
     이 코드는 다른 장소의 코드 변화에 의해 쉽게 파괴될수 있다.
     PHP 4는 그런 상황에서 PHP 3에서 하지않았던 많은 경고 
     메시지를 출력할것이다. 이런 경고메시지를 고치려면 단지
     E_NOTICE 메시지를 꺼놓아도 되지만, 대신 그 코드를 고치는것이
     더 좋은 생각이다.
    </para>
    <para>
     현재 경고메시지를 발생할수 있는 가장 일반적인 경우가 따옴표로 
     둘러싸지않고 문자열 상수를 배열의 인덱스로 사용하는 것이다. PHP 3와
     PHP 4 모두 이것이 그 이름으로 선언된 상수나 키워드가 아니면 
     문자열로 해석하게 될것이다. 그러나 그 코드이외의 곳에서 그 이름을
     갖는 상수가 선언되기만 하면 그 스크립트를 제대로 작동할수 없게 할수 있다.
     그 스크립트에서 침입자에게 주어서는 안될 권한을 줄수 있게 하는 방법으로
     침입자가 문자열 상수를 재선언할수만 있다면 보안적인 위험이 될수도 있다.
     그래서 PHP 4는 현재 따옴표로 둘러싸지 않은 문자열 상수를 사용할때마다
     경고를 하게 될것이다. <literal>$_SERVER[REQUEST_METHOD]</literal>와 같은 
     예를 들수 있다. 이것을 <literal>$_SERVER['REQUEST_METHOD']</literal>으로
     변경하면 해석기도 편해지고 스타일과 보안을 크게 향상시킬것이다.
    </para>
    <para>
     PHP 4가 경고 할 수 있는 다른 것이 초기화되지 않은
     변수나 배열 구성요소의 사용이다.
    </para>
   </section>
   
  </section>

  <section id='migration4.initializers'>
   <title>초기화</title>
   <para>
    static 변수와 클래스 멤버 초기화는 오직 스칼라 값만을 허용한다.
    반면에 PHP 3에서는 모든 유효 표현식이 허용된다. 이것은
    ,다시 한번 말하지만, 해석과 실행이 분리되었기 때문이다. 
    즉 해석기가 생성자를 볼때는 아직 아무 코드도 실행되어 있지
    않은 상태에 있다.
   </para>
   <para>
    클래스에서는 멤버 변수를 초기화하기 위해 생성자를 사용해야
    한다. 단순한 static 값을 제외한 모든 static 변수는 이것과는 거의
    상관이 없다.
   </para>
  </section>

  <section id='migration4.empty'>
   <title><literal>empty("0")</literal></title>
   <para>
    아마도 동작에 있어서 가장 쟁점이 되었던 변화가
    <function>empty</function>의 동작에 대한 것이다. 문자 '0' (제로) 만을
    내포하는 문자열은 현재 비어있다고 본다. 반면에 PHP 3는 그렇지 않았다.
   </para>
   <para> 
    이런 새로운 동작은 숫자 입력이 요구될지라도 문자열을 리턴하는 입력
    필드를 갖고, 자동으로 타입 변환을 하는 기능이 있는 PHP의
    웹 응용프로그램에서는 적절하다. 그러나 다른면에서는 적절한 방식의
    코드를 제대로 동작시키지 않을수도 있다. 무엇을 찾아야할지 알수 없다면
    이런 잘못된 동작을 유도하는것을 추적하기 힘들것이다.
   </para>
  </section>

  <section id='migration4.missing'>
   <title>사라진 함수들</title>
   <para>
    PHP 4는 수많은 새로운 기능, 함수, 확장과 함께 릴리즈되었다.
    그러나 버전 3에서 제공되던 함수가 몇개 빠졌다는것을 발견할수 있다.
    소량의 핵심 함수는 그 함수들이 젠드가 4로 제공하는 해석과 실행을
    분리하는 새로운 구조때문에 사라지게 되었다. 다른 함수와
    완벽한 확장까지도 새로운 함수와 확장이 같은 작업을 더 잘수행하고
    그리고/또는 좀더 일반화된 방식으로 수행되기 때문에 쓸모없게 되었다.
    몇개의 함수들은 단순히 아직 포팅되지 않았고 마지막으로 몇개의 함수와
    확장은 라이센스 때문에 사라질수도 있게 되었다.
   </para>

   <section id='migration4.missing.concept'>
    <title>구조적 변화때문에 사라진 함수들</title>
    <para>
     현재 PHP 4는 실행과 해석을 분리했기 때문에 이미 
     해석기(젠드 엔진에 내장됨)에 의해 해석이 끝나고 나서 런타임시에는
     해석기에 의해 동작을 변경할수 없다. 그래서 함수 
     <function>short_tags</function>은 더이상 존재하지 않는다. 
     그러나 아직은 &php.ini; 파일에 적절한 값을 설정함으로써
     해석기의 동작을 변경할수 있다.
    </para>
    <para>
     PHP 4의 일부가 아니지만 PHP 3의 또다른 기능은 같이 제공된 디버깅
     인터페이스이다. 같은 기능을 추가한 젠드 엔진용의 서드파티 애드온이
     존재한다.
    </para>
   </section>

   <section id='migration4.deprecate'>
    <title>지원되지 않는 함수와 확장</title>
    <para>
     Adabas 와 Solid 데이터베이스 확장은 더이상 지원되지 않는다.
     대신 단일화된 ODBC 확장이 살아 남았다.
    </para>
   </section>

   <section id='migration4.unset'>
    <title><function>unset</function>을 위한 변경 상태</title>
    <para>
     <function>unset</function>, 아직 지원되지만, 함수로서보다는
     언어 구조로서 구현되었다.
    </para>
    <para>
     <function>unset</function>의 동작에 대해 어떤 영향도 받지 않는다.
     <function>function_exists</function>을 사용하여 "unset"을
     테스트하면 &false;를 리턴할것이다. 
     <function>echo</function>함수처럼 언어 구조로서의 역할을 담당한다.
    </para>
    <para>
     좀더 실질적인 변화는 간접적으로 <function>unset</function>을
     호출할수 없다는 것이다. 즉,
     <literal>$func="unset"; $func($somevar)</literal>은 더이상
     동작하지 않을것이다.
    </para>
   </section>
  </section>

  <section id='migration4.extensions'>
   <title>PHP 3 확장</title>
   <para>
    PHP 3를 위해 씌여진 확장은 PHP 4에서 작동하지 않을것이다. 이진파일도 안되고
    소스 레벨도 되지 않는다. 원 소스를 접근할수 있다면 PHP 4로 확장을 포팅하는것은
    어렵지 않다. 실제 포팅 방법에 대한 상세한 설명은 이 매뉴얼에는 존재하지 않는다.
   </para>
  </section>

  <section id='migration4.strings'>
   <title>Variable substitution in strings</title>
   <para>
    PHP 4는 문자열의 가변 치환이라는 새로운 메카니즘을 추가시켰다.
    그래서 문자열 안에서 객체 멤버 변수와 다차원 배열의 구성요소에
    접근할수 있다.
   </para>
   <para>
    그렇게 하기 위해서는 달러사인이 바로 뒤에 붙고 중괄호로 막아놓은 변수를 
    사용해야 한다. 다음과 같은 형태의 중괄호:
    <literal>{$...}</literal>
   </para>
   <para>
    문자열 안에 객체 멤버 변수의 값을 내장시키기 위해서는 간단히
    <literal>"text {$obj-&gt;member} text"</literal>이라고 쓰면 된다.
    PHP 3에서는 <literal>"text ".$obj-&gt;member." text"</literal>와
    같은 형태로 사용해야 했다.
   </para>
   <para>
    이런 형태는 좀더 읽기 좋은 코드로 유도되어야 한다. PHP 3를 위해
    쓰여진 기존의 스크립트를 동작시키지 않을수도 있기 때문이다. 그러나
    이런 종류의 문제는 코드내에서 <literal>{$</literal> 문자 조합을
    체크함으로서 간단하게 확인될수 있다. 그리고 선호하는 검색-변경 툴을
    사용하여 <literal>\{$</literal>으로 대체하면 된다. 
   </para>
  </section>

  <section id='migration4.cookies'>
   <title>쿠키</title>
   <para>
    PHP 3는 코드내에서 <function>setcookie</function> 호출은 반대방향으로
    쿠키를 설정하는 좋지 않은 방식을 사용한다. PHP 4는 이런 방식에 의해
    동작하지 않는다. 코드에서 쿠키를 설정하는 순대대로 정확하게 쿠키 헤더
    줄을 만든다.
   </para>
   <para>
    이런 동작은 몇몇 기존 코드를 파괴할수 있다. 그러나 구버전의 동작은
    매우 이상해서 앞으로의 더 큰 문제를 차단하기 위해 변경할 필요가 있는지
    이해할수 없다.
   </para>
  </section>

  <section id='migration4.variables'>
   <title>전역 변수 다루기</title>
   <para>
    PHP 3와 초기 PHP 4버전에서는 전역 변수를 좀 더 쉽게 다룰수 있지만
    약점이 될수 있기 때문에 좀더 안전하게 바뀌었다.
    PHP 3에서 다음 예제 코드는 잘 작동하지만, PHP 4에서는 unset($GLOBALS["id"]);을
    해야 한다. 이 이슈는 단지 전역 변수를 다루는 데만 한정된다. 
    PHP 4의 최신 버전에서는 항상 $GLOBALS를 사용해야 하고
    대부분의 경우에 그렇게 해야 할것이다.
    <link linkend="references.global">
    <literal>global</literal> 레퍼런스 섹션</link>에서 이 주제에 대한 더 많은
    정보를 볼수 있다.
   </para>
   <example>
    <title>전역변수의 이주</title>
    <programlisting role="php">
<![CDATA[
<?php
$id = 1;
function test()
{
    global $id;
    unset($id);
}
test();
echo($id); // This will print out 1 in PHP 4
?>
]]>
    </programlisting>
   </example>
  </section>

 </appendix>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
