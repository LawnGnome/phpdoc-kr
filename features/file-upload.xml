<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.63 -->
 <chapter id="features.file-upload">
  <title>파일 업로드 다루기</title>

  <sect1 id="features.file-upload.post-method">
   <title>POST 방식 업로드</title>

   <simpara>
    PHP는 RFC-1867 호환 브라우저(넷스케이프 네비게이터 3 이상,
    마이크로소프트 인터넷 익스플로러 3 이상을 포함)로 부터 파일 업로드를
    받을 수 있습니다. 이 기능은 사람들이 텍스트와 바이너리 파일을 동시에
    업로드 할 수 있게 합니다. PHP의 인증과 파일 관리 함수를 이용해서,
    업로드를 할 수 있는 사람과 업로드된 파일이 어떻게 처리될지를 완벽하게
    제어할 수 있습니다.
   </simpara>
   <note>
    <title>관련 환경설정</title>
    <para>
     &php.ini;의 <link linkend="ini.file-uploads">file_uploads</link>, 
     <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
     <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link>,
     <link linkend="ini.post-max-size">post_max_size</link> 지시자를 참고하십시오.
    </para>
   </note>
   <para>
    PHP는 넷스케이프 컴포져와 W3C의 Amaya 클라이언트가 사용하는
    PUT 방식 파일 업로드도 지원합니다. 자세한 내용은 <link
    linkend="features.file-upload.put-method">PUT 방식 지원</link>을
    참고하십시오.
   </para>
   <para>
    파일 업로드 화면은 아래와 같은 특별한 폼으로 만들어집니다:
   </para>
   <para>
    <example>
     <title>파일 업로드 폼</title>
     <programlisting role="html">
<![CDATA[
<form enctype="multipart/form-data" action="_URL_" method="POST">
<input type="hidden" name="MAX_FILE_SIZE" value="30000">
이 파일을 전송합니다: <input name="userfile" type="file">
<input type="submit" value="파일 전송">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    위 예제의 "_URL_"을 변경하여, PHP 파일을 지시하도록 해야합니다.
    MAX_FILE_SIZE 히든 필드는 파일 인풋 필드보다 앞에 위치해야 하며, 
    최대 파일크기(바이트로 지시)를 값으로 가집니다. 또한, 파일 업로드 폼이
    <literal>enctype="multipart/form-data"</literal>을 가지고 있어야 하며,
    그렇지않으면 파일 업로드는 작동하지 않습니다.
    <warning>
     <para>
      MAX_FILE_SIZE는 브라우저에 대한 권고입니다. 이 최대값을 피하는 것은
      간단합니다. 그러므로 브라우저가 원하는 대로 작동하리라고는 생각하지
      마십시오! 그러나, PHP 세팅의 최대 크기는 속일 수 없습니다.
      어찌되었건, MAX_FILE_SIZE를 추가해서 사용자가 큰 파일을 전송한 뒤,
      너무 크다는걸 발견하는 동안의 시간을 보전할 수 있습니다.
     </para>
    </warning>
   </para>

   <para>
    업로드된 파일을 정의하는 변수는 PHP 버전과 환경 설정에 따라 달라집니다.
    자동 전역 <link linkend="reserved.variables.files">$_FILES</link>는
    PHP 4.1.0부터 존재합니다. <varname>$HTTP_POST_FILES</varname> 배열은
    PHP 4.1.0부터 존재했습니다. 이 배열들은 업로드 된 파일의
    모든 정보를 가지고 있습니다. <varname>$_FILES</varname>를 사용하는
    것을 권장합니다. PHP 지시자
    <link linkend="ini.register-globals">register_globals</link>가
    <emphasis>on</emphasis>일때는, 관련된 변수 이름도 존재합니다.
    <link linkend="ini.register-globals">register_globals</link>의
    기본값은 PHP <ulink url="&url.php.release4.2.0;">4.2.0</ulink>부터
    <emphasis>off</emphasis>입니다.
   </para>
   <para>
    예제 스크립트에서 <link linkend="reserved.variables.files">$_FILES</link>의
    내용은 다음과 같습니다. 위 예제 스크립트에서 사용한 파일 업로드 이름
    <emphasis>userfile</emphasis>로 표현함에 주의하십시오. 어떠한 이름이라도
    가질 수 있습니다.
    <variablelist>
     <varlistentry>
      <term><varname>$_FILES['userfile']['name']</varname></term>
      <listitem>
       <para>
        클라이언트 머신에 존재하는 파일의 원래 이름.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['type']</varname></term>
      <listitem>
       <para>
        브라우저가 이 정보를 제공할 경우에, 파일의 mime 형식.
        예를 들면 <literal>"image/gif"</literal>.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['size']</varname></term>
      <listitem>
       <para>
        업로드된 파일의 바이트로 표현한 크기.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['tmp_name']</varname></term>
      <listitem>
       <para>
        서버에 저장된 업로드된 파일의 임시 파일 이름.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['error']</varname></term>
      <listitem>
       <para>
        파일 업로드에 관련한 <link linkend="features.file-upload.errors">에러
        코드</link>. <emphasis>['error']</emphasis>는 PHP 4.2.0에서 추가되었습니다.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     PHP 4.1.0 이전 버전에서는 <varname>$HTTP_POST_FILES</varname>이고,
     <varname>$_FILES</varname>와 같은
     <link linkend="language.variables.superglobals">자동 전역</link> 변수는
     존재하지 않습니다. PHP 3는 <varname>$HTTP_POST_FILES</varname>를
     지원하지 않습니다.
    </para>
   </note>
   <para>
    &php.ini;에서 <link linkend="ini.register-globals">register_globals</link>가
    <emphasis>on</emphasis>일때, 변수가 추가로 사용 가능합니다. 예를 들면,
    <varname>$userfile_name</varname>은 <varname>$_FILES['userfile']['name']</varname>과
    같고, <varname>$userfile_type</varname>은
    <varname>$_FILES['userfile']['type']</varname>과 같습니다.
    PHP 4.2.0부터 register_globals의 기본값이 off임에 주의하십시오.
    이 지시자에 의존하지 않는 편을 권장합니다.
   </para>
   <para>
    &php.ini;에서 <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link>을
    이용하여 다른 위치를 지정하지 않는 한, 파일은 서버의 기본 임시 디렉토리에
    저장됩니다. 서버의 기본 디렉토리는 PHP를 실행하는 환경의 환경 변수
    <envar>TMPDIR</envar>을 통해서 변경할 수 있습니다. PHP 스크립트 내부에서
    <function>putenv</function>를 통해서 설정하는 것은 작동하지 않습니다.
    물론, 이 환경 변수는 업로드된 파일에 다른 작업을 할 때 사용할 수 있습니다.
    <example>
     <title>파일 업로드 확인하기</title>
     <para>
      추가 정보는 <function>is_uploaded_file</function>와
      <function>move_uploaded_file</function>에 대한 함수 정보를 참고하십시오.
      다음 예제는 폼에서 전송된 파일 업로드를 처리합니다.
     </para>
     <programlisting role="php">
<![CDATA[
<?php
// 4.1.0 이전의 PHP에서는, $_FILES 대신에 $HTTP_POST_FILES를 사용해야
// 합니다. 4.0.3 이전의 PHP에서는, move_uploaded_file 대신에 copy()와
// is_uploaded_file()을 사용하십시오.

$uploaddir = '/var/www/uploads/';
$uploadfile = $uploaddir. $_FILES['userfile']['name'];

print "<pre>";
if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploadfile)) {
    print "파일이 존재하고, 성공적으로 업로드 되었습니다.";
    print "추가 디버깅 정보입니다:\n";
    print_r($_FILES);
} else {
    print "파일 업로드 공격의 가능성이 있습니다! 디버깅 정보입니다:\n";
    print_r($_FILES);
}
print "</pre>";

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    업로드된 파일을 받는 PHP 스크립트는 업로드된 파일로 무엇을 할 지를
    결정하는 로직을 포함하고 있어야 합니다. 예를 들면
    <varname>$_FILES['userfile']['size']</varname> 변수를
    너무 작거나 큰 파일을 처리하는데 이용할 수 있습니다.
    <varname>$_FILES['userfile']['type']</varname> 변수를 형식 기준에
    맞지 않는 파일을 처리하는데에 이용할 수도 있습니다.
    PHP 4.2.0부터, <varname>$_FILES['userfile']['error']</varname>를
    이용하여 <link linkend="features.file-upload.errors">에러 코드</link>에
    따라 처리하게 할 수 있습니다.
    어떠한 로직이던, 임시 디렉토리에서 파일을 지우거나 다른 곳으로
    이동시켜야 합니다.
   </simpara>
   <simpara>
    요청의 마지막에 이동되거나 이동이 변경되지 않은 임시 디렉토리의
    파일은 지워지게 됩니다.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.errors">
   <title>에러 메세지 설명</title>
   <simpara>
    PHP 4.2.0부터, PHP는 파일 배열에 적절한 에러 코드를 반환합니다. 에러 코드는
    PHP로 파일을 업로드 했을때 만들어지는 파일 배열의 <emphasis>['error']</emphasis>
    세그먼트에서 확인할 수 있습니다. 예를 들면,
    <varname>$_FILES['userfile']['error']</varname>에서 확인할 수 있을겁니다.
   </simpara>
   <para>
    <variablelist>
     <varlistentry>
      <term><varname>UPLOAD_ERR_OK</varname></term>
      <listitem>
       <para>
        값: 0; 오류 없이 파일 업로드가 성공했습니다.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_INI_SIZE</varname></term>
      <listitem>
       <para>
        값: 1; 파일이 &php.ini;의
        <link linkend="ini.upload-max-filesize">upload_max_filesize</link>
        지시자에 도달했습니다.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_FORM_SIZE</varname></term>
      <listitem>
       <para>
        값: 2; 파일이 HTML 폼에서 지정한 <emphasis>MAX_FILE_SIZE</emphasis>
        지시자에 도달했습니다.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_PARTIAL</varname></term>
      <listitem>
       <para>
        값: 3; 파일이 일부분만 전송되었습니다.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_NO_FILE</varname></term>
      <listitem>
       <para>
        값: 4; 파일이 전송되지 않았습니다.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     이들은 PHP 4.3.0에서 PHP 상수가 되었습니다.
    </para>
   </note>
  </sect1>

  <sect1 id="features.file-upload.common-pitfalls">
   <title>일반적인 문제</title>
   <simpara>
    <literal>MAX_FILE_SIZE</literal>는 ini 설정 <link
    linkend="ini.upload-max-filesize">upload_max_filesize</link>보다
    큰 파일 크기를 지정할 수 없습니다. 기본값은 2 메가바이트입니다.
   </simpara>
   <simpara>
    메모리 제한을 활성화하면, 큰 값의 <link
    linkend="ini.memory-limit">memory_limit</link>가 필요합니다.
    <link linkend="ini.memory-limit">memory_limit</link>를 충분히
    크게 설정했는지 확인해보십시오.
   </simpara>
   <simpara>
    <link linkend="ini.max-execution-time">max_execution_time</link>을
    너무 작게 설정하면, 스크립트 실행이 값에 도달해버립니다.
    <literal>max_execution_time</literal>을 충분히 크게 설정했는지
    확인해보십시오.
   </simpara>
   <note>
    <simpara>
     <link linkend="ini.max-execution-time">max_execution_time</link>은
     스크립트 자신의 실행 시간에만 영향을 미칩니다. <function>system</function>,
     <function>sleep</function> 함수의 시스템 호출, 데이터베이스 쿼리,
     파일 업로드 과정에 걸리는 시간 등 스크립트 밖에서 실행하는데 소모되는
     시간은 스크립트 실행의 최대 시간을 측정하는 데에 포함되지 않습니다.
    </simpara>
   </note>    
   <simpara>
    <link linkend="ini.post-max-size">post_max_size</link>을 너무 작게
    설정하면, 큰 파일은 업로드할 수 없습니다. <literal>post_max_size</literal>을
    충분히 크게 설정했는지 확인해보십시오.
   </simpara>
   <simpara>
    Not validating which file you operate on may mean that users can access
    sensitive information in other directories.
   </simpara>
   <simpara>
    CERN httpd는 클라이언트에서 보내지는 content-type 마임 헤더의
    첫번째 공백을 제거하는 것에 주의하십시오. 이 문제로 인해서, CERN
    httpd는 파일 업로드 기능을 지원하지 않습니다.
   </simpara>
   <simpara>
    Due to the large amount of directory listing styles we cannot guarantee
    that files with exotic names (like containing spaces) are handled properly.
   </simpara>
  </sect1>
  
  <sect1 id="features.file-upload.multiple">
   <title>복수 파일 업로드하기</title>
   <simpara>
    복수 파일은 <literal>input</literal>에서 다른
    <literal>name</literal>을 사용해서 업로드 할 수 있습니다.
   </simpara>
   <simpara>
    It is also possible to upload multiple files simultaneously and
    have the information organized automatically in arrays for you. To
    do so, you need to use the same array submission syntax in the
    HTML form as you do with multiple selects and checkboxes:
   </simpara>
   <note>
    <para>
     Support for multiple file uploads was added in version 3.0.10.
    </para>
   </note>
   <para>
    <example>
     <title>Uploading multiple files</title>
     <programlisting role="html">
<![CDATA[
<form action="file-upload.php" method="POST" enctype="multipart/form-data">
  Send these files:<br>
  <input name="userfile[]" type="file"><br>
  <input name="userfile[]" type="file"><br>
  <input type="submit" value="Send files">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    When the above form is submitted, the arrays
    <varname>$_FILES['userfile']</varname>,
    <varname>$_FILES['userfile']['name']</varname>, and
    <varname>$_FILES['userfile']['size']</varname> will be
    initialized (as well as in $HTTP_POST_FILES for PHP version
    prior 4.1.0).
    When
    <literal>register_globals</literal> is on, globals for uploaded
    files are also initialized. Each of these will be a numerically
    indexed array of the appropriate values for the submitted files.
   </simpara>
   <simpara>
    For instance, assume that the filenames
    <filename>/home/test/review.html</filename> and
    <filename>/home/test/xwp.out</filename> are submitted.  In this
    case, <varname>$_FILES['userfile']['name'][0]</varname>
    would contain the value <filename>review.html</filename>, and
    <varname>$_FILES['userfile']['name'][1]</varname> would
    contain the value <filename>xwp.out</filename>. Similarly,
    <varname>$_FILES['userfile']['size'][0]</varname> would
    contain <filename>review.html</filename>'s filesize, and so forth.
   </simpara>
   <simpara>
    <varname>$_FILES['userfile']['name'][0]</varname>,
    <varname>$_FILES['userfile']['tmp_name'][0]</varname>,
    <varname>$_FILES['userfile']['size'][0]</varname>, and
    <varname>$_FILES['userfile']['type'][0]</varname> are
    also set.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.put-method">
   <title>PUT 방식 지원</title>
   <simpara>
    PUT method support has changed between PHP 3 and PHP 4.
    In PHP 4, one should use the standard input stream to read
    the contents of an HTTP PUT.
   </simpara>
   <para>
    <example>
     <title>Saving HTTP PUT files with PHP 4</title>
     <programlisting role="php">
<![CDATA[
<?php
/* PUT data comes in on the stdin stream */
$putdata = fopen("php://stdin","r");

/* Open a file for writting */
$fp = fopen("myputfile.ext","w");

/* Read the data 1kb at a time
   and write to the file */
while ($data = fread($putdata,1024))
  fwrite($fp,$data);

/* Close the streams */
fclose($fp);
fclose($putdata);
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     All documentation below applies to PHP 3 only.
    </para>
   </note>
   <para>
    PHP provides support for the HTTP PUT method used by clients such
    as Netscape Composer and W3C Amaya.  PUT requests are much simpler
    than a file upload and they look something like this:
    <informalexample>
     <programlisting>
PUT /path/filename.html HTTP/1.1
     </programlisting>
    </informalexample>
   </para>
   <para>
    This would normally mean that the remote client would like to save
    the content that follows as: /path/filename.html in your web tree.
    It is obviously not a good idea for Apache or PHP to automatically
    let everybody overwrite any files in your web tree.  So, to handle
    such a request you have to first tell your web server that you
    want a certain PHP script to handle the request.  In Apache you do
    this with the <emphasis>Script</emphasis> directive.  It can be
    placed almost anywhere in your Apache configuration file.  A
    common place is inside a &lt;Directory&gt; block or perhaps inside
    a &lt;Virtualhost&gt; block.  A line like this would do the trick:
    <informalexample>
     <programlisting>
Script PUT /put.php
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    This tells Apache to send all PUT requests for URIs that match the
    context in which you put this line to the put.php script.  This
    assumes, of course, that you have PHP enabled for the .php
    extension and PHP is active.
   </simpara>
   <simpara>
    Inside your put.php file you would then do something like this:
   </simpara>
   <para>
    <informalexample><programlisting role="php">
<![CDATA[
<?php copy($PHP_UPLOADED_FILE_NAME,$DOCUMENT_ROOT.$REQUEST_URI); ?>
]]>
    </programlisting></informalexample>
   </para>
   <simpara>
    This would copy the file to the location requested by the remote
    client.  You would probably want to perform some checks and/or
    authenticate the user before performing this file copy.  The only
    trick here is that when PHP sees a PUT-method request it stores
    the uploaded file in a temporary file just like those handled but
    the <link
    linkend="features.file-upload.post-method">POST-method</link>.
    When the request ends, this temporary file is deleted.  So, your
    PUT handling PHP script has to copy that file somewhere.  The
    filename of this temporary file is in the $PHP_PUT_FILENAME
    variable, and you can see the suggested destination filename in
    the $REQUEST_URI (may vary on non-Apache web servers).  This
    destination filename is the one that the remote client specified.
    You do not have to listen to this client.  You could, for example,
    copy all uploaded files to a special uploads directory.
   </simpara>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
