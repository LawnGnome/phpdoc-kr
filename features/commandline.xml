<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.23 -->
<chapter id="features.commandline">
 <title>커맨드 라인에서 PHP 사용하기</title>
 <!-- NEW DOCUMENTATION STARTS -->
 <para>
  버전 4.3.0부터 <literal>PHP</literal>는 <emphasis>Command Line Interface</emphasis>를 
  의미하는 <literal>CLI</literal>라는 이름의 새로운 <literal>SAPI</literal> 타입
  (Server Application Programming Interface)을 지원한다.  <literal>SAPI</literal>는 
  이름에서 내포하듯이, 핵심 용도는 셀(또는 데스크탑) 응용프로그램을
  <literal>PHP</literal>로 개발하는것에 맞춰져있다. 이 장에서 설명하는
  <literal>CLI SAPI</literal>와 <literal>SAPI</literal>사이에는 많은 차이가 있다.
  <literal>CLI</literal>와 <literal>CGI</literal>는 많은 부분에 있어서 같은 동작을 
  하지만, 서로 다른 SAPI들이라는 것이다.
 </para>
 <para>
  <literal>CLI SAPI</literal>는 <literal>PHP 4.2.0</literal>에서 처음으로
  릴리즈되었다. 그러나 아직 실험적이었고 <literal>./configure</literal>를
  실행할때 <literal>--enable-cli</literal>을 명시해 주어야 했다.
  PHP 4.3.0 이후부터 <literal>CLI SAPI</literal>는 더이상 실험적이지 않고
  기본값으로 <literal>--enable-cli</literal>가 활성화되어있다.
  그리고 <literal>--disable-cli</literal>로 비활성화시킬수 있다.
 </para>
 <para>
  PHP 4.3.0부터, CLI/CGI 바이너리의 이름과 위치, 존재여부는 PHP가 시스템에
  어떻게 설치되느냐에 따라 달라질 것이다. 기본값으로 <literal>make</literal>를 
  수행할때, CGI와 CLI 모두 빌드되고 각각 <literal>sapi/cgi/php</literal>와 
  <literal>sapi/cli/php</literal>에 위치하게 된다.
  둘 다 <literal>php</literal>라는 이름이 붙는다는것에 주의해야 할것이다.
  configure 줄에 따라 <literal>make install</literal> 시에 무슨일이 일어날까.
  configure 시에 모듈로 SAPI를 선택했다면, 즉 apxs를 사용하거나, 또는
  <literal>--disable-cgi</literal> 옵션을 사용하면 CLI는 
  <literal>make install</literal>시에 <literal>{PREFIX}/bin/php</literal>에 복사된다.
  예를 들면, <literal>--with-apxs</literal>가 configure 줄에 포함되면
  <literal>make install</literal>시에 CLI는 <literal>{PREFIX}/bin/php</literal>에
  복사된다. CGI 바이너리 설치를 오버라이드하고 싶다면 <literal>make install</literal>
  이후에 <literal>make install-cli</literal>를 사용한다.
  차선책으로 configure 줄에 <literal>--disable-cgi</literal>를 설정할수 있다.
 </para>
 <para>
  <note>
   <para>
    <literal>--enable-cli</literal>와 <literal>--enable-cgi</literal>는 모두
    기본값으로 되어있기 때문에, 단순히 configure줄에 <literal>--enable-cli</literal>를
    넣는것이 <literal>make install</literal>시에 <literal>{PREFIX}/bin/php</literal> 에
    CLI를 복사할것이라는 것을 의미하지 않는다.
   </para>
  </note>
 </para>
 <para>
  PHP 4.2.0 과 PHP 4.2.3 사이의 윈도우 패키지는 CLI를 <filename>php-cli.exe</filename>로 
  제공한다. CGI인 <filename>php.exe</filename>와 같은 폴더에 존재한다. 
  PHP 4.3.0부터의 윈도우 패키지는 CLI를 <literal>cli</literal>라는 다른 폴더에 
  <filename>php.exe</filename>파일로 제공한다. 그래서 <literal>cli/php.exe</literal>가 
  된다.
 </para>
 <para>
  <note>
   <title>현재 사용중인 SAPI는 무엇인가?</title>
   <para>
    셀에서, <literal>php -v</literal>를 쳐넣으면 <literal>php</literal>가 
    CGI인지 CLI인지 알수 있을것이다. <function>php_sapi_name</function>과
    상수<constant>PHP_SAPI</constant>도 참고.
   </para>
  </note>
 </para>
 <para>
  <note>
   <para>
    PHP 4.3.2에서 유닉스 <literal>man</literal>ual 페이지가 추가되었다.
    셀 환경에서 <literal>man php</literal>를 쳐넣음으로써 이 페이지를 
    볼수 있을것이다.
   </para>
  </note>
 </para>
 <para>
  다른 <literal>SAPI</literal>와 비교한 <literal>CLI SAPI</literal>의 현저한 차이점:
  <itemizedlist>
   <listitem>
    <para>
     <literal>CGI SAPI</literal>와는 달리, 출력에 헤더를 쓰지 않는다.
    </para>
    <para>
     <literal>CGI SAPI</literal>가 HTTP 헤더를 제거하는 방법을 제공하지만,
     <literal>CLI SAPI</literal>에서는 헤더를 활성화시킬수 있는 스위치(switch)가
     존재하지 않는다.
    </para>
    <para>
     CLI는 기본적으로 정숙모드(quiet mode)로 시작된다. 그러나 
     구버전의 CGI 스크립트와의 호환성을 위해 <literal>-q</literal> 스위치를 
     유지하고 있다.
    </para>
    <para>
     작업 디렉토리가 스크립트의 디렉토리로 변경되지 않는다
     (<literal>-C</literal>스위치는 호환성을 유지됨)
    </para>
    <para>
     일반 텍스트 에러 메시지 (HTML 포맷이 아님)
    </para>
   </listitem>
   <listitem>
    <para>
     셀 환경에 맞지 않는 것들 때문에 <literal>CLI SAPI</literal>에 의해 
     오버로드되는 &php.ini; 지시자(directive)가 몇가지 존재한다.
    </para>
    <para>
     <table>
      <title>&php.ini; 지시자(directive) 오버로드</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>지시자(directive)</entry>
         <entry><literal>CLI SAPI</literal> 기본값</entry>
         <entry>주석</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          셀에서 에러메시지를 읽을때 의미없는 <literal>HTML</literal>태그로
          뒤범벅이 되면 에러메시지를 읽기가 매우 어려울수 있다.
          따라서 이 지시자(directive)의 기본값은 &false;다.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          <function>print</function>, <function>echo</function> 와 비슷한 함수들의
          출력은 모두 즉시 출력으로 쓰기 되고 버퍼에 캐시되지 않는다.
          표준 출력을 지연시키거나 조작하고 싶다면
          <link linkend="ref.outcontrol">output buffering</link>을 사용할수도 있다.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 (unlimited)</entry>
         <entry>
          셀 환경에서 <literal>PHP</literal>를 무한 사용할 가능성때문에,
          maximum execution time은 unlimited로 설정된다. 웹 응용프로그램은
          대부분 매우 빨리 실행이 끝나는 반면에 셀 응용프로그램은 더 많은
          시간이 필요한 경우가 많다.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
          이 설정은 &true;이기 때문에 <literal>CLI SAPI</literal>에서는 항상
          <emphasis>argc</emphasis> (응용프로그램에 전달되는 인자의 수) 와
          <emphasis>argv</emphasis> (응용프로그램에 전단되는 인자의 배열)을
          사용할수 있을것이다.
         </para>
         <para>
          PHP 4.3.0에서부터, <literal>CLI SAPI</literal>는 <literal>PHP</literal>변수 
          <varname>$argc</varname>와 <varname>$argv</varname>가 등록되고 적절한 값으로 
          채워지게 된다. 이 변수의 생성은 <literal>CGI</literal>와 
          <literal>MODULE</literal> 버전과 같이
          <link linkend="ini.register-globals">register_globals</link>가 
          <emphasis>on</emphasis>되어 있어야 한다. 버전이나 register_globals의 
          설정에 관계없이, <link linkend="reserved.variables.server">$_SERVER</link>나 
          <varname>$HTTP_SERVER_VARS</varname>로 그 값에 접근할수 있다.
          Example: <varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      이 지시자(directive)는 설정 파일 &php.ini;나 사용자 설정으로부터 온 다른 값으로
      초기화될수 없다. 모든 설정 파일이 해석되고 난 후에 기본값이 적용되기 때문에
      이 것은 제한이 된다. 하지만, 각 값은 런타임동안에 변경될수 있다.
      (위 지시자(directive) 중 환경과 맞지 않는것
      e.g. <link linkend="ini.register-argc-argv">register_argc_argv</link>).
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     셀 환경에서의 작업을 편하게 하기 위해, 다음 상수가 정의되었다:
     <table>
      <title>CLI 전용 상수</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>상수</entry>
         <entry>설명</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
         <literal>stdin</literal>에 이미 열려진 스트림. 이 상수는 다음처럼
         여는것을 간단하게 해준다.
         <programlisting role="php">
<![CDATA[
$stdin = fopen('php://stdin', 'r');
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry>
         <literal>stdout</literal>에 이미 열려진 스트림. 이 상수는 다음처럼
         여는것을 간단하게 해준다.
         <programlisting role="php">
<![CDATA[
$stdout = fopen('php://stdout', 'w');
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
         <literal>stderr</literal>에 이미 열려진 스트림. 이 상수는 다음처럼
         여는것을 간단하게 해준다.
         <programlisting role="php">
<![CDATA[
$stderr = fopen('php://stderr', 'w');
]]>
         </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     위에서 설명한대로 예를 들면 <literal>stderr</literal>에 대한 스트림을
     직업 열필요가 없다. 스트림 자원 대신 단순하게 상수를 사용하면 된다.
     <programlisting role="php">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
     이 스트림을 명시적으로 닫을 필요가 없다. 스크립트가 끝날때 
     <literal>PHP</literal>에 의해 자동적으로 닫히기 때문이다.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>CLI SAPI</literal>는 현재 디렉토리를 실행중인 스크립트의 디렉토리로
     변경 하지<emphasis role="strong">않는다</emphasis>!
    </para>
    <para>
     다음예는 <literal>CGI SAPI</literal>와의 차이점을 보여준다:
     <programlisting role="php">
<![CDATA[
<?php
    /* Our simple test application named test.php*/
    echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
     <literal>CGI</literal> 버전을 사용할때, 출력은:
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -q another_directory/test.php
/tmp/another_directory
]]>
     </screen>
     이 예제코드는 <literal>PHP</literal>가 현재 디렉토리를 실행스크립트의
     디렉토리로 변경하는것을 보여준다.
    </para>
    <para>
     <literal>CLI SAPI</literal>를 사용할때는 다음과 같다:
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
     </screen>
     이것은 <literal>PHP</literal>에서 셀 툴을 제작할때 좀더 많은
     유연성을 허용한다.
    </para>
    <note>
     <para>
      <literal>CGI SAPI</literal> 는 커맨드 라인에서 실행할때
      <literal>-C</literal> 스위치를 사용하여 <literal>CLI SAPI</literal>의
      동작을 지원한다.
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  <literal>PHP</literal> 바이너리에 의해 제공되는 커맨드 라인 옵션의 리스트는
  <literal>PHP</literal>를 <literal>-h</literal>스위치와 함게 실행하므로써
  어느때든 질의를 할수 있다.
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Display colour syntax highlighted source.
  -w               Display source with stripped comments and whitespace.
  -f <file>        Parse <file>.
  -v               Version number
  -c <path>|<file> Look for php.ini file in this directory
  -a               Run interactively
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -z <file>        Load Zend extension <file>.
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -i               PHP information
  -r <code>        Run PHP <code> without using script tags <?..?>
  -h               This help

  args...          Arguments passed to script. Use -- args when first argument 
                   starts with - or script is read from stdin
]]>
  </screen>
 </para>
 <para>
  <literal>CLI SAPI</literal>는 실행하고자 하는 <literal>PHP</literal>코드를
  취하는 3가지의 방법을 사용한다.
  <orderedlist>
   <listitem>
    <para>
     <literal>PHP</literal>에게 특정 파일을 실행하도록 지정함.
    </para>
    <para>
     <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
     </screen>
     두 방법 (<literal>-f</literal> 스위치를 사용하거나 안하는것)은 모두
     <filename>my_script.php</filename>을 실행한다. 실행하고자하는 파일을
     선택할수 있다 - <literal>PHP</literal> 스크립트는 <filename>.php</filename>확장자
     로 끝날필요없이 어떤 이름이나 원하는 확장자를 갖을수 있다.
    </para>
   </listitem>
   <listitem>
    <para>
     커맨드 라인에서 실행하고자 하는 <literal>PHP</literal> 코드를 직접 전달함.
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
     셀 변수 변환과 따옴표 사용에 있어서 특별한 주의가 필요하다.
    </para>
    <note>
     <para>
      예제 코드를 주의깊에 읽으면, 시작과 끝 태그가 존재하지 않는다!
      <literal>-r</literal> 스위치는 그 태그들이 필요하지 않다.
      그 태그들을 사용하면 해석 에러가 발생할것이다.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     표준 입력(<literal>stdin</literal>)을 통해 수행되는 
     <literal>PHP</literal> 코드를 제공함
    </para>
    <para>
     이 방식은 동적인 <literal>PHP</literal> 코드를 생성할수 있는 
     강력한 기능을 부여하고 바이너리에 그 코드를 넘겨준다. 
     다음 (가상의) 예제코드에서 보여주는 바와 같다.
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
  코드를 수행하기 위한 세 가지 방법의 어떤것도 조합할수 없다.
 </para>
 <para>
  모든 셀 응용 프로그램처럼, <literal>PHP</literal> 바이너리는 많은수의 인자를
  허용하고 <literal>PHP</literal> 스크립트도 인자를 받을수 있다.
  스크립트로 전달할수 있는 인자의 갯수는 <literal>PHP</literal>에 의해 제한받지 않는다.
  (셀은 전달할수 있는 문자 갯수의 제한을 갖는다; 보통 이 제한을 넘지 않을것이다)
  스크립트로 전달할수 있는 인자는 전역 배열 <literal>$argv</literal>에 존재한다. 
  제로 인덱스는 항상 스크립트 명을 포함한다
  (<literal>PHP</literal> 코드가 표준 입력이나 커맨드 라인 스위치
  <literal>-r</literal>로부터 온 경우에는 <literal>-</literal> ).
  두번째로 등록된 전역 변수는 <literal>$argv</literal>배열의 구성요소 수를 갖는
  <literal>$argc</literal>이다 (스크립트로 전달되는 인자의 수가 <emphasis role="strong">아니다</emphasis>)
 </para>
 <para>
  스크립트로 전달하려는 인자가 <literal>-</literal>문자로 시작되지 않는한,
  특별하게 조심할 필요는 없다. <literal>-</literal>로 시작하는 인자를 스크립트에
  전달하면 문제가 발생할 소지가 있다 왜냐하면 <literal>PHP</literal>는 그 인자를
  PHP가 제어해야 한다고 생각하기 때문이다. 이런일이 발생하지 않기 위해서는,
  <literal>--</literal> 구분자의 인자 리스트를 사용한다. 이 구분자가 
  <literal>PHP</literal>에 의해 해석된 후에, 그 뒤의 모든 인자가 스크립트로 온전히
  전달된다.
 </para>
 <para>
  <screen>
<![CDATA[
# This will not execute the given code but will show the PHP usage
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# This will pass the '-h' argument to your script and prevent PHP from showing it's usage
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
  </screen>
 </para>
 <para>
  하지만, 셀 스크립트에서 <literal>PHP</literal>를 사용하는 다른 방법이 있다.
  첫번째 줄을 <literal>#!/usr/bin/php</literal>로 시작하는 스크립트를 작성할수 있다.
  이 줄 뒤에는 <literal>PHP</literal>의 시작과 끝 태그 안에 포함된
  일반적인 <literal>PHP</literal>코드를 놓을수 있다. 이 파일에 적절하게 실행 속성을
  설정하면 (e.g. <literal>chmod +x test</literal>) 스크립트는 보통의 셀이나 펄 스크립트처럼
  실행될수 있다:
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
    var_dump($argv);
?>
]]>
  </programlisting>
  이 파일이 현재 디렉토리에서 <filename>test</filename>라는 이름을 가졌다고
  가정하면 다음과 같이 할수 있다.
  <screen>
<![CDATA[
$ chmod 755 test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
  위와 같은 경우에 <literal>-</literal>로 시작하는 인자를 스크립트로
  전달할때에도 주의할 필요가 없다.
 </para>
 <para>
  <table>
   <title>커맨드 라인 옵션</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>옵션</entry>
      <entry>설명</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-s</entry>
      <entry>
       <para>
        색상으로 문법 강조된 소스를 보임.
       </para>
       <para>
        이 옵션은 파일을 해석하여 <literal>HTML</literal> 강조된 버전을 만드는
        내부적 메카니즘을 사용하여 표준출력에 그것을 쓰도록 한다.
        주의할점은 이 옵션이 하는 일은 <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>블록의
        <literal>HTML</literal> 태그를 생성하고, <literal>HTML</literal> 헤더는 생성하지
        않는다는 것이다. 
       </para>
       <note>
        <para>
         이 옵션은 <literal>-r</literal> 옵션과 함께 사용할수 없다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>
       <para>
        주석과 공백을 제거한 소스를 보임.
       </para>
       <note>
        <para>
         이 옵션은 <literal>-r</literal> 옵션과 함께 사용할수 없다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       <para>
        <literal>-f</literal> 옵션으로 주어진 파일명을 해석하고 실행함.
        이 스위치는 선택적이고 생략가능하다. 파일명만 제공함으로써 실행이 가능하다.
       </para>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       <para>
        PHP, PHP SAPI, Zend 버전을 표준 출력에 출력함, e.g.
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0 (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.3.0, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       <para>
        이 옵션으로 
        &php.ini; 가 위치한 디렉토리를 찾거나 ,
        사용자 정의의 <literal>INI</literal> 파일 디렉토리(&php.ini;라고 이름붙일
        필요가 없다)를 설정할수 있슴. e.g.
        <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-a</entry>
      <entry>
       <para>
        PHP를 대화식으로 실행함.
        <!-- 
        mfischer, 20020510: Couldn't come up with a decent useful description
        of the current implementation of the interactive mode.
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       <para>
        이 옵션은 &php.ini;에서 허용된 설정 지시자(directive)에 대해서 사용자정의 값을
        설정하도록 해줌. 문법은 다음과 같다:
        <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
        </screen>
       </para>
       <para>
        Examples (lines are wrapped for layout reasons):
        <screen>
<![CDATA[
# Omitting the value part will set the given configuration directive to "1"
$ php -d max_execution_time
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Passing an empty value part will set the configuration directive to ""
php -d max_execution_time=
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# The configuration directive will be set to anything passed after the '=' character
$  php -d max_execution_time=20
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
        -d max_execution_time=doesntmakesense
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>
       <para>
        디버거/분석표를 위한 확장 정보를 생성함.
        <!-- 
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>
       <para>
        젠드 확장을 로드함. 파일명만 주어지면, PHP는 시스템의 현재 기본 라이브러리
        경로에서 이 확장을 로드하려고 함(리눅스 시스템에서는 보통
        <filename>/etc/ld.so.conf</filename>로 설정되어 있슴)
        절대 결로 정보를 갖는 파일명을 전달하면 시스템 라이브러리 검색 경로를 사용하지
        않을것이다. 디렉토리 정보를 갖는 상대경로의 파일명은 <literal>PHP</literal>에게
        현재 디렉토리에서 상대경로의 확장만 로드하도록 한다.
       </para>
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       <para>
        이 옵션은 주어진 <literal>PHP</literal>코드의 문법 검사만 수행하게 하는
        편리한 방법을 제공함. 성공하면,
        <literal>No syntax errors detected in &lt;filename&gt;</literal>라는
        메시지가 표준 출력으로 쓰여지고 셀의 리턴 코드는 <literal>0</literal>이다.
        실패하면, 내부적인 해석기 에러와 함께
        <literal>Errors parsing &lt;filename&gt;</literal>라는 메시지가 표준 출력으로
        쓰여지고 셀의 리턴 코드는 <literal>255</literal>가 된다.
       </para>
       <para>
        이 옵션은 치명적인 에러를 발견할수 없을것이다 (undefined functions 같은).
        <literal>-f</literal> 옵션을 사용하면 치명적인 에러도 함께 찾을수 있을것이다.
       </para>
       <note>
        <para>
         이 옵션은 <literal>-r</literal> 옵션과 함께 사용할수 없다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       <para>
        이 옵션을 사용하여, PHP는 내장(로드된)된 PHP 모듈과 Zend 모듈을 출력한다.
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       이 커맨드 라인 옵션은 <function>phpinfo</function>를 호출하고, 결과값을
       출력한다. <literal>PHP</literal>가 정확하게 동작하지 않으면,
       <literal>php -i</literal>를 사용하여 정보 테이블이나 그 테이블 이전에
       어떤 에러 메시지가 출력되는지 보도록 지도될수 있다. 
       출력은 <literal>HTML</literal>내에 존재하고 따라서 꽤 많다는 것에 주의한다.
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>
       <para>
        이 옵션은 커맨드 라인에서 직접 <literal>PHP</literal>를 수행하도록 해줌.
        <literal>PHP</literal>의 시작과 끝 태그
        (<literal>&lt;?php</literal> 과 <literal>?&gt;</literal>)는 
        <emphasis role="strong">필요하지 않다</emphasis>. 만약 존재한다면
        해석 에러가 발생할것이다.
       </para>
       <note>
        <para>
         이런 형태의 <literal>PHP</literal>를 사용할때 셀에 의해 수행되는
         커맨드라인의 변수 치환과 충돌하지 않도록 주의가 필요하다.
        </para>
        <para>
         Example showing a parser error
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
         여기서의 문제점은 sh/bash는 큰따옴표 <literal>"</literal>를 사용할지라도
         변수 치환을 수행한다는것이다. 변수 <literal>$foo</literal>는 정의되지
         않았기 때문에, 실질적인 읽기를 수행하는데 있어서
         <literal>PHP</literal>로 전달되는 코드가 아무것도 없다.
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
         확실한 방법은 작은 따옴표 <literal>'</literal>를 사용하는 것이다.
         작은 따옴표로 둘러싼 문자열안의 변수는 sh/bash에 의해 치환되지 않는다.
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
         sh/bash가 아닌 다른 셀을 사용 중이라면, 좀더 많은 다른 경험을 했을수 있다.
         편하게 버그 보고를 열거나 phpdoc@lists.php.net에 메일을 보내도록 한다.

         아직도 코드내로 셀변수를 취하려고 하거나 회피를 위한 역슬래쉬를 사용해서
         어려움을 격기 쉽다. 분명히 경고했다.  <!-- :-) -->
        </para>
       </note>
       <note>
        <para>
         <literal>-r</literal>는 <emphasis>CLI</emphasis> SAPI에서만 사용가능하다.
         <emphasis>CGI</emphasis> SAPI 에서는 사용할수 없다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       이 옵션으로 커맨드 라인의 실질적인 옵션 리스트에 관한 정보와
       그들이 수행하는 작업에 대한 한줄의 설명을 볼수 있다.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <!-- NEW DOCUMENTATION ENDS -->

 <!-- OLD DOCUMENTED STARTS
  mfischer, 20020510: I've commented out the start paragraphs of the old
  documentation as it is meant to be replaced by the new one.
 <para>
  The command line options of the PHP executable are useful
  if you would like to debug or test your PHP setup, but they
  can also be handy, if you would like to use PHP for a
  different purpose than web scripting.
 </para>
 <para>
  Note, that you can always direct the output of the PHP
  executable to an external file with the &gt; character,
  so <literal>php -q test.php > test.html</literal> will
  print out the output of <filename>test.php</filename>
  without HTTP headers to the <filename>test.html</filename>
  file in the same directory.
 </para>
 <para>
  You can only use these command line options if you have
  the PHP executable. If you built the server module
  version, and you have no CGI version available on your
  machine, than you have no chance to use these options.
  For Windows users both the PHP executable and the server
  modules are in the binary package, the executable is
  named <filename>php.exe</filename>.
 </para>
 <para>
  This list of command line options is consistent with PHP 4.0.6.
  You can get the actual list and some one line descriptions
  with the <literal>-h</literal> option. The output of
  <literal>php -h</literal> should be something like this:
  <screen>
<![CDATA[
Usage: php [-q] [-h] [-s [-v] [-i] [-f <file>] |  {<file> [args...]}
  -q             Quiet-mode.  Suppress HTTP Header output.
  -s             Display colour syntax highlighted source.
  -f <file>      Parse <file>.  Implies `-q'
  -v             Version number
  -C             Do not chdir to the script's directory
  -c <path>      Look for php.ini file in this directory
  -d foo[=bar]   Define INI entry foo with value 'bar'
  -e             Generate extended information for debugger/profiler
  -z <file>      Load Zend extension <file>.
  -l             Syntax check only (lint)
  -m             Show compiled in modules
  -i             PHP information
  -h             This help
]]>
  </screen>
 </para>
 <para>
  Here we list some of the most important command line options
  with detailed explanations.
 </para>
 <para>
  <table>
   <title>Command line options</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-q</entry>
      <entry>
       Suppress HTTP headers output. Normally PHP prints out
       HTTP headers for the calling program (ie. webserver)
       to hand on to the browser. When writing command line
       applications these headers are useless.
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>
       Display the color highlighted source of the file
       given with its name. This is the same as if you were
       printing out the source using the
       <function>highlight_file</function> function in
       a PHP script.
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       Parse the file given, and search for syntactical and
       fatal errors. This option implies -q. Use for
       debugging purposes.
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       By calling PHP with this option, you can ask
       it to print out its version number, ie: 4.0.6. 
      </entry>
     </row>
     <row>
      <entry>-C</entry>
      <entry>
       Normally PHP changes the working directory to the
       running scripts directory. This makes it possible
       for example, to open files in the same directory,
       with only specifying the name of the file. If you
       would like to disable this directory change, use
       this option.
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       Using this option, you can specify an alternative
       &php.ini; path, so PHP will
       search your configurations file in this path
       instead of the default one.
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       With this option, you can set individual 
       &php.ini; settings in the
       time of running a script.
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       Check the file given for syntax errors. This
       option implies -q. Use for debugging purposes.
       This option won't find fatal errors (like undefined
       functions). Use -f if you would like to test
       for fatal errors too.
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       Using this option, PHP prints out the built in
       (and loaded) PHP and Zend modules, the PHP
       and Zend version numbers, and a short Zend
       copyright notice.
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       This command line option calls
       <function>phpinfo</function>, and prints
       out the results. If PHP is not working well,
       it is advisable to make a <literal>php -i</literal>
       and see if any error messages are printed out
       before or in place of the information tables.
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       With this option, you can get information about
       the actual list of command line options and some
       one line descriptions about what they do.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 -->
 <para>
  PHP 실행 파일은 웹서버와 절대적으로 독립적인 PHP 스크립트를 실행하기 위해
  사용될수 있다. 유닉스 시스템에 있다면, PHP 스크립트의 첫번째 줄에 특별한
  것을 추가해야 하고, 실행가능하게 해서, 무슨 프로그램이 스크립트를 수행시킬지
  시스템이 알수 있도록 한다. 윈도우 플랫폼에서는
  <literal>.php</literal>파일의 더블 클릭 옵션을 갖는 <literal>php.exe</literal>와
  연관시킬수 있거나, PHP를 통해 그 스크립트를 수행하도록 배치 파일을 만들수 있다.
  유닉스에서 실행시키기위해 추가된 첫번째 줄은 윈도우에 아무런 해가 없을것이다.
  그래서 이 방법을 사용하여 플랫폼 프로그램을 번갈아 작성할수 있다.
  커맨드 라인 PHP 프로그램을 작성하는 단순한 에제 코드를 아래에서 볼수 있다.
 </para>
 <para>
  <example>
   <title>커맨드 라인에서 실행되도록 의도된 스크립트(script.php)</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

This is a command line PHP script with one option.

  Usage:
  <?php echo $argv[0]; ?> <option>

  <option> can be some word you would like
  to print out. With the --help, -help, -h,
  or -? options, you can get this help.

<?php
} else {
    echo $argv[1];
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  위 스크립트에서, 특별한 첫번째 줄을 사용하여 이 파일이 PHP에 의해
  실행되어야 한다는 것을 가리킨다. CLI 버전을 사용한다면, HTTP 헤더가
  존재하지 않을것이다. PHP 의 커맨드라인 응용프로그램을 작성할때 사용할수
  있는 두개의 변수가 존재한다:<varname>$argc</varname>와 <varname>$argv</varname>.
  첫번째 변수는 인자 갯수에 하나(스크립트명)가 추가된 값이다.
  두번째 변수는 인자들를 포함하는 배열인데, 이 배열은 제로 (<varname>$argv[0]</varname>)에
  스크립트명을 갖으면 시작된다.
 </para>
 <para>
  위 프로그램에서는 인자가 하나 이하인가 이상인가를 체크한다.
  인자가 <literal>--help</literal>나,
  <literal>-help</literal>, <literal>-h</literal>, <literal>-?</literal>이면,
  help 메시지르 출력하고, 스크립트명을 동적으로 출력한다.
  다른 인자를 받게 되면, 그 인자를 출력한다.
 </para>
 <para>
  유닉스에서 위 스크립트를 수행하려 하면, 그 파일을 실행가능하게 해서 단순히
  <literal>script.php echothis</literal> 나 <literal>script.php -h</literal>를
  호출하면 된다. 윈도우에서는, 이 작업을 위해 배치 파일을 만들수 있다. 
 </para>
 <para>
  <example>
   <title>커맨드 라인의 PHP 스크립트를 수행하기 위한 배치 파일(script.bat)</title>
   <programlisting role="shell">
@c:\php\cli\php.exe script.php %1 %2 %3 %4
   </programlisting>
  </example>
 </para>
 <para>
  위 프로그램이 <filename>script.php</filename>이란 이름을 갖고,
  <filename>c:\php\cli\php.exe</filename> 안에 CLI <filename>php.exe</filename>를
  갖는다면 이 배치 파일은 추가된 옵션과 함께 실행이 될것이다:
  <literal>script.bat echothis</literal> 나
  <literal>script.bat -h</literal>.
 </para>
 <para>
  PHP의 커맨드 라인 응용 프로그램의 기능을 확장하기 위한 좀더 많은 함수를 보기위해
  <link linkend="ref.readline">Readline</link> 확장에 대한 문서도 참고한다.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
