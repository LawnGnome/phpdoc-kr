<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.56 Maintainer: progcom Status: ready -->
<!-- CREDITS: fuzzy74 -->
<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook"
 xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>명령줄에서 PHP 사용하기</title>
 <para>
  버전 4.3.0부터 PHP는 <emphasis>Command Line Interface</emphasis>를 
  의미하는 <literal>CLI</literal>라는 이름의 새로운
  <literal>SAPI</literal>(Server Application Programming Interface) 형식을
  지원한다. 이 <literal>SAPI</literal>는 
  이름에서 내포하듯이, 핵심 용도는 셀(또는 데스크탑) 응용프로그램을
  PHP로 개발하는것에 맞춰져있다. 이 장에서 설명하는
  <literal>CLI SAPI</literal>와 <literal>SAPI</literal>사이에는 많은 차이가 있다.
  <literal>CLI</literal>와 <literal>CGI</literal>는 많은 부분에 있어서 같은 동작을 
  하지만, 서로 다른 SAPI들이라는 것이다.
 </para>
 <para>
  <literal>CLI SAPI</literal>는 PHP 4.2.0에서 처음으로
  릴리즈되었다. 그러나 아직 실험적이었고 <command>./configure</command>를
  실행할때 <option role="configure">--enable-cli</option>을 명시해 주어야 했다.
  PHP 4.3.0부터 <literal>CLI SAPI</literal>는 더이상 실험적이지 않고
  기본값으로 <option role="configure">--enable-cli</option>가 활성화되어있다.
  그리고 <option role="configure">--disable-cli</option>로 비활성화시킬수 있다.
 </para>
 <para>
  PHP 4.3.0부터, CLI/CGI 바이너리의 이름과 위치, 존재여부는 PHP가 시스템에
  어떻게 설치되느냐에 따라 달라질 것이다. 기본값으로 <command>make</command>를 
  수행할때, CGI와 CLI 모두 빌드되고 각각 <filename>sapi/cgi/php</filename>와 
  <filename>sapi/cli/php</filename>에 위치하게 된다.
  둘 다 php라는 이름이 붙는다는것에 주의해야 할것이다.
  configure 줄에 따라 <command>make install</command> 시에 무슨일이 일어날까.
  configure 시에 모듈로 SAPI를 선택했다면, 즉 apxs를 사용하거나, 또는
  <option role="configure">--disable-cgi</option> 옵션을 사용하면 CLI는 
  <command>make install</command>시에 <filename>{PREFIX}/bin/php</filename>에 복사된다.
  예를 들면, <option role="configure">--with-apxs</option>가 configure 줄에 포함되면
  <command>make install</command>시에 CLI는
  <filename>{PREFIX}/bin/php</filename>에
  복사된다. CGI 바이너리 설치를 오버라이드하고 싶다면 <command>make
   install</command>
  이후에 <command>make install-cli</command>를 사용한다.
  차선책으로 configure 줄에 <option role="configure">--disable-cgi</option>를 설정할수 있다.
 </para>
 <note>
  <para>
   <option role="configure">--enable-cli</option>와 <option
    role="configure">--enable-cgi</option>는 모두
   기본값으로 켜져 있기 때문에, 단순히 configure줄에 <option
    role="configure">--enable-cli</option>를
   넣는것이 <command>make install</command>시에
   <filename>{PREFIX}/bin/php</filename>에
   CLI를 복사할것이라는 것을 의미하지 않는다.
  </para>
 </note>
 <para>
  PHP 4.2.0 과 PHP 4.2.3 사이의 윈도우 패키지는 CLI를 <filename>php-cli.exe</filename>로 
  제공한다. CGI인 <filename>php.exe</filename>와 같은 폴더에 존재한다. 
  PHP 4.3.0부터 윈도우 패키지 배포판은 CLI를 별개의 폴더 <filename
   class="directory">cli</filename>에 <filename>php.exe</filename>를 놓으므로,
  <filename>cli/php.exe</filename>가 됩니다. PHP 5부터, CLI는 메인 폴더에
  <filename>php.exe</filename>로 배포됩니다. CGI 버전은
  <filename>php-cgi.exe</filename>로 배포됩니다.
 </para>
 <para>
  PHP 5부터, 새로운 <filename>php-win.exe</filename> 파일이 배포됩니다. 이는
  CLI 버전과 동일하지만, php-win은 아무것도 출력하지 않으므로, 콘솔을 제공하지
  않습니다. (화면에 "도스 박스"가 나타나지 않습니다) 이 동작은 php-gtk와
  비슷합니다. <option role="configure">--enable-cli-win32</option>로
  configure해야 합니다.
 </para>
 <note>
  <title>현재 사용중인 SAPI는 무엇인가?</title>
  <para>
   셀에서, <command>php -v</command>를 쳐넣으면 <filename>php</filename>가 
   CGI인지 CLI인지 알수 있을것이다. <function>php_sapi_name</function>과
   상수<constant>PHP_SAPI</constant>도 참고.
  </para>
 </note>
 <note>
  <para>
   PHP 4.3.2에서 유닉스 <literal>man</literal>ual 페이지가 추가되었다.
   셀 환경에서 <command>man php</command>를 침으로써 이 페이지를 
   볼수 있을것이다.
  </para>
 </note>
 <para>
  다른 <literal>SAPI</literal>와 비교한 <literal>CLI SAPI</literal>의 현저한 차이점:
  <itemizedlist>
   <listitem>
    <para>
     <literal>CGI SAPI</literal>와는 달리, 출력에 헤더를 쓰지 않는다.
    </para>
    <para>
     <literal>CGI SAPI</literal>가 HTTP 헤더를 제거하는 방법을 제공하지만,
     <literal>CLI SAPI</literal>에서는 헤더를 활성화시킬수 있는 스위치가
     존재하지 않는다.
    </para>
    <para>
     CLI는 기본적으로 정숙 모드로 시작된다. 그러나 
     구버전의 CGI 스크립트와의 호환성을 위해 <option>-q</option> 스위치를 
     유지하고 있다.
    </para>
    <para>
     작업 디렉토리가 스크립트의 디렉토리로 변경되지 않는다
     (<option>-C</option>와 <option>--no-chdir</option> 스위치는 호환성을
     유지됩니다)
    </para>
    <para>
     일반 텍스트 에러 메시지 (HTML 포맷이 아님)
    </para>
   </listitem>
   <listitem>
    <para>
     셀 환경에 맞지 않는 것들 때문에 <literal>CLI SAPI</literal>에 의해 
     오버로드되는 &php.ini; 지시어가 몇가지 존재한다.
    </para>
    <para>
     <table>
      <title>&php.ini; 지시어 오버로드</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>지시어</entry>
         <entry><literal>CLI SAPI</literal> 기본값</entry>
         <entry>주석</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          셀에서 에러메시지를 읽을때 의미없는 <literal>HTML</literal>태그로
          뒤범벅이 되면 에러메시지를 읽기가 매우 어려울수 있다.
          따라서 이 지시어의 기본값은 &false;다.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          <function>print</function>, <function>echo</function> 와 비슷한 함수들의
          출력은 모두 즉시 출력으로 쓰기 되고 버퍼에 캐시되지 않는다.
          표준 출력을 지연시키거나 조작하고 싶다면
          <link linkend="ref.outcontrol">output buffering</link>을 사용할수도 있다.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 (무제한)</entry>
         <entry>
          셀 환경에서 PHP를 무한하게 사용할 가능성때문에,
          최대 실행 시간은 무제한으로 설정된다. 웹 응용프로그램은
          대부분 매우 빨리 실행이 끝나는 반면에 셀 응용프로그램은 더 많은
          시간이 필요한 경우가 많다.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
          이 설정은 &true;이기 때문에 <literal>CLI SAPI</literal>에서는 항상
          <emphasis>argc</emphasis> (응용프로그램에 전달되는 인수의 수) 와
          <emphasis>argv</emphasis> (응용프로그램에 전단되는 인수의 배열)을
          사용할수 있을것이다.
         </para>
         <para>
          PHP 4.3.0부터, <literal>CLI SAPI</literal>는 PHP 변수 
          <varname>$argc</varname>와 <varname>$argv</varname>가 등록되고 적절한 값으로 
          채워지게 된다. 이 변수의 생성은 <literal>CGI</literal>와 
          <literal>MODULE</literal> 버전과 같이
          <link linkend="ini.register-globals">register_globals</link>가 
          <emphasis>on</emphasis>되어 있어야 한다. 버전이나 register_globals의 
          설정에 관계없이, <varname>$_SERVER</varname>나 
          <varname>$HTTP_SERVER_VARS</varname>로 그 값에 접근할수 있다.
          Example: <varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      이 지시어는 설정 파일 &php.ini;나 사용자 설정으로부터 온 다른 값으로
      초기화될수 없다. 모든 설정 파일이 해석되고 난 후에 기본값이 적용되기 때문에
      이 것은 제한이 된다. 하지만, 각 값은 런타임동안에 변경될수 있다.
      (위 지시어 중 환경과 맞지 않는것
      e.g. <link linkend="ini.register-argc-argv">register_argc_argv</link>).
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     셀 환경에서의 작업을 편하게 하기 위해, 다음 상수가 정의되었다:
     <table>
      <title>CLI 전용 상수</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>상수</entry>
         <entry>설명</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
          <para><literal>stdin</literal>에 이미 열려진 스트림. 이 상수는 다음처럼
         여는것을 간단하게 해준다.
         <programlisting role="php">
<![CDATA[
<?php

$stdin = fopen('php://stdin', 'r');

?>
]]>
         </programlisting>
         <literal>stdin</literal>에서 한 줄을 읽으려면, 다음처럼 할 수
         있습니다.
         <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // STDIN에서 한 줄을 읽습니다
fscanf(STDIN, "%d\n", $number); // STDIN에서 수를 읽습니다
?>
]]>
         </programlisting>
         </para></entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry><para>
         <literal>stdout</literal>에 이미 열려진 스트림. 이 상수는 다음처럼
         여는것을 간단하게 해준다.
         <programlisting role="php">
<![CDATA[
<?php

$stdout = fopen('php://stdout', 'w');

?>
]]>
         </programlisting>
         </para></entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
          <para>
           <literal>stderr</literal>에 이미 열려진 스트림. 이 상수는 다음처럼
           여는것을 간단하게 해준다.
           <programlisting role="php">
<![CDATA[
<?php

$stderr = fopen('php://stderr', 'w');

?>
]]>
           </programlisting>
          </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     위에서 설명한대로 예를 들면 <literal>stderr</literal>에 대한 스트림을
     직업 열필요가 없다. 스트림 자원 대신 단순하게 상수를 사용하면 된다.
     <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
     이 스트림을 명시적으로 닫을 필요가 없다. 스크립트가 끝날때 
     PHP에 의해 자동적으로 닫히기 때문이다.
    </para>
    <note>
     <para>
      이 상수들은 PHP 스크립트를 <literal>stdin</literal>에서 읽을 경우에는
      사용할 수 없습니다.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     <literal>CLI SAPI</literal>는 현재 디렉토리를 실행중인 스크립트의 디렉토리로
     변경 하지<emphasis role="strong">않는다</emphasis>!
    </para>
    <informalexample>
     <para>
      다음예는 <literal>CGI SAPI</literal>와의 차이점을 보여준다:
     </para>
     <programlisting role="php">
<![CDATA[
<?php
// Our simple test application named test.php
echo getcwd(), "\n";
?>
]]>
     </programlisting>
     <para>
      <literal>CGI</literal> 버전을 사용할때, 출력은:
     </para>
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -q another_directory/test.php
/tmp/another_directory
]]>
     </screen>
     <para>
      이 예제코드는 PHP가 현재 디렉토리를 실행스크립트의
      디렉토리로 변경하는것을 보여준다.
     </para>
     <para>
      <literal>CLI SAPI</literal>를 사용할때는 다음과 같다:
     </para>
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
     </screen>
     <para>
      이것은 PHP에서 셀 툴을 제작할때 좀더 많은
      유연성을 허용한다.
     </para>
    </informalexample>
    <note>
     <para>
      <literal>CGI SAPI</literal> 는 명령줄에서 실행할때
      <option>-C</option> 스위치를 사용하여 <literal>CLI SAPI</literal>의
      동작을 지원한다.
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  PHP 바이너리에 의해 제공되는 명령줄 옵션의 리스트는
  PHP를 <option>-h</option> 스위치와 함께 실행하므로써
  어느때든 질의를 할수 있다.
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [--] [args...]
       php [options] -r <code> [--] [args...]
       php [options] [-B <begin_code>] -R <code> [-E <end_code>] [--] [args...]
       php [options] [-B <begin_code>] -F <file> [-E <end_code>] [--] [args...]
       php [options] -- [args...]
       php [options] -a

  -a               Run interactively
  -c <path>|<file> Look for php.ini file in this directory
  -n               No php.ini file will be used
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -f <file>        Parse and execute <file>.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r <code>        Run PHP <code> without using script tags <?..?>
  -B <begin_code>  Run PHP <begin_code> before processing input lines
  -R <code>        Run PHP <code> for every input line
  -F <file>        Parse and execute <file> for every input line
  -B <begin_code>  Run PHP <end_code> after processing all input lines
  -H               Hide any passed arguments from external tools.
  -s               Display colour syntax highlighted source.
  -v               Version number
  -w               Display source with stripped comments and whitespace.
  -z <file>        Load Zend extension <file>.

  args...          Arguments passed to script. Use -- args when first argument 
                   starts with - or script is read from stdin

  --ini            Show configuration file names

  --rf <name>      Show information about function <name>.
  --rc <name>      Show information about class <name>.
  --re <name>      Show information about extension <name>.
  --ri <name>      Show configuration for extension <name>.
]]>
  </screen>
 </para>
 <para>
  <literal>CLI SAPI</literal>는 실행하고자 하는 PHP 코드를
  취하는 3가지의 방법을 사용한다.
  <orderedlist>
   <listitem>
    <para>
     PHP에게 특정 파일을 실행하도록 지정함.
    </para>
    <informalexample>
     <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
     </screen>
    </informalexample>
    <para>
     두 방법 (<option>-f</option> 스위치를 사용하거나 안하는것)은 모두
     <filename>my_script.php</filename>을 실행한다. 실행하고자하는 파일을
     선택할수 있다 - PHP 스크립트는 <literal>.php</literal> 확장자
     로 끝날필요없이 어떤 이름이나 원하는 확장자를 갖을수 있다.
    </para>
    <note>
     <para>
      스크립트에 인수를 전달해야 할 때, <option>-f</option> 스위치를 사용할
      경우 <literal>--</literal>을 첫번째 인수로 전달해야 합니다.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     명령줄에서 실행하고자 하는 PHP 코드를 직접 전달함.
    </para>
    <informalexample>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
    </informalexample>
    <para>
     셀 변수 변환과 따옴표 사용에 있어서 특별한 주의가 필요하다.
    </para>
    <note>
     <para>
      예제 코드를 주의깊게 읽으면, 시작과 끝 태그가 존재하지 않는다!
      <option>-r</option> 스위치는 그 태그들이 필요하지 않다.
      그 태그들을 사용하면 해석 에러가 발생할것이다.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     표준 입력(<literal>stdin</literal>)을 통해 수행되는 
     PHP 코드를 제공함
    </para>
    <para>
     이 방식은 동적인 PHP 코드를 생성할수 있는 
     강력한 기능을 부여하고 바이너리에 그 코드를 넘겨준다. 
     다음 (가상의) 예제코드에서 보여주는 바와 같다.
    </para>
    <informalexample>
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </informalexample>
   </listitem>
  </orderedlist>
  코드를 수행하기 위한 세 가지 방법의 어떤것도 조합할수 없다.
 </para>
 <para>
  모든 셀 응용 프로그램처럼, PHP 바이너리는 많은수의 인수를
  허용하고 PHP 스크립트도 인수를 받을수 있다.
  스크립트로 전달할수 있는 인수의 갯수는 PHP에 의해 제한받지 않는다.
  (셀은 전달할수 있는 문자 갯수의 제한을 갖는다; 보통 이 제한을 넘지 않을것이다)
  스크립트로 전달할수 있는 인수는 전역 배열 <varname>$argv</varname>에 존재한다. 
  제로 인덱스는 항상 스크립트 명을 포함한다
  (PHP 코드가 표준 입력이나 명령줄 스위치
  <option>-r</option>로부터 온 경우에는 <literal>-</literal> ).
  두번째로 등록된 전역 변수는 <varname>$argv</varname>배열의 구성요소 수를 갖는
  <varname>$argc</varname>이다 (스크립트로 전달되는 인수의 수가 <emphasis role="strong">아니다</emphasis>)
 </para>
 <para>
  스크립트로 전달하려는 인수가 <literal>-</literal>문자로 시작되지 않는한,
  특별하게 조심할 필요는 없다. <literal>-</literal>로 시작하는 인수를 스크립트에
  전달하면 문제가 발생할 소지가 있다 왜냐하면 PHP는 그 인수를
  PHP가 제어해야 한다고 생각하기 때문이다. 이런일이 발생하지 않기 위해서는,
  <literal>--</literal> 구분자의 인수 리스트를 사용한다. 이 구분자가 
  PHP에 의해 해석된 후에, 그 뒤의 모든 인수가 스크립트로 온전히
  전달된다.
 </para>
 <informalexample>
  <screen>
<![CDATA[
# This will not execute the given code but will show the PHP usage
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# This will pass the '-h' argument to your script and prevent PHP from showing it's usage
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
  </screen>
 </informalexample>
 <para>
  하지만, 셀 스크립트에서 PHP를 사용하는 다른 방법이 있다.
  첫번째 줄을 <literal>#!/usr/bin/php</literal>로 시작하는 스크립트를 작성할수 있다.
  이 줄 뒤에는 PHP의 시작과 끝 태그 안에 포함된
  일반적인 PHP 코드를 놓을수 있다. 이 파일에 적절하게 실행 속성을
  설정하면 (e.g. <command>chmod +x test</command>) 스크립트는 보통의 셀이나 펄 스크립트처럼
  실행될수 있다:
 </para>
 <example>
  <title>PHP 스크립트를 쉘 스크립트처럼 실행하기</title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
  </programlisting>
  <para>
   이 파일이 현재 디렉토리에서 <filename>test</filename>라는 이름을 가졌다고
   가정하면 다음과 같이 할수 있다.
  </para>
  <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
 </example>
 <para>
  위와 같은 경우에 <literal>-</literal>로 시작하는 인수를 스크립트로
  전달할때에도 주의할 필요가 없다.
 </para>
 <para>
  긴 옵션은 PHP 4.3.3부터 사용할 수 있습니다.
  <table>
   <title>명령줄 옵션</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>옵션</entry>
      <entry>긴 옵션</entry>
      <entry>설명</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-a</entry>
      <entry>--interactive</entry>
      <entry>
       <para>
        PHP를 대화적으로 실행합니다. PHP를 <link
         linkend="ref.readline">Readline</link> 확장과 함께
        컴파일했다면(윈도우에서는 불가능), 자동 완성 기능(예. 변수명의 시작
        부분을 치고 TAB을 누르면 PHP가 이름을 완성해줍니다)과 화살표 키로
        사용할 수 있는 타이핑 기록을 가진 멋진 쉘을 가지게 됩니다. 기록은
        <filename>~/.php_history</filename> 파일에 저장됩니다.
       </para>
       <note>
        <para>
         <link linkend="ini.auto-prepend-file">auto_prepend_file</link>과
         <link linkend="ini.auto-append-file">auto_append_file</link>은 이
         모드에서 해석되지만 약간의 제한이 존재합니다 - 예. 함수는 호출하기
         전에 정의되어야 합니다.
        </para>
       </note>
       <note>
        <para>
         PHP를 CLI 대화 모드로 사용할 때, <link
          linkend="language.oop5.autoload">자동 적재</link>를 사용할 수
         없습니다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>--php-ini</entry>
      <entry>
       <para>
        이 옵션으로 &php.ini;를 찾을 디렉토리를 지정하거나, 사용자
        <literal>INI</literal> 파일(&php.ini;라는 이름을 가질 필요는
        없습니다)을 지정할 수 있습니다. 예를 들면:
       </para>
       <para><informalexample>
        <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
        </screen>
       </informalexample></para>
       <para>
        이 옵션을 지정하지 않으면, 파일을 <link
         linkend="configuration.file">기본 위치</link>에서 찾습니다.
       </para>
      </entry>
     </row>
     <row>
      <entry>-n</entry>
      <entry>--no-php-ini</entry>
      <entry>
       <para>
        &php.ini;를 무시합니다. 이 스위치는 PHP 4.3.0부터 사용할 수 있습니다.
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>--define</entry>
      <entry>
       <para>
        이 옵션은 &php.ini;에서 허용된 설정 지시어에 대해서 사용자정의 값을
        설정하도록 해줌. 문법은 다음과 같다:
        <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
        </screen>
       </para>
       <para><informalexample>
        <para>
         예제 (표시 관계로 줄바꿈을 하였습니다):
        </para>
        <screen>
<![CDATA[
# Omitting the value part will set the given configuration directive to "1"
$ php -d max_execution_time
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Passing an empty value part will set the configuration directive to ""
php -d max_execution_time=
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# The configuration directive will be set to anything passed after the '=' character
$  php -d max_execution_time=20
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
        -d max_execution_time=doesntmakesense
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
        </screen>
       </informalexample></para>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>--profile-info</entry>
      <entry>
       <para>
        디버거/프로파일러에서 사용할 수 있는 확장 정보 모드를 켭니다.
       </para>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>--file</entry>
      <entry>
       <para>
        <option>-f</option> 옵션으로 주어진 파일명을 해석하여 실행합니다. 이
        스위치는 선택적으로 생략할 수 있습니다. 단지 실행할 파일명만 제공해도
        됩니다.
       </para>
       <note>
        <para>
         스크립트에 인수를 전달할 때, 첫번째 인수는
         <literal>--</literal>이여야 합니다. 그렇지 않으면 PHP는 그들을 PHP
         옵션으로 해석합니다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h 와 -?</entry>
      <entry>--help 와 --usage</entry>
      <entry>
       이 옵션으로, 실제 명령줄 옵션 목록과 작동에 관한 한 줄 설명에 대한
       정보를 얻을 수 있습니다.
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>--info</entry>
      <entry>
       이 명령줄 옵션은 <function>phpinfo</function>를 호출하여, 그 결과를
       출력합니다. PHP가 제대로 작동하지 않으면, <command>php -i</command>를
       사용하여 어떠한 오류 메세지가 시작시나 정보표에 나오는지 확인할 수
       있습니다. CGI 모드를 사용하면 출력은 <literal>HTML</literal>이고 매우
       큰 점에 주의하십시오.
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>--syntax-check</entry>
      <entry>
       <para>
        이 옵션은 주어진 PHP 코드의 문법 검사만 수행하게 하는
        편리한 방법을 제공함. 성공하면,
        <literal>No syntax errors detected in &lt;filename&gt;</literal>라는
        메시지가 표준 출력으로 쓰여지고 셀의 리턴 코드는 <literal>0</literal>이다.
        실패하면, 내부적인 해석기 에러와 함께
        <literal>Errors parsing &lt;filename&gt;</literal>라는 메시지가 표준 출력으로
        쓰여지고 셀의 리턴 코드는 <literal>-1</literal>이 된다.
       </para>
       <para>
        이 옵션은 치명적인 에러를 발견할수 없을것이다 (undefined functions 같은).
        <option>-f</option> 옵션을 사용하면 치명적인 에러도 함께 찾을수 있을것이다.
       </para>
       <note>
        <para>
         이 옵션은 <option>-r</option> 옵션과 함께 사용할수 없다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>--modules</entry>
      <entry>
       <para><informalexample>
        <para>
         이 옵션을 사용하여, PHP는 내장(로드된)된 PHP 모듈과 Zend 모듈을 출력한다.
        </para>
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </informalexample></para>
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>--run</entry>
      <entry>
       <para>
        이 옵션은 명령줄에서 직접 PHP를 수행하도록 해줌.
        PHP의 시작과 끝 태그
        (<literal>&lt;?php</literal> 과 <literal>?&gt;</literal>)는 
        <emphasis role="strong">필요하지 않다</emphasis>. 만약 존재한다면
        해석 에러가 발생할것이다.
       </para>
       <note>
        <para>
         이런 형태의 PHP를 사용할때 셀에 의해 수행되는
         커맨드라인의 변수 치환과 충돌하지 않도록 주의가 필요하다.
        </para>
        <informalexample>
         <para>
          해석 오류를 보여주는 예제
         </para>
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
        </informalexample>
        <para>
         여기서의 문제점은 sh/bash는 큰따옴표 <literal>"</literal>를 사용할지라도
         변수 치환을 수행한다는것이다. 변수 <varname>$foo</varname>는 정의되지
         않았기 때문에, 실질적인 읽기를 수행하는데 있어서
         PHP로 전달되는 코드가 아무것도 없다:
        </para>
        <informalexample>
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
         <para>
         확실한 방법은 작은 따옴표 <literal>'</literal>를 사용하는 것이다.
         작은 따옴표로 둘러싼 문자열안의 변수는 sh/bash에 의해 치환되지 않는다.
         </para>
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
        </informalexample>
        <para>
         sh/bash가 아닌 다른 셀을 사용 중이라면, 좀더 많은 다른 경험을 했을수 있다.
         <link xlink:href="&url.php.bugs;">&url.php.bugs;</link>에서 버그
         보고를 하시면 됩니다. 
         아직도 코드내로 셀변수를 취하려고 하거나 회피를 위한 역슬래쉬를 사용해서
         어려움을 격기 쉽다. 분명히 경고했다.
        </para>
       </note>
       <note>
        <para>
         <option>-r</option>는 <emphasis>CLI</emphasis> SAPI에서만 사용가능하다.
         <emphasis>CGI</emphasis> SAPI 에서는 사용할수 없다.
        </para>
       </note>
       <note>
        <para>
         이 옵션은 매우 기본적인 기능을 의미합니다. 그러므로 몇몇 설정
         지시어(예. <link
          linkend="ini.auto-prepend-file">auto_prepend_file</link>과 <link
          linkend="ini.auto-append-file">auto_append_file</link>)는 이
         모드에서 무시됩니다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-B</entry>
      <entry>--process-begin</entry>
      <entry>
       <para>
        stdin을 처리하기 전에 실행할 PHP 코드. PHP 5에서 추가.
       </para>
      </entry>
     </row>
     <row>
      <entry>-R</entry>
      <entry>--process-code</entry>
      <entry>
       <para>
        매 입력줄마다 실행할 PHP 코드. PHP 5에서 추가.
       </para>
       <para>
        이 모드에서 사용할 수 있는 두가지 특별한 변수가 있습니다:
        <varname>$argn</varname>과 <varname>$argi</varname>.
        <varname>$argn</varname>은 현 시점에서 PHP가 처리하는 줄을 가지고,
        <varname>$argi</varname>은 줄 번호를 가집니다.
       </para>
      </entry>
     </row>
     <row>
      <entry>-F</entry>
      <entry>--process-file</entry>
      <entry>
       <para>
        매 입력줄마다 실행할 PHP 파일. PHP 5에서 추가.
       </para>
      </entry>
     </row>
     <row>
      <entry>-E</entry>
      <entry>--process-end</entry>
      <entry>
       <para>
        입력을 처리한 후에 실행할 PHP 코드. PHP 5에서 추가.
       </para>
       <para><example>
        <title>프로젝트 줄 수를 세기 위해 <option>-B</option>,
         <option>-R</option>, <option>-E</option> 옵션 사용하기.
        </title>
        <screen>
<![CDATA[
$ find my_proj | php -B '$l=0;' -R '$l += count(@file($argn));' -E 'echo "Total Lines: $l\n";'
Total Lines: 37328
]]>
        </screen>
       </example></para>
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>--syntax-highlight 와 --syntax-highlighting</entry>
      <entry>
       <para>
        색으로 구문을 강조한 소스를 표시합니다.
       </para>
       <para>
        이 옵션은 파일을 해석하는 내부 메커니즘을 사용하여 강조된
        <literal>HTML</literal> 버전을 생성하여 표준 출력에 씁니다. 이로써
        만들어지는 것은 <literal>HTML</literal> <literal>&lt;code&gt; [...]
         &lt;/code&gt;</literal> 태그 블럭만이고, <literal>HTML</literal>
        헤더는 출력하지 않습니다.
       </para>
       <note>
        <para>
         이 옵션은 <option>-r</option> 옵션과 함께 사용할 수 없습니다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>--version</entry>
      <entry>
       <para><informalexample>
        <para>
         PHP, PHP SAPI, 젠드 버전을 표준 출력으로 씁니다. 예를 들면,
        </para>
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0 (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.3.0, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </informalexample></para>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>--strip</entry>
      <entry>
       <para>
        주석과 공백을 제거한 소스를 표시합니다.
       </para>
       <note>
        <para>
         이 옵션은 <option>-r</option> 옵션과 함께 사용할 수 없습니다.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>--zend-extension</entry>
      <entry>
       <para>
        젠드 확장을 적재합니다. 파일명만 주어지면, PHP는 시스템의 기본
        라이브러리 경로(보통 리눅스 시스템에서
        <filename>/etc/ld.so.conf</filename>로 지정)에서 확장을 적재하려고
        시도합니다. 절대 경로 정보와 파일명을 넘겨주면 시스템 라이브러리 검색
        경로를 사용하지 않습니다. 디렉토리 정보와 함께 상대적인 파일명을
        사용하면 PHP는 현재 디렉토리에서 상대적인 경로에서만 확장 적재를
        시도합니다.
       </para>
      </entry>
     </row>
     <row>
      <entry></entry>
      <entry>--ini</entry>
      <entry>
       <para>
        설정 파일명과 검색한 디렉토리를 표시합니다. PHP 5.2.3부터 사용할 수
        있습니다.
        <example>
         <title><literal>--ini</literal> 예제</title>
         <programlisting role="shell">
<![CDATA[
$ php --ini
Configuration File (php.ini) Path: /usr/dev/php/5.2/lib
Loaded Configuration File:         /usr/dev/php/5.2/lib/php.ini
Scan for additional .ini files in: (none)
Additional .ini files parsed:      (none)
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
     <row>
      <entry>--rf</entry>
      <entry>--rfunction</entry>
      <entry>
       <para>
        주어진 함수나 클래스 메쏘드에 대한 정보(예. 인수의 갯수와 이름)를
        보여줍니다. PHP 5.1.2부터 사용할 수 있습니다.
       </para>
       <para>
        이 옵션은 PHP를 <link
         linkend="language.oop5.reflection">Reflection</link>과 함께
        컴파일했을 경우에만 사용할 수 있습니다.
       </para>
       <para>
        <example>
         <title>기본 <literal>--rf</literal> 사용법</title>
         <programlisting role="shell">
<![CDATA[
$ php --rf var_dump
Function [ <internal> public function var_dump ] {

  - Parameters [2] {
    Parameter #0 [ <required> $var ]
    Parameter #1 [ <optional> $... ]
  }
}
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
     <row>
      <entry>--rc</entry>
      <entry>--rclass</entry>
      <entry>
       <para>
        주어진 클래스에 대한 정보(상수, 프로퍼티, 메쏘드의 목록)를 보여줍니다.
        PHP 5.1.2부터 사용할 수 있습니다.
       </para>
       <para>
        이 옵션은 PHP를 <link
         linkend="language.oop5.reflection">Reflection</link>과 함께
        컴파일했을 경우에만 사용할 수 있습니다.
       </para>
       <para>
        <example>
         <title><literal>--rc</literal> 예제</title>
         <programlisting role="shell">
<![CDATA[
$ php --rc Directory
Class [ <internal:standard> class Directory ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [0] {
  }

  - Methods [3] {
    Method [ <internal> public method close ] {
    }

    Method [ <internal> public method rewind ] {
    }

    Method [ <internal> public method read ] {
    }
  }
}
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
     <row>
      <entry>--re</entry>
      <entry>--rextension</entry>
      <entry>
       <para>
        주어진 확장에 대한 정보(&php.ini; 옵션, 정의된 함수, 상수, 클래스의
        목록)를 보여줍니다. PHP 5.1.2부터 사용할 수 있습니다.
       </para>
       <para>
        이 옵션은 PHP를 <link
         linkend="language.oop5.reflection">Reflection</link>과 함께
        컴파일했을 경우에만 사용할 수 있습니다.
       </para>
       <para>
        <example>
         <title><literal>--re</literal> 예제</title>
         <programlisting role="shell">
<![CDATA[
$ php --re json
Extension [ <persistent> extension #19 json version 1.2.1 ] {

  - Functions {
    Function [ <internal> function json_encode ] {
    }
    Function [ <internal> function json_decode ] {
    }
  }
}
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
     <row>
      <entry>--ri</entry>
      <entry>--rextinfo</entry>
      <entry>
       <para>
        주어진 확장의 설정 정보(<function>phpinfo</function>의 반환 정보와
        동일)를 보여줍니다. PHP 5.2.2부터 사용할 수 있습니다. 핵심 설정 정보는
        확장 이름으로 "main"을 사용해서 확인할 수 있습니다.
       </para>
       <para>
        <example>
         <title><literal>--ri</literal> 예제</title>
         <programlisting role="shell">
<![CDATA[
$ php --ri date

date

date/time support => enabled
"Olson" Timezone Database Version => 2007.5
Timezone Database => internal
Default timezone => Europe/Oslo

Directive => Local Value => Master Value
date.timezone => Europe/Oslo => Europe/Oslo
date.default_latitude => 59.22482 => 59.22482
date.default_longitude => 11.018084 => 11.018084
date.sunset_zenith => 90.583333 => 90.583333
date.sunrise_zenith => 90.583333 => 90.583333
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <para>
  PHP 실행 파일은 웹서버와 절대적으로 독립적인 PHP 스크립트를 실행하기 위해
  사용될수 있다. 유닉스 시스템에 있다면, PHP 스크립트의 첫번째 줄에 특별한
  것을 추가해야 하고, 실행가능하게 해서, 무슨 프로그램이 스크립트를 수행시킬지
  시스템이 알수 있도록 한다. 윈도우 플랫폼에서는
  <literal>.php</literal>파일의 더블 클릭 옵션을 갖는
  <filename>php.exe</filename>와
  연관시킬수 있거나, PHP를 통해 그 스크립트를 수행하도록 배치 파일을 만들수 있다.
  유닉스에서 실행시키기위해 추가된 첫번째 줄은 윈도우에 아무런 해가 없을것이다.
  그래서 이 방법을 사용하여 플랫폼 프로그램을 번갈아 작성할수 있다.
  명령줄 PHP 프로그램을 작성하는 단순한 에제 코드를 아래에서 볼수 있다.
 </para>
 <para>
  <example>
   <title>명령줄에서 실행되도록 의도된 스크립트(script.php)</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

This is a command line PHP script with one option.

  Usage:
  <?php echo $argv[0]; ?> <option>

  <option> can be some word you would like
  to print out. With the --help, -help, -h,
  or -? options, you can get this help.

<?php
} else {
    echo $argv[1];
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  위 스크립트에서, 특별한 첫번째 줄을 사용하여 이 파일이 PHP에 의해
  실행되어야 한다는 것을 가리킨다. CLI 버전을 사용한다면, HTTP 헤더가
  존재하지 않을것이다. PHP 의 커맨드라인 응용프로그램을 작성할때 사용할수
  있는 두개의 변수가 존재한다:<varname>$argc</varname>와 <varname>$argv</varname>.
  첫번째 변수는 인수 갯수에 하나(스크립트명)가 추가된 값이다.
  두번째 변수는 인수들를 포함하는 배열인데, 이 배열은 제로 (<varname>$argv[0]</varname>)에
  스크립트명을 갖으면 시작된다.
 </para>
 <para>
  위 프로그램에서는 인수가 하나 이하인가 이상인가를 체크한다.
  인수가 <option>--help</option>나,
  <option>-help</option>, <option>-h</option>, <option>-?</option>이면,
  help 메시지를 출력하고, 스크립트명을 동적으로 출력한다.
  다른 인수를 받게 되면, 그 인수를 출력한다.
 </para>
 <para>
  유닉스에서 위 스크립트를 수행하려 하면, 그 파일을 실행가능하게 해서 단순히
  <command>script.php echothis</command>나 <command>script.php -h</command>를
  호출하면 된다. 윈도우에서는, 이 작업을 위해 배치 파일을 만들수 있다. 
 </para>
 <para>
  <example>
   <title>명령줄의 PHP 스크립트를 수행하기 위한 배치 파일(script.bat)</title>
   <programlisting role="shell">
<![CDATA[
@C:\php\php.exe script.php %1 %2 %3 %4
]]>
   </programlisting>
  </example>
 </para>
 <para>
  위 프로그램이 <filename>script.php</filename>이란 이름을 갖고,
  <filename>C:\php\php.exe</filename> 안에 CLI <filename>php.exe</filename>를
  갖는다면 이 배치 파일은 추가된 옵션과 함께 실행이 될것이다:
  <command>script.bat echothis</command>나
  <command>script.bat -h</command>.
 </para>
 <para>
  PHP의 명령줄 응용 프로그램의 기능을 확장하기 위한 좀더 많은 함수를 보기위해
  <link linkend="ref.readline">Readline</link> 확장에 대한 문서도 참고한다.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
