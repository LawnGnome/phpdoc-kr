<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.7 $ -->
<!-- EN-Revision: 1.13 -->
 <chapter id="tutorial">
  <title>간단한 튜토리얼</title>

  <para>
   짧고 간단한 튜토리얼로 PHP의 가장 기초가 되는 부분을 보여드리겠습니다.
   PHP는 웹페이지를 만드는데에만 쓰이는 것은 아니지만, 여기서는
   PHP로 동적 웹페이지를 만드는 내용에 대해서만 다루겠습니다.
   더 많은 정보는 <link linkend="intro-whatcando">PHP는 무엇을
   할 수 있는가?</link> 섹션에 있습니다.
  </para>
  <para>
   PHP가 포함된 웹 페이지는 보통의 HTML 페이지와 같이 취급됩니다.
   그러므로, 보통의 HTML 페이지를 만드는 것과 같은 방법으로 작성할 수 있습니다.
  </para>

  <sect1 id="tutorial.requirements">
   <title>무엇이 필요한가?</title>
   <para>
    이 튜토리얼에서는 PHP를 사용 가능한 서버에서, <filename>.php</filename>
    확장자를 가지는 모든 파일은 PHP로 인식한다고 가정합니다.
    이것은 대부분의 서버에서 PHP의 기본 확장자입니다만, 확인하기 위해서
    서버 관리자에게 문의해보십시오. 서버가 PHP를 지원하고 있다면,
    그 이상 준비할 것은 없습니다. 단지 <filename>.php</filename> 파일을
    만들어서 웹 디렉토리에 넣어두면, 서버가 자동적으로 처리해줄 것입니다.
    컴파일 할 필요도 없고, 특별한 툴을 설치할 필요도 없습니다.
    PHP가 포함된 파일은, 모든것을 할 수 있게 해주는 약간의 마법의 태그를
    가진 단순한 HTML 파일이라고 생각하십시오.
   </para>
   <para>
    기존의 대역폭을 보존하거나, 로컬에서 개발하기를 원한다면,
    <link linkend="install.apache">아파치</link> 등의 웹서버를 설치하고
    <ulink url="&url.php.downloads;">PHP</ulink>를 설치할 수 있습니다.
    물론, <ulink url="&url.mysql.docs;">MySQL</ulink> 등의 데이터베이스를
    설치할 수도 있습니다. 이것들을 개별적으로 설치하거나, 보다 간단하게
    몇번의 마우스 클릭으로 모두 설치할 수 있는 <ulink url="&url.installkits;">locate
    a pre-configured package</ulink>를 사용할 수도 있습니다.
    리눅스와 Windows를 포함하여 어떤 OS에서라도 PHP를 지원하게 웹서버를
    설치하는 것은 간단합니다. 리눅스에서라면 <ulink url="&url.rpmfind;">rpmfind</ulink>로
    RPM들의 위치를 쉽게 찾을 수 있을 것입니다.
   </para>
  </sect1>

  <sect1 id="tutorial.firstpage">
   <title>Your first PHP-enabled page</title>
   <para>
    다음에 쓰여진 내용으로 <filename>hello.php</filename>를 만들고,
    웹서버 루트 디렉토리(<varname>DOCUMENT_ROOT</varname>)에 놓읍시다.
   </para>
   <para>
    <example>
     <title>첫번째 PHP 스크립트: <filename>hello.php</filename></title>
     <programlisting role="php">
<![CDATA[
<html>
 <head>
  <title>PHP 테스트</title>
 </head>
 <body>
 <?php echo "<p>Hello World</p>"; ?>
 </body>
</html>
]]>
     </programlisting>
     <simpara>
      웹 브라우저를 이용해서 "/hello.php"에 접근해봅시다. 로컬에서 개발한다면
      URL은 보통 <literal>http://localhost/hello.php</literal>이나
      <literal>http://127.0.0.1/hello.php</literal>일 것입니다.
      URL은 웹 서버 설정에 따라 달리집니다만, 이 튜토리얼에서 다룰 내용은 아닙니다.
      웹 서버 설정에 대해서는 웹 서버 설정 파일(아파치에서는 <filename>httpd.conf</filename>)의
      <varname>DocumentRoot</varname>와 <varname>ServerName</varname> 부분을 참고하십시오.
      모든 것이 제대로 설치 되었다면 이 파일은 PHP에 의해 파싱되어 브라우저에
      다음과 같은 출력을 할 것입니다:
     </simpara>
     <para>
      <screen role="html">
<![CDATA[
<html>
 <head>
  <title>PHP 테스트</title>
 </head>
 <body>
 <p>Hello World</p>
 </body>
</html>
]]>
      </screen>
     </para>
    </example>
   </para>
   <para>
    CGI 스크립트와 다른 점에 주의하십시오. 파일에 대해 실행 가능성(executable)이나
    특별한 조치는 필요가 없습니다. 많은 재미있는 일들을 하게 해주는 특별한
    태그를 지닌 보통의 HTML 파일로 생각하십시오.
   </para>
   <para>
    이 프로그램은 매우 간단해서, 실제로 이런 페이지를 만들기 위해서 PHP를
    사용할 필요는 없습니다. 이 프로그램은 <literal>Hello World</literal>를
    PHP <function>echo</function> 표현으로 보여주기만 할 뿐입니다.
   </para>
   <para>
    이 예제를 실행했을 때, 아무것도 출력하지 않거나, 다운로드 할 것인지 묻거나,
    모든 내용이 텍스트 문서처럼 보였다면, 그 서버에서 PHP가 작동하지 않는 것입니다.
    서버 관리자에게 매뉴얼의 <link linkend="installation">설치하기</link>를
    이용해서 PHP를 사용 가능하게 해달라고 요청하십시오.
    로컬에서 개발한다면, 설치하기 챕터를 읽어보고 모든 것이 제대로 설정되었나를
    확인해보십시오. 문제가 계속된다면, 망설이지 말고
    <ulink url="&url.php.support;">PHP 지원</ulink>을 이용하십시오.
   </para>
   <para>
    예제의 초점은 특별한 PHP 태그를 보여주는 것입니다.
    이 예제에서 <literal>&lt;?php</literal>가 PHP 태그의 시작을 알립니다.
    그러면 PHP 상태로 돌입하게 되고, 종료 태그인 <literal>?&gt;</literal>에
    의해서 PHP 모드를 떠나게 됩니다. HTML 파일 어디에서라도 이런 방법으로
    PHP 모드로 들어가고, 나올 수 있습니다. 더 자세한 내용은 매뉴얼에서
    <link linkend="language.basic-syntax">기초 PHP 문법</link> 섹션을 읽어보십시오.
   </para>
   <note>
    <title>텍스트 편집기 노트</title>
    <para>
     PHP를 만들고, 수정하고, 관리할 수 있는 많은 텍스트 편집기와 IDE가 있습니다.
     이러한 도구에 대한 부분적인 목록은 <ulink url="&url.phpeditorlist;">PHP
     Editor's List</ulink>에서 관리하고 있습니다. 편집기를 추천하기를 원한다면,
     위 페이지를 방문해서 페이지 관리자에게 그 편집기를 목록에 추가해달라고 하십시오.
     syntax highlighting이 있는 편집기는 도움이 될 것입니다.
    </para>
   </note>
   
   <note>
    <title>워드 프로세서 노트</title>
    <para>
     StarOffice Writer, Microsoft Word, Abiword 등의 워드 프로세서는
     PHP 파일을 수정하는데에는 좋지 않습니다. 텍스트 스크립트에 이용하기
     위해서는, 꼭 PLAIN TEXT로 저장해야만 하며, 그렇지 않으면 PHP는
     그 스크립트를 읽거나 실행하지 못할 것입니다.
    </para>
   </note>
   
   <note>
    <title>Windows 메모장 노트</title>
    <para>
     PHP 스크립트를 Windows 메모장을 이용해서 작성할때는, 파일이 .php 확장자를
     가지도록 주의해야합니다. (메모장은 다음과 같은 절차를 거치지 않으면
     자동적으로 .txt 확장자를 붙입니다) 파일을 저장할 때, 파일 이름을 묻는
     부분에서 파일 이름을 따옴표로 감싸줘야 합니다. (예: "<filename>hello.php</filename>")
     또는, 저장창에서 '텍스트 문서' 드롭다운 메뉴를 클릭해서 "모든 파일"로
     설정을 바꿀 수 있습니다. 이 경우에는 따옴표를 쓰지 않아도 됩니다.
    </para>
  </note>
  
  <para>
   간단한 PHP 스크립트를 성공적으로 작동하게 하였다면, 가장 유명한 PHP 스크립트를
   작성할 차례입니다! <function>phpinfo</function> 함수를 호출하면,
   사용 가능한 <link linkend="language.variables.predefined">예약 정의 변수</link>,
   불러진 PHP 모듈들, <link linkend="configuration">configuration</link> 설정
   등의 시스템과 설정에 관련한 수많은 유용한 정보를 볼 수 있습니다.
   잠깐의 시간을 들여서 이 중요한 정보를 확인해보십시오.
  </para>
   
  </sect1>

  <sect1 id="tutorial.useful">
   <title>유용한 무언가</title>
   <para>
    무언가 조금 더 유용한 것을 해봅시다. 어떤 사람이 페이지를
    보는데 사용하는 브라우저의 종류를 확인해봅시다. 이를 위해서,
    브라우저가 HTTP 요청의 부분으로 보내는 user agent 문자열을 확인해야 합니다.
    이 정보는 <link linkend="language.variables">변수</link>에 기록되어
    있습니다. PHP에서 변수는 항상 달러표시($)로 시작합니다. 여기서 다룰
    변수는 <varname>$_SERVER["HTTP_USER_AGENT"]</varname>입니다.
   </para>
   <note>
    <title>PHP 자동 전역 노트</title>
    <para>
     <link linkend="reserved.variables.server">$_SERVER</link>는 모든 웹 서버
     정보를 포함하기 위해 특별히 예약된 PHP 변수입니다. 이것은 자동 전역(Autoglobal
     or Superglobal)이라고 불립니다. 더 많은 정보를 위해서
     <link linkend="language.variables.superglobals">자동전역</link>에 관련된
     매뉴얼 페이지를 참고하십시오. 이 특별한 변수들은 PHP
     <ulink url="&url.php.release4.1.0;">4.1.0</ulink>에서 소개되었습니다.
     이전에는 <varname>$HTTP_SERVER_VARS</varname> 등의 <varname>$HTTP_*_VARS</varname>
     배열을 이용하였습니다. deprecated이지만, 이 구형의 변수들은 아직 존재합니다.
     (<link linkend="tutorial.oldcode">예전의 코드</link>에 관한 노트를 참고하십시오)
    </para>
   </note>
   <para>
    이 변수를 표시하는 것은 간단합니다:
   </para>
   <para>
    <example>
    <title>변수 출력하기 (배열 요소)</title>
    <programlisting role="php">
<![CDATA[
<?php echo $_SERVER["HTTP_USER_AGENT"]; ?>
]]>
    </programlisting>
    <para>
     이 스크립트의 출력 예제는 다음과 같습니다:
     <screen role="html">
Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)
     </screen>
    </para>
   </example>
   </para>
   <para>
    PHP에는 많은 변수의 <link linkend="language.types">형</link>이
    존재합니다. 위 예제에서는 <link linkend="language.types.array">배열</link>
    요소를 출력했습니다. 배열은 매우 유용할 수 있습니다.
   </para>
   <para>
    <varname>$_SERVER</varname>는 PHP에 의해서 자동적으로 만들어지는
    변수 중에 하나에 불과합니다. 매뉴얼의 <link linkend="reserved.variables">예약
    정의 변수</link>를 보거나, 다음과 같은 파일을 작성하여 모든 목록을 확인할
    수 있습니다:
   </para>
   <para>
    <example>
     <title><function>phpinfo</function>로 모든 예약 정의 변수 보기</title>
     <programlisting role="php">
<![CDATA[
<?php phpinfo(); ?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    브라우저로 이 파일을 읽어오면 PHP에 대한 정보와 함께 사용가능한
    모든 변수들을 확인할 수 있습니다.
   </para>
   <para>
    You can put multiple PHP statements inside a PHP tag and create
    little blocks of code that do more than just a single echo.
    For example, if we wanted to check for Internet Explorer we
    could do something like this:
   </para>
   <para>
    <example>
     <title>Example using <link linkend="control-structures">control 
     structures</link> and <link linkend="functions">functions</link></title>
     <programlisting role="php">
<![CDATA[
<?php
if (strstr($_SERVER["HTTP_USER_AGENT"], "MSIE")) {
	echo "You are using Internet Explorer<br />";
}
?>
]]>
     </programlisting>
     <para>
      A sample output of this script may be:
      <screen role="html">
<![CDATA[
You are using Internet Explorer<br />
]]>
      </screen>
     </para>
    </example>
   </para>
   <para>
    Here we introduce a couple of new concepts. We have an 
    <link linkend="control-structures.if">if</link> statement.
    If you are familiar with the basic syntax used by the C
    language this should look logical to you. If you don't know enough
    C or some other language where the syntax used above is used, you
    should probably pick up any introductory PHP book and read the first
    couple of chapters, or read the <link linkend="langref">Language
    Reference</link> part of the manual. You can find a list of PHP books
    at <ulink url="&url.php.books;">&url.php.books;</ulink>.
   </para>
   <para>
    The second concept we introduced was the <function>strstr</function>
    function call. <function>strstr</function> is a function built into
    PHP which searches a string for another string. In this case we are
    looking for <literal>"MSIE"</literal> inside
    <varname>$_SERVER["HTTP_USER_AGENT"]</varname>. If the string is found,
    the function returns &true; and if it isn't, it returns &false;. If
    it returns &true;, the <link linkend="control-structures.if">if</link> 
    statement evaluates to &true; and the code within its {braces} is 
    executed.  Otherwise, it's not.  Feel free to create similar examples, 
    with <link linkend="control-structures.if">if</link>, 
    <link linkend="control-structures.else">else</link>, and other 
    functions such as <function>strtoupper</function> and 
    <function>strlen</function>.  Each related manual page contains examples 
    too.
   </para>
   <para>
    We can take this a step further and show how you can jump in and out
    of PHP mode even in the middle of a PHP block:
   </para>
   <para>
    <example>
     <title>Mixing both HTML and PHP modes</title>
     <programlisting role="php">
<![CDATA[
<?php
if (strstr($_SERVER["HTTP_USER_AGENT"], "MSIE")) {
?>
<h3>strstr must have returned true</h3>
<center><b>You are using Internet Explorer</b></center>
<?php
} else {
?>
<h3>strstr must have returned false</h3>
<center><b>You are not using Internet Explorer</b></center>
<?php
}
?>
]]>
     </programlisting>
     <para>
      A sample output of this script may be:
      <screen role="html">
<![CDATA[
<h3>strstr must have returned true</h3>
<center><b>You are using Internet Explorer</b></center>
]]>
      </screen>
     </para>
    </example>
   </para>
   <para>
    Instead of using a PHP echo statement to output something, we jumped out of PHP
    mode and just sent straight HTML. The important and powerful point to note here
    is that the logical flow of the script remains intact. Only one of the HTML blocks
    will end up getting sent to the viewer depending on if
    <function>strstr</function> returned &true; or &false;  In other words, 
    if the string <literal>MSIE</literal> was found or not.
   </para>
  </sect1>
   
  <sect1 id="tutorial.forms">
   <title>폼(Form) 다루기</title>
   <para>
    One of the most powerful features of PHP is the way it handles HTML
    forms. The basic concept that is important to understand is that any
    form element in a form will automatically be available to your PHP 
    scripts.  Please read the manual section on
    <link linkend="language.variables.external">Variables from outside 
    of PHP</link> for more information and examples on using forms 
    with PHP.  Here's an example HTML form:
   </para>
   <para>
    <example>
     <title>A simple HTML form</title>
     <programlisting role="html">
<![CDATA[
<form action="action.php" method="POST">
 Your name: <input type="text" name="name" />
 Your age: <input type="text" name="age" />
 <input type="submit">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    There is nothing special about this form. It is a straight HTML form
    with no special tags of any kind. When the user fills in this form
    and hits the submit button, the <filename>action.php</filename> page
    is called. In this file you would have something like this:
   </para>
   <para>
    <example>
     <title>Printing data from our form</title>
     <programlisting role="php">
<![CDATA[
Hi <?php echo $_POST["name"]; ?>.
You are <?php echo $_POST["age"]; ?> years old.
]]>
     </programlisting>
     <para>
      A sample output of this script may be:
      <screen role="html">
<![CDATA[
Hi Joe.
You are 22 years old.
]]>
      </screen>
     </para>
    </example>
   </para>
   <para>
    It should be obvious what this does. There is nothing more to it.
    The <varname>$_POST["name"]</varname> and <varname>$_POST["age"]</varname>
    variables are automatically set for you by PHP.  Earlier we
    used the <varname>$_SERVER</varname> autoglobal, now above we just 
    introduced the <link linkend="reserved.variables.post">$_POST</link>
    autoglobal which contains all POST data.  Notice how the
    <emphasis>method</emphasis> of our form is POST.  If we used the 
    method <emphasis>GET</emphasis> then our form information would live in 
    the <link linkend="reserved.variables.get">$_GET</link> autoglobal instead.
    You may also use the <link linkend="reserved.variables.request">$_REQUEST</link>
    autoglobal if you don't care the source of your request data. It 
    contains a mix of GET, POST, COOKIE and FILE data.  See also the 
    <function>import_request_variables</function> function.
   </para>
  </sect1>
  
  <sect1 id="tutorial.oldcode">
   <title>새 버전의 PHP에서 예전의 코드를 사용하기</title>
   <para>
    Now that PHP has grown to be a popular scripting language, there are
    more resources out there that have listings of code you can reuse
    in your own scripts. For the most part the developers of the PHP
    language have tried to be backwards compatible, so a script written
    for an older version should run (ideally) without changes in a newer
    version of PHP, in practice some changes will usually be needed.
   </para>
   <para>
    예전의 코드에 영향을 주는 최근의 중요한 두가지 변경점:
    <itemizedlist>
     <listitem>
      <simpara>
       (함수나 메쏘드 안에서 사용할 때 global 선언을 필요로 하는) 이전의
       <varname>$HTTP_*_VARS</varname> 배열에의 반대(deprecation).
       PHP <ulink url="&url.php.release4.1.0;">4.1.0</ulink>에서 소개한
       <link linkend="language.variables.superglobals">자동 전역 배열</link>을
       사용하십시오. 그 종류에는 <varname>$_GET</varname>, <varname>$_POST</varname>,
       <varname>$_COOKIE</varname>, <varname>$_SERVER</varname>,
       <varname>$_ENV</varname>, <varname>$_REQUEST</varname>,
       <varname>$_SESSION</varname>이 있습니다. $HTTP_POST_VARS와 같은
       이전의 <varname>$HTTP_*_VARS</varname> 배열은 PHP 3부터 아직까지 존재합니다.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       기본값으로, 외부 변수를 더 이상 전역 변수로 등록하지 않습니다.
       다른 말로는, PHP <ulink url="&url.php.release4.2.0;">4.2.0</ulink>부터
       &php.ini;에서의 PHP 설정 <link linkend="ini.register-globals">register_globals</link>의
       기본값이 <emphasis>off</emphasis>가 되었습니다. 이 값들에의 접근은
       위에서 언급한 자동 전역 배열을 이용하는 것을 권장합니다.
       예전의 스크립트, 책, 그리고 튜토리얼은 이 설정을 on이라고 생각합니다.
       예를 들어, on이라면 누군가가 <varname>$id</varname>를 URL
       <literal>http://www.example.com/foo.php?id=42</literal>처럼 사용할 수 있습니다.
       on/off에 관계 없이, <varname>$_GET['id']</varname>은 사용 가능합니다.
      </simpara>
     </listitem>
    </itemizedlist>
    이 변화에 대한 자세한 내용은
    <link linkend="language.variables.predefined">예약 정의 변수</link>
    섹션과 그 안의 링크들을 참고하십시오.
   </para>
  </sect1>
  
  <sect1 id="tutorial.whatsnext">
   <title>다음은?</title>
   <para>
    With what you know now you should be able to understand most of 
    the manual and also the various example scripts available in the
    example archives. You can also find other examples on the php.net
    websites in the links section:
    <ulink url="&url.php.links;">&url.php.links;</ulink>.
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->