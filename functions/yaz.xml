<?xml version="1.0" encoding="utf-8"?>
<reference id="ref.yaz">
	<title>YAZ functions</title>
	<titleabbrev>YAZ</titleabbrev>
	<partintro>
		<sect1 id="yaz.intro">
			<title>Introduction</title>
			<para>
    이 익스텐션은 정보검색을 위한 Z39.50 프로토콜을 사용하는<productname>YAZ</productname>툴킷의 PHP 인터페이스를 제공한다. 이 익스텐션은 Z39.50 origin(client)에게 쉽게 Z39.50 targets (servers)을 병렬 검색할 수 있는 도구를 제공한다. 
   </para>
			<para>
				<productname>YAZ</productname>는 <ulink url="&url.yaz;">&url.yaz;</ulink>서 만나볼 수 있다. 뉴스, 예제 스크립트, 등등 이 익스텐션은 <ulink url="&url.yaz-phpyaz;">&url.yaz-phpyaz;</ulink>여기서 구할 수 있다.
   </para>
			<para>
    이 모듈은 Z39.50의 복잡성은 대부분 감추어져 있어서 매우 사용하기 쉽다. 이것은 PHP가 이용할 수 있는 다양한 SQL APIs와 매우 유사한 persistent stateless connections 을 제공한다. 이것은 세션들이 stateless 하지만 사용자들에게 분배된다는 것을 의미한다. 결국. 대부분의 경우 연결은 저장되고 상태의 진행은 초기화 된다.
   </para>
		</sect1>
		<sect1 id="yaz.install">
			<title>설치</title>
			<para>
    YAZ를 컴파일 하고 설치를 한다. PHP를 필요한 모듈과 빌드 할때 --with-yaz 옵션을 추가한다. 작업은 대개 다음과 같다.:
   </para>
			<para>
				<informalexample>
					<programlisting>
gunzip -c yaz-1.6.tar.gz|tar xf -
gunzip -c php-4.0.X.tar.gz|tar xf -
cd yaz-1.6
./configure --prefix=/usr
make
make install
cd ../php-4.0.X
./configure --with-yaz=/usr/bin
make
make install
    </programlisting>
				</informalexample>
			</para>
		</sect1>
		<sect1 id="yaz.example">
			<title>Example</title>
			<para>
    PHP/YAZ는 targets(Z-Associations)의 연결을 유지한다. positive integer는 ID of a
    particular를 나타낸다.
   </para>
			<para>
    아래의 예제 스크립트는 API의 parallel searching을 보여준다. 독립변수 업시 불러낼때 query form을 출력하고 그렇지 않은경우(독립변수가 주어질때) 주어진 배열에서 targets을 찾아낸다
                    </para>
			<para>
				<example>
					<title>
						<function>YAZ</function>
					</title>
					<programlisting role="php">
$num_hosts = count ($host);
if (empty($term) || count($host) == 0) {
    echo '&lt;form method="get"&gt;
    &lt;input type="checkbox"
    name="host[]" value="bagel.indexdata.dk/gils"&gt;
        GILS test
    &lt;input type="checkbox"
    name="host[]" value="localhost:9999/Default"&gt;
        local test
    &lt;input type="checkbox" checked="1"
    name="host[]" value="z3950.bell-labs.com/books"&gt;
        BELL Labs Library
    &lt;br>
    RPN Query:
    &lt;input type="text" size="30" name="term"&gt;
    &lt;input type="submit" name="action" value="Search"&gt;
    ';        
} else {
    echo 'You searced for ' . htmlspecialchars($term) . '&lt;br&gt;';
    for ($i = 0; $i &lt; $num_hosts; $i++) {
        $id[] = yaz_connect($host[$i]);
        yaz_syntax($id[$i],"sutrs");
        yaz_search($id[$i],"rpn",$term);
    }
    yaz_wait();
    for ($i = 0; $i &lt; $num_hosts; $i++) {
        echo '&lt;hr&gt;' . $host[$i] . ":";
        $error = yaz_error($id[$i]);
        if (!empty($error)) {
            echo "Error: $error";
        } else {
            $hits = yaz_hits($id[$i]);
            echo "Result Count $hits";
        }
        echo '&lt;dl&gt;';
        for ($p = 1; $p &lt;= 10; $p++) {
            $rec = yaz_record($id[$i],$p,"string");
            if (empty($rec)) continue;
            echo "&lt;dt&gt;&lt;b&gt;$p&lt;/b&gt;&lt;/dt&gt;&lt;dd&gt;";
            echo ereg_replace("\n", "&lt;br&gt;\n",$rec);
            echo "&lt;/dd&gt;";
        }
        echo '&lt;/dl&gt;';
    }
}
    </programlisting>
				</example>
			</para>
		</sect1>
	</partintro>
	<refentry id="function.yaz-addinfo">
		<refnamediv>
			<refname>yaz_addinfo</refname>
			<refpurpose>추가적인 error 정보를 리턴한다.</refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_addinfo</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
				</methodsynopsis>
			<para>
     부가적인 target (마지막 요청한)에 관한 정보를 리턴한다. 만일 마지막 작업이 성공적으로 이루어지거나 target이 제공하는 추가정보가 없는 경우 공백문자(A empty string)를 리턴한다.
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-close">
		<refnamediv>
			<refname>yaz_close</refname>
			<refpurpose>YAZ의 연결을 닫는다.</refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_close</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
				</methodsynopsis>
			<para>
     target과의 연결을 닫는다. application은 주어진 ID로 target에 조회할 수 없다.
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-connect">
		<refnamediv>
			<refname>yaz_connect</refname>
			<refpurpose>
     성공한 경우 양의 association ID를 리턴한다 : 실패의 경우 "0"을 리턴
    </refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_connect</methodname>
					<methodparam><type>string</type><parameter>zurl</parameter></methodparam>
				</methodsynopsis>
			<para>
				<function>yaz_connect</function>은 Z39.50 target과의 연결을 준비한다. zurl 변수는 host[:port][/database]형태를 취한다. 
				만일 port가 주어지지 않으면 "210"이 사용되고, database가 주어지지 않으면 "Default"를 사용한다. non-blocking함수이고, socket을 만들려고 시도하지 않는다. 
				- 이것은 단지 마지막으로 <function>yaz_wait</function>가 호출되었을때 수행된 연결을 준비한다.
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-errno">
		<refnamediv>
			<refname>yaz_errno</refname>
			<refpurpose>error number를 리턴한다.</refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_errno</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
				</methodsynopsis>
			<para>
     target (last request)에 관한 error을 리턴한다. target이 진단코드(diagnostic code)를 리턴한 경우 양의 값을; 성공하여 에러가 없는 경우는 "0"의 값을; 요청에 대한 에러를 나타내지 못하는 경우 음의 값을 리턴한다.
    </para>
			<para>
				<function>yaz_errno</function>은 마지막 작업이 success/failure가 결정된 target에 대한 네트워크가 활성화(<function>yaz_wait</function>라 리턴된 후에) 된 다음에 호출되어야 한다. (예. search)
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-error">
		<refnamediv>
			<refname>yaz_error</refname>
			<refpurpose>error내용을 리턴한다.</refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_error</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
				</methodsynopsis>
			<para>
     target (마지막 요청한)의 error 메세지를 리턴한다. 마지막 행한 작업이 성공적인 경우 공백문자(empty string)을 리턴한다.
    </para>
			<para>
				<function>yaz_error</function>는  <function>yaz_errno</function>에 의해 리터된 마지막 에러번호에 일치하는 영문 메세지를 리턴한다.
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-hits">
		<refnamediv>
			<refname>yaz_hits</refname>
			<refpurpose>마지막 검색에 대한 히트수를 리턴한다.</refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_hits</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
				</methodsynopsis>
			<para>
				<function>yaz_hits</function> 마지막 검색에 대한 히트수를 리턴한다.
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-range">
		<refnamediv>
			<refname>yaz_range</refname>
			<refpurpose>
     검색결과를 나타낼 범위를 지정한다.
    </refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_range</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
					<methodparam><type>int</type><parameter>start</parameter></methodparam>
					<methodparam><type>int</type><parameter>number</parameter></methodparam>
				</methodsynopsis>
			<para>
     이 함수는 <function>yaz_search</function>와 조합하여 시작위치(start)와 검색내용 중 나열할 최대값(number)을 나타내는데 이용된다. start의 디폴트 값은 "1"이고, number의 디폴트 값은 "10"이다.( 단지 <function>yaz_search</function>만이 있는경우)
        </para>
			<para>
    성공하면 &true;를 : 에러가 난 경우는 &false; 를 반환한다. 
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-record">
		<refnamediv>
			<refname>yaz_record</refname>
			<refpurpose>레코드를 리턴한다.</refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_record</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
					<methodparam><type>int</type><parameter>pos</parameter></methodparam>
					<methodparam><type>string</type><parameter>type</parameter></methodparam>
				</methodsynopsis>
			<para>
     주어진 포지션에 레코드가 없는경우 공백문자를 반환하고, 있는경우 레코드를 반환한다.
    </para>
			<para>
				<function>yaz_record</function>는 지정된 위치의 result set에서의 레코드를 점검한다. 만일 주어진 위치에서 database record 존재하지 않으면 공백문자를 리턴한다. 변수는 리턴될 레코드의 type를 지정한다. 만일 "string"이 주어지면 레코드는 (XML과 SUTRS)출력에 적합한 문자로 리턴된다. 만일 "array"로 지정하면 (structured records위한) 배열로 리턴된다.
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-search">
		<refnamediv>
			<refname>yaz_search</refname>
			<refpurpose>검색을 준비한다.</refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_search</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
					<methodparam><type>string</type><parameter>type</parameter></methodparam>
					<methodparam><type>string</type><parameter>query</parameter></methodparam>
				</methodsynopsis>
			<para>
				<function>yaz_search</function>은 주어진 ID로 target에 검색을 준비한다. type은 쿼리 타입을 나타낸다.-세번째 변수로 지정된 Type-1 query (RPN)인 경우 단지 "rpn"만을 지원한다. <function>yaz_connect</function>처럼 non-blocking 이고 <function>yaz_wait</function>이 호출된 이후에 검색을 준비한다.
    </para>
		</refsect1>
		<refsect1>
			<title>The RPN query</title>
			<para>
     The RPN query is a textual represenation of the Type-1 query as defined by the Z39.50 standard. However, in the text representation
     as used by YAZ a prefix notation is used, that is the operater
     precedes the operands. The query string is a sequence of tokens where
     white space is ignored is ignored unless surrounded by double
     quotes. Tokens beginning with an at-character (<literal>@</literal>)
     are considered operators, otherwise they are treated as search terms.
    </para>
			<table>
				<title>RPN Operators</title>
				<tgroup cols="2">
					<thead>
						<row>
							<entry>Syntax</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<literal>@and query1 query2</literal>
							</entry>
							<entry>intersection of query1 and query2</entry>
						</row>
						<row>
							<entry>
								<literal>@or query1 query2</literal>
							</entry>
							<entry>union of query1 and query2</entry>
						</row>
						<row>
							<entry>
								<literal>@not query1 query2</literal>
							</entry>
							<entry>query1 and not query2</entry>
						</row>
						<row>
							<entry>
								<literal>@set name</literal>
							</entry>
							<entry>result set reference</entry>
						</row>
						<row>
							<entry>
								<literal>@attrset set query</literal>
							</entry>
							<entry>specifies attribute-set for query. This construction is only
                allowed once - in the beginning of the whole query</entry>
						</row>
						<row>
							<entry>
								<literal>@attr set type=value query</literal>
							</entry>
							<entry>applies attribute to query. The type and value are
                 integers specifying the attribute-type and attribute-value
                 respectively. The set, if given, specifies the
                 attribute-set.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>
     The following illustrates valid query constructions:
     <informalexample>
					<screen>computer</screen>
				</informalexample>
      Matches documents where "computer" occur. No attributes are specified.
    </para>
			<para>
				<informalexample>
					<screen>"donald knuth"</screen>
				</informalexample>
     Matches documents where "donald knuth" occur.
    </para>
			<para>
				<informalexample>
					<screen>@attr 1=4 art</screen>
				</informalexample>
     Attribute type is 1 (Bib-1 use), attribute value is 4
     Title), so this should match documents where "art" occur
     in the title.
    </para>
			<para>
				<informalexample>
					<screen>@attrset gils @and @attr 1=4 art @attr 1=1003 "donald knuth"</screen>
				</informalexample>
     The query as a whole uses the GILS attributeset. The query matches
     documents where "art" occur in the title and in which "donald knuth"
     occur in the author.
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-syntax">
		<refnamediv>
			<refname>yaz_syntax</refname>
			<refpurpose>
     Specifies the object identifier (OID) for the preferred record syntax
     for retrieval.
    </refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_syntax</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
					<methodparam><type>string</type><parameter>syntax</parameter></methodparam>
				</methodsynopsis>
			<para>
     The syntax may be specified in a raw dot-notation (like
     <literal>1.2.840.10003.5.10</literal>) or as one of the known
     record syntaxes (sutrs, usmarc, grs1, xml, etc.).
     This function is used in conjunction with
     <function>yaz_search</function> to specify the preferred record
     syntax for retrieval.
    </para>
		</refsect1>
	</refentry>
	<refentry id="function.yaz-wait">
		<refnamediv>
			<refname>yaz_wait</refname>
			<refpurpose>Executes queries</refpurpose>
		</refnamediv>
		<refsect1>
			<title>Description</title>
				<methodsynopsis>
					<type>int</type><methodname>yaz_wait</methodname>
					<methodparam><type>int</type><parameter>id</parameter></methodparam>
					<methodparam><type>string</type><parameter>syntax</parameter></methodparam>
				</methodsynopsis>
			<para>
     This function carries out networked (blocked) activity for
     outstanding requests which have been prepared by the functions
     <function>yaz_connect</function>,
     <function>yaz_search</function>.  <function>yaz_wait</function>
     returns when all targets have either completed all requests or
     otherwise completed (in case of errors).
    </para>
		</refsect1>
	</refentry>
</reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

