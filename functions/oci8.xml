 <reference id="ref.oci8">
  <title>Oracle 8 functions</title>
  <titleabbrev>OCI8</titleabbrev>
  <partintro>
   <para>
		이 함수들은 Oracle8과 Oracle7 데이터베이스를 접근할 수 있도록 해준다.
		이것은 Oracle8 Call-Interface (OCI8)를 사용한다.
		이 드라이버를 사용하려면 Oracle8 client libraries가 필요하다.
   </para>
   <para>
		이 드라이버는 보통의 PHP Ora_ 드라이버보다 더욱 유연하다. 
		이것은 PHP의 전역, 지역 변수들의 Oracle placeholder로의 binding을 지원하고, 
		full LOB와 FILE, ROWID를 지원하며, user-supplied define variable을 
		사용할 수 있도록 해 준다. 
   </para>
   <para>
		이 드라이버를 사용하기 전에 오라클 유저와 웹서버 유저에게 
		유효한 오라클 환경변수를 적용했는지 확인해야한다. 
		적용시킬 환경변수:
    <itemizedlist>
     <listitem>
      <simpara>
       ORACLE_HOME
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       ORACLE_SID
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       LD_PRELOAD
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       LD_LIBRARY_PATH
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       NLS_LANG
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       ORA_NLS33
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
   <para>
		웹서버 유저에게 환경변수를 적용한후에,
		웹서버 유저(nobody, www)를 오라클 그룹에 추가했는지 확인해야 한다.
   </para>
   <para>
    <example>
     <title>OCI Hints</title>
      <programlisting role="php">
&lt;?php
// by sergo@bacup.ru

// Use option: OCI_DEFAULT for execute command to delay execution
OCIExecute($stmt, OCI_DEFAULT);

// for retrieve data use (after fetch):

$result = OCIResult($stmt, $n);
if (is_object ($result)) $result = $result->load();

// For INSERT or UPDATE statement use:

$sql = "insert into table (field1, field2) values (field1 = 'value',
 field2 = empty_clob()) returning field2 into :field2";
OCIParse($conn, $sql);
$clob = OCINewDescriptor($conn, OCI_D_LOB);
OCIBindByName ($stmt, ":field2", &$clob, -1, OCI_B_CLOB);
OCIExecute($stmt, OCI_DEFAULT);
$clob->save ("some text");

?&gt;
     </programlisting>
    </example>
   </para>
   <para>
		command-line에서 내장 프로시저(stored procedures)를 쓰는것처럼 
		사용이 간편하다.
    <example>
     <title>내장 프로시저(Stored Procedures) 사용하기</title>
      <programlisting role="php">
&lt;?php
// by webmaster@remoterealty.com
$sth = OCIParse ( $dbh, "begin sp_newaddress( :address_id, '$firstname',
 '$lastname', '$company', '$address1', '$address2', '$city', '$state',
 '$postalcode', '$country', :error_code );end;" );

// This calls stored procedure sp_newaddress, with :address_id being an
// in/out variable and :error_code being an out variable. 
// Then you do the binding:

   OCIBindByName ( $sth, ":address_id", $addr_id, 10 );
   OCIBindByName ( $sth, ":error_code", $errorcode, 10 );
   OCIExecute ( $sth );

?&gt;
     </programlisting>
    </example>
   </para>
  </partintro>

  <refentry id="function.ocidefinebyname">
   <refnamediv>
    <refname>OCIDefineByName</refname>
    <refpurpose>
		 SELECT 구문을 사용하는 동안 정의단계(define-step)를 위한 PHP 변수를 할당한다.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIDefineByName</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>string <parameter>Column-Name</parameter></paramdef>
      <paramdef>mixed <parameter>variable</parameter></paramdef>
      <paramdef>int <parameter><optional>type</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIDefineByName</function>페치(fetch)한 컬럼을 사용자정의 변수
     에 할당한다.  
     물론, 오라클 유저는 select 구문에서 소문자 컬럼명을  쓸수 있지만,
     <function>OCIDefineByName</function>함수의 
     <parameter>Column-Name</parameter>인수는 반드시 대문자로 적어야 한다.
     select 구문에서 존재하지도 않는 변수를 선언해도, 에러는 발생하지않을것이다!
    </para>
    <para>
     추상 데이터타입(LOB/ROWID/BFILE)을 다룰 때는
     <function>OCINewDescriptor</function>함수를 사용하여
     그 컬럼에 대한 변수영역을 미리 할당해야 한다. 
     <function>OCIBindByName</function>를 보시오.
    </para>
     <example>
      <title>OCIDefineByName</title>
      <programlisting>
&lt;?php
/* OCIDefineByPos example thies@thieso.net (980219) */

$conn = OCILogon("scott","tiger");

$stmt = OCIParse($conn,"select empno, ename from emp");

/* the define MUST be done BEFORE ociexecute! */

OCIDefineByName($stmt,"EMPNO",$empno);
OCIDefineByName($stmt,"ENAME",$ename);

OCIExecute($stmt);

while (OCIFetch($stmt)) {
    echo "empno:".$empno."\n";
    echo "ename:".$ename."\n";
}

OCIFreeStatement($stmt);
OCILogoff($conn);
?>
     </programlisting>
    </example>
   </refsect1>
  </refentry>

  <refentry id="function.ocibindbyname">
   <refnamediv>
    <refname>OCIBindByName</refname>
    <refpurpose>
     오라클 위치보유자(Placeholder)를 PHP 변수에 연계(bind)시킨다.
     Bind a PHP variable to an Oracle Placeholder
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIBindByName</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>string <parameter>ph_name</parameter></paramdef>
      <paramdef>mixed &amp;<parameter>variable</parameter></paramdef>
      <paramdef>int <parameter>length</parameter></paramdef>
      <paramdef>int <parameter>
       <optional>type</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIBindByName</function> binds the PHP variable
     <parameter>variable</parameter> to the Oracle placeholder
     <parameter>ph_name</parameter>.  Whether it will be used for
     input or output will be determined run-time, and the necessary
     storage space will be allocated. The
     <parameter>length</parameter> parameter sets the maximum length
     for the bind. If you set <parameter>length</parameter> to -1
     <function>OCIBindByName</function> will use the current length of
     <parameter>variable</parameter> to set the maximum length.
    </para>
    <para>
     If you need to bind an abstract Datatype (LOB/ROWID/BFILE) you
     need to allocate it first using
     <function>OCINewDescriptor</function> function. The
     <parameter>length</parameter> is not used for abstract Datatypes
     and should be set to -1. The <parameter>type</parameter> variable
     tells oracle, what kind of descriptor we want to use. Possible
     values are: OCI_B_FILE (Binary-File), OCI_B_CFILE
     (Character-File), OCI_B_CLOB (Character-LOB), OCI_B_BLOB
     (Binary-LOB) and OCI_B_ROWID (ROWID).
    </para>
    <example>
     <title>OCIDefineByName</title>
     <programlisting>
&lt;?php
/* OCIBindByPos example thies@thieso.net (980221)
  inserts 3 records into emp, and uses the ROWID for updating the 
  records just after the insert.
*/

$conn = OCILogon("scott","tiger");

$stmt = OCIParse($conn,"insert into emp (empno, ename) ".
					   "values (:empno,:ename) ".
					   "returning ROWID into :rid");

$data = array(1111 => "Larry", 2222 => "Bill", 3333 => "Jim");

$rowid = OCINewDescriptor($conn,OCI_D_ROWID);

OCIBindByName($stmt,":empno",&amp;$empno,32);
OCIBindByName($stmt,":ename",&amp;$ename,32);
OCIBindByName($stmt,":rid",&amp;$rowid,-1,OCI_B_ROWID);

$update = OCIParse($conn,"update emp set sal = :sal where ROWID = :rid");
OCIBindByName($update,":rid",&amp;$rowid,-1,OCI_B_ROWID);
OCIBindByName($update,":sal",&amp;$sal,32);

$sal = 10000;

while (list($empno,$ename) = each($data)) {
	OCIExecute($stmt);
	OCIExecute($update);
} 

$rowid->free();

OCIFreeStatement($update);
OCIFreeStatement($stmt);

$stmt = OCIParse($conn,"select * from emp where empno in (1111,2222,3333)");
OCIExecute($stmt);
while (OCIFetchInto($stmt,&amp;$arr,OCI_ASSOC)) {
	var_dump($arr);
}
OCIFreeStatement($stmt);

/* delete our "junk" from the emp table.... */
$stmt = OCIParse($conn,"delete from emp where empno in (1111,2222,3333)");
OCIExecute($stmt);
OCIFreeStatement($stmt);

OCILogoff($conn);
?>
     </programlisting>
    </example>
    <warning>
     <para>
      It is a bad idea to use magic quotes and
      <function>OciBindByName</function> simultaneously as no quoting
      is needed on quoted variables and any quotes magically applied
      will be written into your database as
      <function>OciBindByName</function> is not able to distinguish
      magically added quotings from those added by intention.
     </para> 
    </warning>
   </refsect1>
  </refentry>
  
  <refentry id="function.ocilogon">
   <refnamediv>
    <refname>OCILogon</refname>
    <refpurpose>Establishes a connection to Oracle</refpurpose>
    <refpurpose>오라클 접속을 구축한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCILogon</function></funcdef>
      <paramdef>string <parameter>username</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string
       <parameter><optional>db</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCILogon</function> 다른 OCI 함수 호출에 필요한 접속 변수를
     넘겨준다. 세번째 인수는 로컬 오라클 인스턴스(local Oracle instance)이름,
     또는 tnsnames.ora 설정파일에 설정된 엔트리(entry) 이름이 될 수 있다. 
     세번째 인수를 생략할 경우, PHP는 접속할 데이터베이스를 결정하기 위해서 
     환경변수 ORACLE_SID(Oracle instance) 또는 TWO_TASK(tnsnames.ora)를
     이용한다.
    </para>
    <para>Connections are shared at the page level when using
    <para>이 함수를 사용할때마다 각 접속은 페이지 레벨에서 분배되어진다.
     <function>OCILogon</function>.  This means that commits and
     rollbacks apply to all open transactions in the page, even if you
     have created multiple connections.
     <function>OCILogon</function>.  이것은 각 페이지에서 열린 모든 
     트랜잭션에 커밋(commits)과 롤백(rollbacks)이 적용되어진다는 것을
     의미한다. 두개이상의 접속을 만들지라도. 
    </para>
    <para>
     This example demonstrates how the connections are shared.
     아래 예제는 접속이 어떻게 분배되는가를 보여준다.
     <example>
      <title>OCILogon</title>
      <programlisting>
&lt;?php
print "&lt;HTML>&lt;PRE>";
$db = "";

$c1 = ocilogon("scott","tiger",$db);
$c2 = ocilogon("scott","tiger",$db);

function create_table($conn)
{ $stmt = ociparse($conn,"create table scott.hallo (test varchar2(64))");
  ociexecute($stmt);
  echo $conn." created table\n\n";
}

function drop_table($conn)
{ $stmt = ociparse($conn,"drop table scott.hallo");
  ociexecute($stmt);
  echo $conn." dropped table\n\n";
}

function insert_data($conn)
{ $stmt = ociparse($conn,"insert into scott.hallo 
            values('$conn' || ' ' || to_char(sysdate,'DD-MON-YY HH24:MI:SS'))");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." inserted hallo\n\n";
}

function delete_data($conn)
{ $stmt = ociparse($conn,"delete from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." deleted hallo\n\n";
}

function commit($conn)
{ ocicommit($conn);
  echo $conn." committed\n\n";
}

function rollback($conn)
{ ocirollback($conn);
  echo $conn." rollback\n\n";
}

function select_data($conn)
{ $stmt = ociparse($conn,"select * from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn."----selecting\n\n";
  while (ocifetch($stmt))
    echo $conn." &lt;".ociresult($stmt,"TEST").">\n\n";
  echo $conn."----done\n\n";
}

create_table($c1);
insert_data($c1);   // Insert a row using c1
insert_data($c2);   // Insert a row using c2

select_data($c1);   // Results of both inserts are returned
select_data($c2);   

rollback($c1);      // Rollback using c1

select_data($c1);   // Both inserts have been rolled back
select_data($c2);   

insert_data($c2);   // Insert a row using c2
commit($c2);        // commit using c2

select_data($c1);   // result of c2 insert is returned

delete_data($c1);   // delete all rows in table using c1
select_data($c1);   // no rows returned
select_data($c2);   // no rows returned
commit($c1);        // commit using c1

select_data($c1);   // no rows returned
select_data($c2);   // no rows returned


drop_table($c1);
print "&lt;/PRE>&lt;/HTML>";
?></programlisting></example></para>
    <simpara>
     See also <function>OCIPLogon</function> and
     <function>OCINLogon</function>.</simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ociplogon">
   <refnamediv>
    <refname>OCIPLogon</refname>
    <refpurpose>오라클 데이터베이스에 접속하고 영속적 DB 접속
    (persistant connection) 을 이용해서 로그온한다.
    또다른 새로운 세션(session)을 넘겨준다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIPLogon</function></funcdef>
      <paramdef>string <parameter>username</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string
       <parameter><optional>db</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIPLogon</function> 오라클8 DB에 영속적인 접속을 형성하고,
     로그온 한다. 세번째 인수는 로컬 오라클 인스턴스(local Oracle instanace)의
     이름, 또는 tnsnames.ora설정파일의 엔트리(entry) 이름이 될수 있다.
     세번째 인수가 생략되면, PHP는 접속할 오라클 데이터베이스를 결정하기 위해
     환경변수 ORACLE_SID (Oracle instance)나 TWO_TASK(tnsnames.ora)를
     이용한다.
    </para>
    <simpara>
     See also <function>OCILogon</function> and
     <function>OCINLogon</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ocinlogon">
   <refnamediv>
    <refname>OCINLogon</refname>
    <refpurpose>Connect to an Oracle database and log on using a new
    connection. Returns a new session.</refpurpose>
    <refpurpose>오라클 데이터베이스에 접속하고 새로운 접속을 이용해서
    로그온한다. 새로운 세션(session)을 넘겨준다. </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCINLogon</function></funcdef>
      <paramdef>string <parameter>username</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string
       <parameter><optional>db</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINLogon</function> 오라클8 DB에 새로운 접속을 형성하고,
     로그온 한다. 세번째 인수는 로컬 오라클 인스턴스(local Oracle instanace)의
     이름, 또는 tnsnames.ora설정파일의 엔트리(entry) 이름이 될수 있다.
     세번째 인수가 생략되면, PHP는 접속할 오라클 데이터베이스를 결정하기 위해
     환경변수 ORACLE_SID (Oracle instance)나 TWO_TASK(tnsnames.ora)를
     이용한다.
    </para>
    <para>
     <function>OCINLogon</function> forces a new connection.  This
     should be used if you need to isolate a set of transactions.  By
     default, connections are shared at the page level if using
     <function>OCILogon</function> or at the web server process level
     if using <function>OCIPLogon</function>.  If you have multiple
     connections open using <function>OCINLogon</function>, all
     commits and rollbacks apply to the specified connection only.
     <function>OCINLogon</function> 새로운 접속을 강제로 형성한다.
     각 트랜잭션들을 분리할 필요가 있으면 사용해야 할것이다.
     기본적으로, <function>OCILogon</function>함수를 사용하면 접속은
     페이지 레벨에서 분배되어지고, <function>OCIPLogon</function>함수를
     사용하면 웹서버 프로세스 레벨에서 분배되어진다.
     <function>OCINLogon</function>함수로 두개 이상의 접속을 연다면,
     모든 커밋(commits)과 롤백(rollbacks)은 특정 접속에만 적용되어진다.
    </para>
    <para>
     This example demonstrates how the connections are separated.
     <example>
      <title>OCINLogon</title>
      <programlisting>
&lt;?php
print "&lt;HTML>&lt;PRE>";
$db = "";

$c1 = ocilogon("scott","tiger",$db);
$c2 = ocinlogon("scott","tiger",$db);

function create_table($conn)
{ $stmt = ociparse($conn,"create table scott.hallo (test
varchar2(64))");
  ociexecute($stmt);
  echo $conn." created table\n\n";
}

function drop_table($conn)
{ $stmt = ociparse($conn,"drop table scott.hallo");
  ociexecute($stmt);
  echo $conn." dropped table\n\n";
}

function insert_data($conn)
{ $stmt = ociparse($conn,"insert into scott.hallo 
            values('$conn' || ' ' || to_char(sysdate,'DD-MON-YY HH24:MI:SS'))");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." inserted hallo\n\n";
}

function delete_data($conn)
{ $stmt = ociparse($conn,"delete from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." deleted hallo\n\n";
}

function commit($conn)
{ ocicommit($conn);
  echo $conn." committed\n\n";
}

function rollback($conn)
{ ocirollback($conn);
  echo $conn." rollback\n\n";
}

function select_data($conn)
{ $stmt = ociparse($conn,"select * from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn."----selecting\n\n";
  while (ocifetch($stmt))
    echo $conn." &lt;".ociresult($stmt,"TEST").">\n\n";
  echo $conn."----done\n\n";
}

create_table($c1);
insert_data($c1);

select_data($c1);   
select_data($c2);   

rollback($c1);      

select_data($c1);   
select_data($c2);   

insert_data($c2);   
commit($c2);        

select_data($c1);   

delete_data($c1);   
select_data($c1);   
select_data($c2);   
commit($c1);        

select_data($c1);
select_data($c2);


drop_table($c1);
print "&lt;/PRE>&lt;/HTML>";
?></programlisting></example>
    </para>
    <simpara>
     See also <function>OCILogon</function> and
     <function>OCIPLogon</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ocilogoff">
   <refnamediv>
    <refname>OCILogOff</refname>
    <refpurpose>오라클로 부터 접속을 해제한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCILogOff</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCILogOff</function> 오라클 접속을 닫는다.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ociexecute">
   <refnamediv>
    <refname>OCIExecute</refname>
    <refpurpose>SQL 구문(Statement)을 수행한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIExecute</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
      <paramdef>int
       <parameter><optional>mode</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIExecute</function> 미리 해석된 구문(statement)를
     실행한다. (<function>OCIParse</function>함수를 보라.) 선택적인
     인수 <parameter>mode</parameter>는 execution-mode(디폴트는
     OCI_COMMIT_ON_SUCCESS이다)를 지정할 수 있다. 각 구문이 자동적으로
     커밋(commit)되지 않기를 원하면 OCI_DEFAULT로 설정하면 된다. 
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocicommit">
   <refnamediv>
    <refname>OCICommit</refname>
    <refpurpose>미결정된 트랜잭션을 커밋시킨다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCICommit</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCICommit</function> commits all outstanding statements
     for Oracle connection <parameter>connection</parameter>.
     <function>OCICommit</function> 오라클 접속 파라미터
     <parameter>connection</parameter>에 대해서
     미결정된 모든 구문(outstanding statements)을 커밋한다. 
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocirollback">
   <refnamediv>
    <refname>OCIRollback</refname>
    <refpurpose>미결정된 트랜잭션을 롤백한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIRollback</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIRollback</function> rolls back all outstanding
     statements for Oracle connection <parameter>connection</parameter>.
     <function>OCIRollback</function> 오라클 접속 파라미터
     <parameter>connection</parameter>에 대해서
     미결정된 모든 구문(outstanding statements)을 롤백 처리한다.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocinewdescriptor">
   <refnamediv>
    <refname>OCINewDescriptor</refname>
    <refpurpose>
     LOB/FILE의 비어있는 새로운 descriptor를 초기화한다 (LOB 이 기본값이다)
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCINewDescriptor</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
      <paramdef>int
       <parameter><optional>type</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINewDescriptor</function> Allocates storage to hold
     descriptors or LOB locators. Valid values for the valid 
     <parameter>type</parameter> are OCI_D_FILE, OCI_D_LOB, OCI_D_ROWID.
     For LOB descriptors, the methods load, save, and savefile are 
     associated with the descriptor, for BFILE only the load method
     exists. See the second example usage hints.
    </para>
    <example>
     <title>OCINewDescriptor</title>
     <programlisting>
&lt;?php   
    /* This script is designed to be called from a HTML form.
     * It expects $user, $password, $table, $where, and $commitsize
     * to be passed in from the form.  The script then deletes
     * the selected rows using the ROWID and commits after each
     * set of $commitsize rows. (Use with care, there is no rollback)
     */
    $conn = OCILogon($user, $password);
    $stmt = OCIParse($conn,"select rowid from $table $where");
    $rowid = OCINewDescriptor($conn,OCI_D_ROWID);
    OCIDefineByName($stmt,"ROWID",&amp;$rowid);   
    OCIExecute($stmt);
    while ( OCIFetch($stmt) ) {      
       $nrows = OCIRowCount($stmt);
       $delete = OCIParse($conn,"delete from $table where ROWID = :rid");
       OCIBindByName($delete,":rid",&amp;$rowid,-1,OCI_B_ROWID);
       OCIExecute($delete);      
       print "$nrows\n";
       if ( ($nrows % $commitsize) == 0 ) {
           OCICommit($conn);      
       }   
    }
    $nrows = OCIRowCount($stmt);   
    print "$nrows deleted...\n";
    OCIFreeStatement($stmt);  
    OCILogoff($conn);
?>  
     </programlisting>
     <programlisting>
&lt;?php
    /* This script demonstrates file upload to LOB columns
     * The formfield used for this example looks like this
     * &lt;form action="upload.php3" method="post" enctype="multipart/form-data">
     * &lt;input type="file" name="lob_upload">
     * ...
     */
  if(!isset($lob_upload) || $lob_upload == 'none'){
?>
&lt;form action="upload.php3" method="post" enctype="multipart/form-data">
Upload file: &lt;input type="file" name="lob_upload">&lt;br>
&lt;input type="submit" value="Upload"> - &lt;input type="reset">
&lt;/form>
&lt;?php
  } else {
     // $lob_upload contains the temporary filename of the uploaded file
     $conn = OCILogon($user, $password);
     $lob = OCINewDescriptor($conn, OCI_D_LOB);
     $stmt = OCIParse($conn,"insert into $table (id, the_blob) 
               values(my_seq.NEXTVAL, EMPTY_BLOB()) returning the_blob into :the_blob");
     OCIBindByName($stmt, ':the_blob', &amp;$lob, -1, OCI_B_BLOB);
     OCIExecute($stmt);
     if($lob->savefile($lob_upload)){
        OCICommit($conn);
        echo "Blob successfully uploaded\n";
     }else{
        echo "Couldn't upload Blob\n";
     }
     OCIFreeDesc($lob);
     OCIFreeStatement($stmt);
     OCILogoff($conn);
  }
?>
     </programlisting>
    </example>
   </refsect1>
  </refentry>
  
  <refentry id="function.ocirowcount">
   <refnamediv>
    <refname>OCIRowCount</refname>
    <refpurpose>Gets the number of affected rows</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIRowCount</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIRowCount</function> returns the number of rows affected
	 for eg update-statements. This function will not tell you the number
	 of rows that a select will return!</para>
    <para>
     <example>
      <title>OCIRowCount</title>
      <programlisting>
&lt;?php
    print "&lt;HTML>&lt;PRE>";
    $conn = OCILogon("scott","tiger");
    $stmt = OCIParse($conn,"create table emp2 as select * from emp");
    OCIExecute($stmt);
    print OCIRowCount($stmt) . " rows inserted.&lt;BR>";
    OCIFreeStatement($stmt);
    $stmt = OCIParse($conn,"delete from emp2");
    OCIExecute($stmt);
    print OCIRowCount($stmt) . " rows deleted.&lt;BR>";
    OCICommit($conn);
    OCIFreeStatement($stmt);
    $stmt = OCIParse($conn,"drop table emp2");
    OCIExecute($stmt);
    OCIFreeStatement($stmt);
    OCILogOff($conn);
    print "&lt;/PRE>&lt;/HTML>";
?> </programlisting></example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocinumcols">
   <refnamediv>
    <refname>OCINumCols</refname>
    <refpurpose>
     Return the number of result columns in a statement
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCINumCols</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINumCols</function> returns the number of columns in a 
     statement
    </para>
    <example>
     <title>OCINumCols</title>
     <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    while ( OCIFetch($stmt) ) {
        print "\n";   
        $ncols = OCINumCols($stmt);
        for ( $i = 1; $i &lt;= $ncols; $i++ ) {
            $column_name  = OCIColumnName($stmt,$i);
            $column_value = OCIResult($stmt,$i);
            print $column_name . ': ' . $column_value . "\n";
        }
        print "\n";
    }
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
     </programlisting>
    </example>
   </refsect1>
  </refentry>
 
  <refentry id="function.ociresult">
   <refnamediv>
    <refname>OCIResult</refname>
    <refpurpose>Returns column value for fetched row</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>OCIResult</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
      <paramdef>mixed <parameter>column</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIResult</function> returns the data for column 
	 <parameter>column</parameter> in the current row (see 
	 <function>OCIFetch</function>).<function>OCIResult</function> will
	 return everything as strings except for abstract types (ROWIDs,
	 LOBs and FILEs).
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifetch">
   <refnamediv>
    <refname>OCIFetch</refname>
    <refpurpose>Fetches the next row into result-buffer</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFetch</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFetch</function> fetches the next row (for SELECT
     statements) into the internal result-buffer.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifetchinto">
   <refnamediv>
    <refname>OCIFetchInto</refname>
    <refpurpose>Fetches the next row into result-array</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFetchInto</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>array &amp;<parameter>result</parameter></paramdef>
      <paramdef>int
       <parameter><optional>mode</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFetchInto</function> fetches the next row (for SELECT
     statements) into the <parameter>result</parameter> array.
     <function>OCIFetchInto</function> will overwrite the previous
     content of <parameter>result</parameter>. By default 
     <parameter>result</parameter> will contain a one-based array of all
     columns that are not NULL.
    </para>
	<para>
	 The <parameter>mode</parameter> parameter allows you to change the
	 default behaviour. You can specify more than one flag by simply
	 adding them up (eg OCI_ASSOC+OCI_RETURN_NULLS). The known flags
	 are:
     <simplelist>
      <member>
       <literal>OCI_ASSOC</literal> Return an associative array.
      </member>
      <member>
       <literal>OCI_NUM</literal> Return an numbered array starting with
       one. (DEFAULT)
      </member>
      <member>
       <literal>OCI_RETURN_NULLS</literal> Return empty columns.
      </member>
      <member>
       <literal>OCI_RETURN_LOBS</literal> Return the value of a LOB
       instead of the descriptor.
      </member>
     </simplelist>
	</para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifetchstatement">
   <refnamediv>
    <refname>OCIFetchStatement</refname>
    <refpurpose>Fetch all rows of result data into an array.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFetchStatement</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>array &amp;<parameter>variable</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFetchStatement</function> fetches all the rows from a 
     result into a user-defined array.
     <function>OCIFetchStatement</function> returns the number of rows
     fetched. 
    </para>
     <example>
      <title>OCIFetchStatement</title>
      <programlisting>
&lt;?php
/* OCIFetchStatement example mbritton@verinet.com (990624) */

$conn = OCILogon("scott","tiger");

$stmt = OCIParse($conn,"select * from emp");

OCIExecute($stmt);

$nrows = OCIFetchStatement($stmt,$results);
if ( $nrows > 0 ) {
   print "&lt;TABLE BORDER=\"1\">\n";
   print "&lt;TR>\n";
   while ( list( $key, $val ) = each( $results ) ) {
      print "&lt;TH>$key&lt;/TH>\n";
   }
   print "&lt;/TR>\n";
   
   for ( $i = 0; $i &lt; $nrows; $i++ ) {
      reset($results);
      print "&lt;TR>\n";
      while ( $column = each($results) ) {   
         $data = $column['value'];
         print "&lt;TD>$data[$i]&lt;/TD>\n";
      }
      print "&lt;/TR>\n";
   }
   print "&lt;/TABLE>\n";
} else {
   echo "No data found&lt;BR>\n";
}      
print "$nrows Records Selected&lt;BR>\n";
 
OCIFreeStatement($stmt);
OCILogoff($conn);
?>
     </programlisting>
    </example>
   </refsect1>
  </refentry>
  
  <refentry id="function.ocicolumnisnull">
   <refnamediv>
    <refname>OCIColumnIsNULL</refname>
    <refpurpose>test whether a result column is NULL</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIColumnIsNULL</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>mixed <parameter>column</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIColumnIsNULL</function> returns true if the returned
     column <parameter>column</parameter> in the result from the
     statement <parameter>stmt</parameter> is NULL. You can either use
	 the column-number (1-Based) or the column-name for the
	 <parameter>col</parameter> parameter.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocicolumnname">
   <refnamediv>
    <refname>OCIColumnName</refname>
    <refpurpose>Returns the name of a column.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCIColumnName</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>int <parameter>col</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIColumnName</function> returns the name of the column 
      corresponding to the column number (1-based) that is passed in.
    </simpara>
    <para>
     <example>
      <title>OCIColumnName</title>
      <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    print "&lt;TABLE BORDER=\"1\">";
    print "&lt;TR>";
    print "&lt;TH>Name&lt;/TH>";
    print "&lt;TH>Type&lt;/TH>";
    print "&lt;TH>Length&lt;/TH>";
    print "&lt;/TR>";
    $ncols = OCINumCols($stmt);
    for ( $i = 1; $i &lt;= $ncols; $i++ ) {
        $column_name  = OCIColumnName($stmt,$i);
        $column_type  = OCIColumnType($stmt,$i);
        $column_size  = OCIColumnSize($stmt,$i);
        print "&lt;TR>";
        print "&lt;TD>$column_name&lt;/TD>";
        print "&lt;TD>$column_type&lt;/TD>";
        print "&lt;TD>$column_size&lt;/TD>";
        print "&lt;/TR>";
    }
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
      </programlisting>
     </example>
    </para>
    <simpara>
     See also <function>OCINumCols</function>,
     <function>OCIColumnType</function>, 
     and <function>OCIColumnSize</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ocicolumnsize">
   <refnamediv>
    <refname>OCIColumnSize</refname>
    <refpurpose>return result column size</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIColumnSize</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>mixed <parameter>column</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIColumnSize</function> returns the size of the column
     as given by Oracle. You can either use
	 the column-number (1-Based) or the column-name for the
	 <parameter>col</parameter> parameter.
    </para>
    <para>
     <example>
      <title>OCIColumnSize</title>
      <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    print "&lt;TABLE BORDER=\"1\">";
    print "&lt;TR>";
    print "&lt;TH>Name&lt;/TH>";
    print "&lt;TH>Type&lt;/TH>";
    print "&lt;TH>Length&lt;/TH>";
    print "&lt;/TR>";
    $ncols = OCINumCols($stmt);
    for ( $i = 1; $i &lt;= $ncols; $i++ ) {
        $column_name  = OCIColumnName($stmt,$i);
        $column_type  = OCIColumnType($stmt,$i);
        $column_size  = OCIColumnSize($stmt,$i);
        print "&lt;TR>";
        print "&lt;TD>$column_name&lt;/TD>";
        print "&lt;TD>$column_type&lt;/TD>";
        print "&lt;TD>$column_size&lt;/TD>";
        print "&lt;/TR>";
    }
    print "&lt;/TABLE>";
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
      </programlisting>
     </example>
    </para>
    <simpara>
     See also <function>OCINumCols</function>,
     <function>OCIColumnName</function>, and
     <function>OCIColumnSize</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ocicolumntype">
   <refnamediv>
    <refname>OCIColumnType</refname>
    <refpurpose>Returns the data type of a column.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>OCIColumnType</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>int <parameter>col</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIColumnType</function> returns the data type of the
     column corresponding to the column number (1-based) that is passed
     in.
    </simpara>
    <para>
     <example>
      <title>OCIColumnType</title>
      <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    print "&lt;TABLE BORDER=\"1\">";
    print "&lt;TR>";
    print "&lt;TH>Name&lt;/TH>";
    print "&lt;TH>Type&lt;/TH>";
    print "&lt;TH>Length&lt;/TH>";
    print "&lt;/TR>";
    $ncols = OCINumCols($stmt);
    for ( $i = 1; $i &lt;= $ncols; $i++ ) {
        $column_name  = OCIColumnName($stmt,$i);
        $column_type  = OCIColumnType($stmt,$i);
        $column_size  = OCIColumnSize($stmt,$i);
        print "&lt;TR>";
        print "&lt;TD>$column_name&lt;/TD>";
        print "&lt;TD>$column_type&lt;/TD>";
        print "&lt;TD>$column_size&lt;/TD>";
        print "&lt;/TR>";
    }
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
      </programlisting>
     </example>
    </para>
    <simpara>
     See also <function>OCINumCols</function>,
     <function>OCIColumnName</function>, 
     and <function>OCIColumnSize</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ociserverversion">
   <refnamediv>
    <refname>OCIServerVersion</refname>
    <refpurpose>Return a string containing server version
    information.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCIServerVersion</function></funcdef>
      <paramdef>int <parameter>conn</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <example>
      <title>OCIServerVersion</title>
      <programlisting>
&lt;?php
   $conn = OCILogon("scott","tiger");
   print "Server Version: " . OCIServerVersion($conn);
   OCILogOff($conn);
?>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocistatementtype">
   <refnamediv>
    <refname>OCIStatementType</refname>
    <refpurpose>Return the type of an OCI statement.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCIStatementType</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIStatementType</function> returns one of the following
     values:
     <orderedlist>
      <listitem><simpara>			"SELECT"</simpara></listitem>
      <listitem><simpara>			"UPDATE"</simpara></listitem>
      <listitem><simpara>			"DELETE"</simpara></listitem>
      <listitem><simpara>			"INSERT"</simpara></listitem>
      <listitem><simpara>			"CREATE"</simpara></listitem>
      <listitem><simpara>			"DROP"</simpara></listitem>
      <listitem><simpara>			"ALTER"</simpara></listitem>
      <listitem><simpara>			"BEGIN"</simpara></listitem>
      <listitem><simpara>			"DECLARE"</simpara></listitem>
      <listitem><simpara>			"UNKNOWN"</simpara></listitem>
     </orderedlist></para>
    <para>
     <example>
      <title>Code examples</title>
      <programlisting>
&lt;?php
    print "&lt;HTML>&lt;PRE>";
    $conn = OCILogon("scott","tiger");
    $sql  = "delete from emp where deptno = 10";
   
    $stmt = OCIParse($conn,$sql);
    if ( OCIStatementType($stmt) == "DELETE" ) {
        die "You are not allowed to delete from this table&lt;BR>";
    }
   
    OCILogoff($conn);
    print "&lt;/PRE>&lt;/HTML>";
?>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocinewcursor">
   <refnamediv>
    <refname>OCINewCursor</refname>
    <refpurpose>
     Return a new cursor (Statement-Handle) - use to bind ref-cursors.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCINewCursor</function></funcdef>
      <paramdef>int <parameter>conn</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINewCursor</function> allocates a new statement handle
     on the specified connection.
    </para>
    <para>
     <example>
      <title>Using a REF CURSOR from a stored procedure</title>
      <programlisting>
&lt;?php   
// suppose your stored procedure info.output returns a ref cursor in :data

$conn = OCILogon("scott","tiger");
$curs = OCINewCursor($conn);
$stmt = OCIParse($conn,"begin info.output(:data); end;");

ocibindbyname($stmt,"data",&amp;$curs,-1,OCI_B_CURSOR);
ociexecute($stmt);
ociexecute($curs);

while (OCIFetchInto($curs,&amp;$data)) {
    var_dump($data);
}
 
OCIFreeCursor($stmt);
OCIFreeStatement($curs);
OCILogoff($conn);
?>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Using a REF CURSOR in a select statement</title>
      <programlisting>
&lt;?php   
print "&lt;HTML>&lt;BODY>";
$conn = OCILogon("scott","tiger");
$count_cursor = "CURSOR(select count(empno) num_emps from emp " .
                "where emp.deptno = dept.deptno) as EMPCNT from dept";
$stmt = OCIParse($conn,"select deptno,dname,$count_cursor");

ociexecute($stmt);
print "&lt;TABLE BORDER=\"1\">";
print "&lt;TR>";
print "&lt;TH>DEPT NAME&lt;/TH>";
print "&lt;TH>DEPT #&lt;/TH>";
print "&lt;TH># EMPLOYEES&lt;/TH>";
print "&lt;/TR>";

while (OCIFetchInto($stmt,&amp;$data,OCI_ASSOC)) {
    print "&lt;TR>";
    $dname  = $data["DNAME"];
    $deptno = $data["DEPTNO"];
    print "&lt;TD>$dname&lt;/TD>";
    print "&lt;TD>$deptno&lt;/TD>";
    ociexecute($data[ "EMPCNT" ]);
    while (OCIFetchInto($data[ "EMPCNT" ],&amp;$subdata,OCI_ASSOC)) {
        $num_emps = $subdata["NUM_EMPS"];
        print  "&lt;TD>$num_emps&lt;/TD>";
    }
    print "&lt;/TR>";
}
print "&lt;/TABLE>";
print "&lt;/BODY>&lt;/HTML>";
OCIFreeStatement($stmt);
OCILogoff($conn);
?>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifreestatement">
   <refnamediv>
    <refname>OCIFreeStatement</refname>
    <refpurpose>
     Free all resources associated with a statement.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFreeStatement</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFreeStatement</function> returns true if successful,
     or false if unsuccessful.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifreecursor">
   <refnamediv>
    <refname>OCIFreeCursor</refname>
    <refpurpose>
     Free all resources associated with a cursor.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFreeCursor</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFreeCursor</function> returns true if successful, or
     false if unsuccessful.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifreedesc">
   <refnamediv>
    <refname>OCIFreeDesc</refname>
    <refpurpose>Deletes a large object descriptor.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFreeDesc</function></funcdef>
      <paramdef>object <parameter>lob</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFreeDesc</function> returns true if successful, or
     false if unsuccessful.
    </para>
   </refsect1>
  </refentry>
  
  <refentry id="function.ociparse">
   <refnamediv>
    <refname>OCIParse</refname>
    <refpurpose>Parse a query and return a statement</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIParse</function></funcdef>
      <paramdef>int <parameter>conn</parameter></paramdef>
      <paramdef>strint <parameter>query</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIParse</function> parses the
     <parameter>query</parameter> using  <parameter>conn</parameter>. 
     It returns the statement identity if the query is valid, false if
     not. The <parameter>query</parameter> can be any valid SQL
     statement.
    </simpara>
   </refsect1>
  </refentry>
  <refentry id="function.ocierror">
   <refnamediv>
    <refname>OCIError</refname>
    <refpurpose>Return the last error of stmt|conn|global. 
     If no error happened returns false.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>OCIError</function></funcdef>
      <paramdef>int 
       <parameter><optional>stmt|conn|global</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIError</function> returns the last error found.  If
     the optional <parameter>stmt|conn|global</parameter> is not
     provided, the last error encountered is returned.  If no error is
     found, <function>OCIError</function> returns
     false. <function>OCIError</function> returns the error as an
     associative array. In this array, <parameter>code</parameter>
     consists the oracle error code and <parameter>message</parameter>
     the oracle errorstring.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ociinternaldebug">
   <refnamediv>
    <refname>OCIInternalDebug</refname>
    <refpurpose>
     Enables or disables internal debug output.  By default it is
     disabled
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>OCIInternalDebug</function></funcdef>
      <paramdef>int <parameter>onoff</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIInternalDebug</function> enables internal debug
     output.  Set <parameter>onoff</parameter> to 0 to turn debug
     output off, 1 to turn it on.
    </simpara>
   </refsect1>
  </refentry>
 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
