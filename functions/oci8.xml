<?xml version="1.0" encoding="utf-8"?>
 <reference id="ref.oci8">
  <title>오라클 8 함수</title>
  <titleabbrev>OCI8</titleabbrev>
  <partintro>
   <para>
		이 함수들은 Oracle8과 Oracle7 데이터베이스에 접근할 수 있도록 해준다.
		이것은 Oracle8 Call-Interface (OCI8)를 사용한다.
		이 드라이버를 사용하려면 Oracle8 client libraries가 필요하다.
   </para>
   <para>
		이 드라이버는 보통의 PHP Ora_ 드라이버보다 더욱 유연하다. 
		이것은 PHP의 전역, 지역 변수들의 Oracle placeholder로의 binding을 지원하고, 
		full LOB와 FILE, ROWID를 지원하며, user-supplied define variable을 
		사용할 수 있도록 해 준다. 
   </para>
   <para>
		이 드라이버를 사용하기 전에 오라클 유저와 웹서버 유저에게 
		유효한 오라클 환경변수를 적용했는지 확인해야한다. 
		적용시킬 환경변수:
    <itemizedlist>
     <listitem>
      <simpara>
       ORACLE_HOME
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       ORACLE_SID
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       LD_PRELOAD
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       LD_LIBRARY_PATH
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       NLS_LANG
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       ORA_NLS33
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
   <para>
		웹서버 유저에게 환경변수를 적용한후에,
		웹서버 유저(nobody, www)를 오라클 그룹에 추가했는지 확인해야 한다.
   </para>
   <para>
    <example>
     <title>OCI Hints</title>
      <programlisting role="php">
&lt;?php
// by sergo@bacup.ru

// Use option: OCI_DEFAULT for execute command to delay execution
OCIExecute($stmt, OCI_DEFAULT);

// for retrieve data use (after fetch):

$result = OCIResult($stmt, $n);
if (is_object ($result)) $result = $result->load();

// For INSERT or UPDATE statement use:

$sql = "insert into table (field1, field2) values (field1 = 'value',
 field2 = empty_clob()) returning field2 into :field2";
OCIParse($conn, $sql);
$clob = OCINewDescriptor($conn, OCI_D_LOB);
OCIBindByName ($stmt, ":field2", &amp;$clob, -1, OCI_B_CLOB);
OCIExecute($stmt, OCI_DEFAULT);
$clob->save ("some text");

?&gt;
     </programlisting>
    </example>
   </para>
   <para>
		command-line에서 내장 프로시저(stored procedures)를 쓰는것처럼 
		사용이 간편하다.
    <example>
     <title>내장 프로시저(Stored Procedures) 사용하기</title>
      <programlisting role="php">
&lt;?php
// by webmaster@remoterealty.com
$sth = OCIParse ( $dbh, "begin sp_newaddress( :address_id, '$firstname',
 '$lastname', '$company', '$address1', '$address2', '$city', '$state',
 '$postalcode', '$country', :error_code );end;" );

// This calls stored procedure sp_newaddress, with :address_id being an
// in/out variable and :error_code being an out variable. 
// Then you do the binding:

   OCIBindByName ( $sth, ":address_id", $addr_id, 10 );
   OCIBindByName ( $sth, ":error_code", $errorcode, 10 );
   OCIExecute ( $sth );

?&gt;
     </programlisting>
    </example>
   </para>
  </partintro>

  <refentry id="function.ocidefinebyname">
   <refnamediv>
    <refname>OCIDefineByName</refname>
    <refpurpose>
		 SELECT 구문(Statement)을 사용하는 동안 정의단계(define-step)를 위한
     PHP 변수를 할당한다.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIDefineByName</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>string <parameter>Column-Name</parameter></paramdef>
      <paramdef>mixed <parameter>variable</parameter></paramdef>
      <paramdef>int <parameter><optional>type</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIDefineByName</function>함수는 
     페치(fetch)한 컬럼을 사용자정의 변수 에 할당한다.  
     물론, 오라클 유저는 select 구문에서 소문자 컬럼명을  쓸수 있지만,
     <function>OCIDefineByName</function>함수의 
     <parameter>Column-Name</parameter>인수는 반드시 대문자로 적어야 한다.
     select 구문에서 존재하지도 않는 변수를 선언해도, 에러는 발생하지않을것이다!
    </para>
    <para>
     추상 데이터타입(LOB/ROWID/BFILE)을 다룰 때는
     <function>OCINewDescriptor</function>함수를 사용하여
     그 컬럼에 대한 변수영역을 미리 할당해야 한다. 
     <function>OCIBindByName</function>를 보시오.
    </para>
     <example>
      <title>OCIDefineByName</title>
      <programlisting>
&lt;?php
/* OCIDefineByPos example thies@thieso.net (980219) */

$conn = OCILogon("scott","tiger");

$stmt = OCIParse($conn,"select empno, ename from emp");

/* the define MUST be done BEFORE ociexecute! */

OCIDefineByName($stmt,"EMPNO",$empno);
OCIDefineByName($stmt,"ENAME",$ename);

OCIExecute($stmt);

while (OCIFetch($stmt)) {
    echo "empno:".$empno."\n";
    echo "ename:".$ename."\n";
}

OCIFreeStatement($stmt);
OCILogoff($conn);
?>
     </programlisting>
    </example>
   </refsect1>
  </refentry>

  <refentry id="function.ocibindbyname">
   <refnamediv>
    <refname>OCIBindByName</refname>
    <refpurpose>
     오라클 위치보유자(Placeholder)를 PHP 변수에 연계(bind)시킨다.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIBindByName</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>string <parameter>ph_name</parameter></paramdef>
      <paramdef>mixed &amp;<parameter>variable</parameter></paramdef>
      <paramdef>int <parameter>length</parameter></paramdef>
      <paramdef>int <parameter>
       <optional>type</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIBindByName</function>함수는 PHP 변수 
     <parameter>variable</parameter>에 오라클 위치보유자(Oracle placeholder)인
     <parameter>ph_name</parameter>변수에 연계시킨다.
     용도가 입력인지 출력인지는 실시간으로 결정될것이고,
     충분한 저장 공간이 할당될 필요가 있다. <parameter>length</parameter>인수
     는 바인드를 위한 최대 길이를 세팅한다. <parameter>length</parameter>인수를
     -1로 세팅하면 <function>OCIBindByName</function>함수는 
     바인드를 위한 최대 길이를 <parameter>variable</parameter>의 
     현재 길이로 사용할것이다.
    </para>
    <para>
     추상형 데이터타입(LOB/ROWID/BFILE)을 바인드 할 필요가 있다면
     우선은 <function>OCINewDescriptor</function>함수를 사용해서
     변수를 할당해야 한다. 
     <parameter>length</parameter>인수는 추상형 데이터타입
     을 위해 사용되지 않는다. 이때 이 값은 -1이 되어야 한다.
     <parameter>type</parameter>변수는 오라클에서 현재 어떤 종류의
     descriptor가 사용되는지 알려준다. 가능한 값은 다음과 같다:
     OCI_B_FILE (Binary-File), OCI_B_CFILE
     (Character-File), OCI_B_CLOB (Character-LOB), OCI_B_BLOB
     (Binary-LOB) and OCI_B_ROWID (ROWID).
    </para>
    <example>
     <title>OCIDefineByName</title>
     <programlisting>
&lt;?php
/* OCIBindByPos example thies@thieso.net (980221)
  inserts 3 records into emp, and uses the ROWID for updating the 
  records just after the insert.
*/

$conn = OCILogon("scott","tiger");

$stmt = OCIParse($conn,"insert into emp (empno, ename) ".
					   "values (:empno,:ename) ".
					   "returning ROWID into :rid");

$data = array(1111 => "Larry", 2222 => "Bill", 3333 => "Jim");

$rowid = OCINewDescriptor($conn,OCI_D_ROWID);

OCIBindByName($stmt,":empno",&amp;$empno,32);
OCIBindByName($stmt,":ename",&amp;$ename,32);
OCIBindByName($stmt,":rid",&amp;$rowid,-1,OCI_B_ROWID);

$update = OCIParse($conn,"update emp set sal = :sal where ROWID = :rid");
OCIBindByName($update,":rid",&amp;$rowid,-1,OCI_B_ROWID);
OCIBindByName($update,":sal",&amp;$sal,32);

$sal = 10000;

while (list($empno,$ename) = each($data)) {
	OCIExecute($stmt);
	OCIExecute($update);
} 

$rowid->free();

OCIFreeStatement($update);
OCIFreeStatement($stmt);

$stmt = OCIParse($conn,"select * from emp where empno in (1111,2222,3333)");
OCIExecute($stmt);
while (OCIFetchInto($stmt,&amp;$arr,OCI_ASSOC)) {
	var_dump($arr);
}
OCIFreeStatement($stmt);

/* delete our "junk" from the emp table.... */
$stmt = OCIParse($conn,"delete from emp where empno in (1111,2222,3333)");
OCIExecute($stmt);
OCIFreeStatement($stmt);

OCILogoff($conn);
?>
     </programlisting>
    </example>
    <warning>
     <para>
      It is a bad idea to use magic quotes and
      <function>OciBindByName</function> simultaneously as no quoting
      is needed on quoted variables and any quotes magically applied
      will be written into your database as
      <function>OciBindByName</function> is not able to distinguish
      magically added quotings from those added by intention.
     </para> 
    </warning>
   </refsect1>
  </refentry>
  
  <refentry id="function.ocilogon">
   <refnamediv>
    <refname>OCILogon</refname>
    <refpurpose>오라클 접속을 형성한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCILogon</function></funcdef>
      <paramdef>string <parameter>username</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string
       <parameter><optional>db</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCILogon</function> 다른 OCI 함수 호출에 필요한 접속 변수를
     넘겨준다. 세번째 인수는 로컬 오라클 인스턴스(local Oracle instance)이름,
     또는 tnsnames.ora 설정파일에 설정된 엔트리(entry) 이름이 될 수 있다. 
     세번째 인수를 생략할 경우, PHP는 접속할 데이터베이스를 결정하기 위해서 
     환경변수 ORACLE_SID(Oracle instance) 또는 TWO_TASK(tnsnames.ora)를
     이용한다.
    </para>
    <para><function>OCILogon</function> 함수를 사용할때마다 각 접속은 
    페이지 레벨에서 분배되어진다.  이것은 각 페이지에서 열린 모든 
     트랜잭션에 커밋(commits)과 롤백(rollbacks)이 적용되어진다는 것을
     의미한다. 두개이상의 접속을 만들지라도. 
    </para>
    <para>
     아래 예제는 접속이 어떻게 분배되는가를 보여준다.
     <example>
      <title>OCILogon</title>
      <programlisting>
&lt;?php
print "&lt;HTML>&lt;PRE>";
$db = "";

$c1 = ocilogon("scott","tiger",$db);
$c2 = ocilogon("scott","tiger",$db);

function create_table($conn)
{ $stmt = ociparse($conn,"create table scott.hallo (test varchar2(64))");
  ociexecute($stmt);
  echo $conn." created table\n\n";
}

function drop_table($conn)
{ $stmt = ociparse($conn,"drop table scott.hallo");
  ociexecute($stmt);
  echo $conn." dropped table\n\n";
}

function insert_data($conn)
{ $stmt = ociparse($conn,"insert into scott.hallo 
            values('$conn' || ' ' || to_char(sysdate,'DD-MON-YY HH24:MI:SS'))");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." inserted hallo\n\n";
}

function delete_data($conn)
{ $stmt = ociparse($conn,"delete from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." deleted hallo\n\n";
}

function commit($conn)
{ ocicommit($conn);
  echo $conn." committed\n\n";
}

function rollback($conn)
{ ocirollback($conn);
  echo $conn." rollback\n\n";
}

function select_data($conn)
{ $stmt = ociparse($conn,"select * from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn."----selecting\n\n";
  while (ocifetch($stmt))
    echo $conn." &lt;".ociresult($stmt,"TEST").">\n\n";
  echo $conn."----done\n\n";
}

create_table($c1);
insert_data($c1);   // Insert a row using c1
insert_data($c2);   // Insert a row using c2

select_data($c1);   // Results of both inserts are returned
select_data($c2);   

rollback($c1);      // Rollback using c1

select_data($c1);   // Both inserts have been rolled back
select_data($c2);   

insert_data($c2);   // Insert a row using c2
commit($c2);        // commit using c2

select_data($c1);   // result of c2 insert is returned

delete_data($c1);   // delete all rows in table using c1
select_data($c1);   // no rows returned
select_data($c2);   // no rows returned
commit($c1);        // commit using c1

select_data($c1);   // no rows returned
select_data($c2);   // no rows returned


drop_table($c1);
print "&lt;/PRE>&lt;/HTML>";
?></programlisting></example></para>
    <simpara>
     See also <function>OCIPLogon</function> and
     <function>OCINLogon</function>.</simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ociplogon">
   <refnamediv>
    <refname>OCIPLogon</refname>
    <refpurpose>오라클 데이터베이스에 접속하고 영속적 DB 접속
    (persistant connection) 을 이용해서 로그온한다.
    또다른 새로운 세션(session)을 넘겨준다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIPLogon</function></funcdef>
      <paramdef>string <parameter>username</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string
       <parameter><optional>db</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIPLogon</function> 오라클8 DB에 영속적인 접속을 형성하고,
     로그온 한다. 세번째 인수는 로컬 오라클 인스턴스(local Oracle instanace)의
     이름, 또는 tnsnames.ora설정파일의 엔트리(entry) 이름이 될수 있다.
     세번째 인수가 생략되면, PHP는 접속할 오라클 데이터베이스를 결정하기 위해
     환경변수 ORACLE_SID (Oracle instance)나 TWO_TASK(tnsnames.ora)를
     이용한다.
    </para>
    <simpara>
     See also <function>OCILogon</function> and
     <function>OCINLogon</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ocinlogon">
   <refnamediv>
    <refname>OCINLogon</refname>
    <refpurpose>오라클 데이터베이스에 접속하고 새로운 접속을 이용해서
    로그온한다. 새로운 세션(session)을 넘겨준다. </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCINLogon</function></funcdef>
      <paramdef>string <parameter>username</parameter></paramdef>
      <paramdef>string <parameter>password</parameter></paramdef>
      <paramdef>string
       <parameter><optional>db</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINLogon</function> 오라클8 DB에 새로운 접속을 형성하고,
     로그온 한다. 세번째 인수는 로컬 오라클 인스턴스(local Oracle instanace)의
     이름, 또는 tnsnames.ora설정파일의 엔트리(entry) 이름이 될수 있다.
     세번째 인수가 생략되면, PHP는 접속할 오라클 데이터베이스를 결정하기 위해
     환경변수 ORACLE_SID (Oracle instance)나 TWO_TASK(tnsnames.ora)를
     이용한다.
    </para>
    <para>
     <function>OCINLogon</function>함수는 새로운 접속을 강제로 형성한다.
     각 트랜잭션들을 분리할 필요가 있을때 사용해야 할것이다.
     기본적으로, <function>OCILogon</function>함수를 사용하면 접속은
     페이지 레벨에서 분배되어지고, <function>OCIPLogon</function>함수는
     웹서버 프로세스 레벨에서 분배되어진다.
     <function>OCINLogon</function>함수로 두개 이상의 접속을 연다면,
     모든 커밋(commits)과 롤백(rollbacks)은 특정 접속에만 적용되어진다.
    </para>
    <para>
     This example demonstrates how the connections are separated.
     <example>
      <title>OCINLogon</title>
      <programlisting>
&lt;?php
print "&lt;HTML>&lt;PRE>";
$db = "";

$c1 = ocilogon("scott","tiger",$db);
$c2 = ocinlogon("scott","tiger",$db);

function create_table($conn)
{ $stmt = ociparse($conn,"create table scott.hallo (test
varchar2(64))");
  ociexecute($stmt);
  echo $conn." created table\n\n";
}

function drop_table($conn)
{ $stmt = ociparse($conn,"drop table scott.hallo");
  ociexecute($stmt);
  echo $conn." dropped table\n\n";
}

function insert_data($conn)
{ $stmt = ociparse($conn,"insert into scott.hallo 
            values('$conn' || ' ' || to_char(sysdate,'DD-MON-YY HH24:MI:SS'))");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." inserted hallo\n\n";
}

function delete_data($conn)
{ $stmt = ociparse($conn,"delete from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn." deleted hallo\n\n";
}

function commit($conn)
{ ocicommit($conn);
  echo $conn." committed\n\n";
}

function rollback($conn)
{ ocirollback($conn);
  echo $conn." rollback\n\n";
}

function select_data($conn)
{ $stmt = ociparse($conn,"select * from scott.hallo");
  ociexecute($stmt,OCI_DEFAULT);
  echo $conn."----selecting\n\n";
  while (ocifetch($stmt))
    echo $conn." &lt;".ociresult($stmt,"TEST").">\n\n";
  echo $conn."----done\n\n";
}

create_table($c1);
insert_data($c1);

select_data($c1);   
select_data($c2);   

rollback($c1);      

select_data($c1);   
select_data($c2);   

insert_data($c2);   
commit($c2);        

select_data($c1);   

delete_data($c1);   
select_data($c1);   
select_data($c2);   
commit($c1);        

select_data($c1);
select_data($c2);


drop_table($c1);
print "&lt;/PRE>&lt;/HTML>";
?></programlisting></example>
    </para>
    <simpara>
     See also <function>OCILogon</function> and
     <function>OCIPLogon</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ocilogoff">
   <refnamediv>
    <refname>OCILogOff</refname>
    <refpurpose>오라클로 부터 접속을 해제한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCILogOff</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCILogOff</function> 오라클 접속을 닫는다.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ociexecute">
   <refnamediv>
    <refname>OCIExecute</refname>
    <refpurpose>SQL 구문(Statement)을 수행한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIExecute</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
      <paramdef>int
       <parameter><optional>mode</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIExecute</function> 미리 해석된 구문(statement)을
     실행한다. (<function>OCIParse</function>함수를 보라.) 선택적인
     인수 <parameter>mode</parameter>에 execution-mode(디폴트는
     OCI_COMMIT_ON_SUCCESS이다)를 지정할 수 있다. 각 구문이 자동적으로
     커밋(commit)되지 않기를 원하면 OCI_DEFAULT로 설정하면 된다. 
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocicommit">
   <refnamediv>
    <refname>OCICommit</refname>
    <refpurpose>미결정된 트랜잭션을 커밋시킨다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCICommit</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCICommit</function> 오라클 접속 파라미터
     <parameter>connection</parameter>에 대해서
     미결정된 모든 구문(outstanding statements)을 커밋한다. 
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocirollback">
   <refnamediv>
    <refname>OCIRollback</refname>
    <refpurpose>미결정된 트랜잭션을 롤백한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIRollback</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIRollback</function> 오라클 접속 파라미터
     <parameter>connection</parameter>에 대해서
     미결정된 모든 구문(outstanding statements)을 롤백 처리한다.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocinewdescriptor">
   <refnamediv>
    <refname>OCINewDescriptor</refname>
    <refpurpose>
     LOB/FILE의 비어있는 새로운 descriptor를 초기화한다 (LOB 이 기본값이다)
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCINewDescriptor</function></funcdef>
      <paramdef>int <parameter>connection</parameter></paramdef>
      <paramdef>int
       <parameter><optional>type</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINewDescriptor</function>함수는 hold descpriptor나 
     LOB locator를 위한 저장공간을 할당한다.
     유효한 <parameter>type</parameter>값은 OCI_D_FILE, OCI_D_LOB,
     OCI_D_ROWID 이다.
     LOB descriptor를 위해 load, save, savefile 메쏘드가 
     descriptor에 연결되어 있다.  BFILE를 위해서는 load 메쏘드만이 존재한다.
     See the second example usage hints.
    </para>
    <example>
     <title>OCINewDescriptor</title>
     <programlisting>
&lt;?php   
    /* This script is designed to be called from a HTML form.
     * It expects $user, $password, $table, $where, and $commitsize
     * to be passed in from the form.  The script then deletes
     * the selected rows using the ROWID and commits after each
     * set of $commitsize rows. (Use with care, there is no rollback)
     */
    $conn = OCILogon($user, $password);
    $stmt = OCIParse($conn,"select rowid from $table $where");
    $rowid = OCINewDescriptor($conn,OCI_D_ROWID);
    OCIDefineByName($stmt,"ROWID",&amp;$rowid);   
    OCIExecute($stmt);
    while ( OCIFetch($stmt) ) {      
       $nrows = OCIRowCount($stmt);
       $delete = OCIParse($conn,"delete from $table where ROWID = :rid");
       OCIBindByName($delete,":rid",&amp;$rowid,-1,OCI_B_ROWID);
       OCIExecute($delete);      
       print "$nrows\n";
       if ( ($nrows % $commitsize) == 0 ) {
           OCICommit($conn);      
       }   
    }
    $nrows = OCIRowCount($stmt);   
    print "$nrows deleted...\n";
    OCIFreeStatement($stmt);  
    OCILogoff($conn);
?>  
     </programlisting>
     <programlisting>
&lt;?php
    /* This script demonstrates file upload to LOB columns
     * The formfield used for this example looks like this
     * &lt;form action="upload.php3" method="post" enctype="multipart/form-data">
     * &lt;input type="file" name="lob_upload">
     * ...
     */
  if(!isset($lob_upload) || $lob_upload == 'none'){
?>
&lt;form action="upload.php3" method="post" enctype="multipart/form-data">
Upload file: &lt;input type="file" name="lob_upload">&lt;br>
&lt;input type="submit" value="Upload"> - &lt;input type="reset">
&lt;/form>
&lt;?php
  } else {
     // $lob_upload contains the temporary filename of the uploaded file
     $conn = OCILogon($user, $password);
     $lob = OCINewDescriptor($conn, OCI_D_LOB);
     $stmt = OCIParse($conn,"insert into $table (id, the_blob) 
               values(my_seq.NEXTVAL, EMPTY_BLOB()) returning the_blob into :the_blob");
     OCIBindByName($stmt, ':the_blob', &amp;$lob, -1, OCI_B_BLOB);
     OCIExecute($stmt);
     if($lob->savefile($lob_upload)){
        OCICommit($conn);
        echo "Blob successfully uploaded\n";
     }else{
        echo "Couldn't upload Blob\n";
     }
     OCIFreeDesc($lob);
     OCIFreeStatement($stmt);
     OCILogoff($conn);
  }
?>
     </programlisting>
    </example>
   </refsect1>
  </refentry>
  
  <refentry id="function.ocirowcount">
   <refnamediv>
    <refname>OCIRowCount</refname>
    <refpurpose>적용되어진 열의 갯수를 가져온다</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIRowCount</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIRowCount</function>함수는 update같은 구문에 의해 적용되어진
     열의 갯수를 리턴한다. 이 함수는 select 가 리턴할 열의 갯수를
     말해 주진 않을 것이다!</para>
    <para>
     <example>
      <title>OCIRowCount</title>
      <programlisting>
&lt;?php
    print "&lt;HTML>&lt;PRE>";
    $conn = OCILogon("scott","tiger");
    $stmt = OCIParse($conn,"create table emp2 as select * from emp");
    OCIExecute($stmt);
    print OCIRowCount($stmt) . " rows inserted.&lt;BR>";
    OCIFreeStatement($stmt);
    $stmt = OCIParse($conn,"delete from emp2");
    OCIExecute($stmt);
    print OCIRowCount($stmt) . " rows deleted.&lt;BR>";
    OCICommit($conn);
    OCIFreeStatement($stmt);
    $stmt = OCIParse($conn,"drop table emp2");
    OCIExecute($stmt);
    OCIFreeStatement($stmt);
    OCILogOff($conn);
    print "&lt;/PRE>&lt;/HTML>";
?> </programlisting></example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocinumcols">
   <refnamediv>
    <refname>OCINumCols</refname>
    <refpurpose>
     구문 결과값의 컬럼의 갯수를 리턴한다
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCINumCols</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINumCols</function>함수는 구문에서 컬럼의 갯수를 리턴한다.
    </para>
    <example>
     <title>OCINumCols</title>
     <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    while ( OCIFetch($stmt) ) {
        print "\n";   
        $ncols = OCINumCols($stmt);
        for ( $i = 1; $i &lt;= $ncols; $i++ ) {
            $column_name  = OCIColumnName($stmt,$i);
            $column_value = OCIResult($stmt,$i);
            print $column_name . ': ' . $column_value . "\n";
        }
        print "\n";
    }
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
     </programlisting>
    </example>
   </refsect1>
  </refentry>
 
  <refentry id="function.ociresult">
   <refnamediv>
    <refname>OCIResult</refname>
    <refpurpose>페치된 열의 컬럼 값을 리턴한다</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>OCIResult</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
      <paramdef>mixed <parameter>column</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIResult</function>함수는 현재 열의 컬럼
     <parameter>column</parameter>에 대한 데이터를 리턴한다
     (<function>OCIFetch</function>함수를 보라).
   <function>OCIResult</function>함수는 추상형데이터타입(ROWID, LOB, FILE)을
   제외한 문자열같은 모든 것을 리턴할 것이다.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifetch">
   <refnamediv>
    <refname>OCIFetch</refname>
    <refpurpose>결과 버퍼(result-buffer)로 다음 열을 페치한다</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFetch</function></funcdef>
      <paramdef>int <parameter>statement</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFetch</function>함수는 다음 열(SELECT 구문을 위해)을 
     내부 결과 버퍼(internal result-buffer)에 페치한다.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifetchinto">
   <refnamediv>
    <refname>OCIFetchInto</refname>
    <refpurpose>결과 배열(result-array)에 다음 열을 페치한다</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFetchInto</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>array &amp;<parameter>result</parameter></paramdef>
      <paramdef>int
       <parameter><optional>mode</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFetchInto</function>함수는 다음열(SELECT 구문을 위해)을 
     <parameter>result</parameter>배열에 페치한다.
     <function>OCIFetchInto</function>함수는 <parameter>result</parameter>
     변수의 이전값을 덮어 쓸것이다.
     기본적으로 <parameter>result</parameter>변수는 &null;이 아닌 모든 컬럼의
     일차원 배열을 포함할것이다.
    </para>
	<para>
	 The <parameter>mode</parameter> parameter allows you to change the
	 default behaviour. You can specify more than one flag by simply
	 adding them up (eg OCI_ASSOC+OCI_RETURN_NULLS). The known flags
	 are:
	 <parameter>mode</parameter>인수는 이 함수의 기본값을 변화시킨다.
   한개 이상의 플래그를 추가할수있다(OCI_ASSOC+OCI_RETURN_NULLS와 같이).
   알려진 플래그는 다음과 같다:
     <simplelist>
      <member>
       <literal>OCI_ASSOC</literal> 연관배열(associative array)을 리턴한다.
      </member>
      <member>
       <literal>OCI_NUM</literal> 1부터 시작하는 숫자를 갖는 변수를 리턴한다.
       (디폴트)
      </member>
      <member>
       <literal>OCI_RETURN_NULLS</literal> 빈 컬럼을 리턴한다.
      </member>
      <member>
       <literal>OCI_RETURN_LOBS</literal>descriptor 대신에 LOB의 값을 리턴한다.
      </member>
     </simplelist>
	</para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifetchstatement">
   <refnamediv>
    <refname>OCIFetchStatement</refname>
    <refpurpose>배열에 모든 열의 결과 값을 페치한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFetchStatement</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>array &amp;<parameter>variable</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFetchStatement</function>함수는 사용자 정의 배열로
     결과값의 모든 열을 페치한다.
    <function>OCIFetchStatement</function>함수는 페치된 열의 갯수를
    리턴한다. 
    </para>
     <example>
      <title>OCIFetchStatement</title>
      <programlisting>
&lt;?php
/* OCIFetchStatement example mbritton@verinet.com (990624) */

$conn = OCILogon("scott","tiger");

$stmt = OCIParse($conn,"select * from emp");

OCIExecute($stmt);

$nrows = OCIFetchStatement($stmt,$results);
if ( $nrows > 0 ) {
   print "&lt;TABLE BORDER=\"1\">\n";
   print "&lt;TR>\n";
   while ( list( $key, $val ) = each( $results ) ) {
      print "&lt;TH>$key&lt;/TH>\n";
   }
   print "&lt;/TR>\n";
   
   for ( $i = 0; $i &lt; $nrows; $i++ ) {
      reset($results);
      print "&lt;TR>\n";
      while ( $column = each($results) ) {   
         $data = $column['value'];
         print "&lt;TD>$data[$i]&lt;/TD>\n";
      }
      print "&lt;/TR>\n";
   }
   print "&lt;/TABLE>\n";
} else {
   echo "No data found&lt;BR>\n";
}      
print "$nrows Records Selected&lt;BR>\n";
 
OCIFreeStatement($stmt);
OCILogoff($conn);
?>
     </programlisting>
    </example>
   </refsect1>
  </refentry>
  
  <refentry id="function.ocicolumnisnull">
   <refnamediv>
    <refname>OCIColumnIsNULL</refname>
    <refpurpose>결과 컬럼이 널(&null;)인지 테스트한다</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIColumnIsNULL</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>mixed <parameter>column</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIColumnIsNULL</function>함수는
     구문 <parameter>stmt</parameter>의 결과값에서
     리턴된 컬럼 <parameter>column</parameter> 값이 널(&null;)이면
     &true;를 리턴한다.  <parameter>col</parameter> 인수를 위해
     컬럼 숫자(column-number(1-Based))나 컬럼 이름(column-name)을
     사용할 수 있다. 
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocicolumnname">
   <refnamediv>
    <refname>OCIColumnName</refname>
    <refpurpose>컬럼의 이름을 리턴한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCIColumnName</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>int <parameter>col</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIColumnName</function> 함수는 컬럼 숫자(1-based)에
     부합되는 컬럼 이름을 리턴한다.
    </simpara>
    <para>
     <example>
      <title>OCIColumnName</title>
      <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    print "&lt;TABLE BORDER=\"1\">";
    print "&lt;TR>";
    print "&lt;TH>Name&lt;/TH>";
    print "&lt;TH>Type&lt;/TH>";
    print "&lt;TH>Length&lt;/TH>";
    print "&lt;/TR>";
    $ncols = OCINumCols($stmt);
    for ( $i = 1; $i &lt;= $ncols; $i++ ) {
        $column_name  = OCIColumnName($stmt,$i);
        $column_type  = OCIColumnType($stmt,$i);
        $column_size  = OCIColumnSize($stmt,$i);
        print "&lt;TR>";
        print "&lt;TD>$column_name&lt;/TD>";
        print "&lt;TD>$column_type&lt;/TD>";
        print "&lt;TD>$column_size&lt;/TD>";
        print "&lt;/TR>";
    }
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
      </programlisting>
     </example>
    </para>
    <simpara>
     See also <function>OCINumCols</function>,
     <function>OCIColumnType</function>, 
     and <function>OCIColumnSize</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ocicolumnsize">
   <refnamediv>
    <refname>OCIColumnSize</refname>
    <refpurpose>결과 컬럼 사이즈를 리턴한다</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIColumnSize</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>mixed <parameter>column</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIColumnSize</function>함수는 오라클에 의해 주어진
     컬럼의 사이즈를 리턴한다.  <parameter>col</parameter> 인수에는
     컬럼 숫자(column-number (1-Based))나 컬럼 이름을 사용할 수 있다. 
    </para>
    <para>
     <example>
      <title>OCIColumnSize</title>
      <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    print "&lt;TABLE BORDER=\"1\">";
    print "&lt;TR>";
    print "&lt;TH>Name&lt;/TH>";
    print "&lt;TH>Type&lt;/TH>";
    print "&lt;TH>Length&lt;/TH>";
    print "&lt;/TR>";
    $ncols = OCINumCols($stmt);
    for ( $i = 1; $i &lt;= $ncols; $i++ ) {
        $column_name  = OCIColumnName($stmt,$i);
        $column_type  = OCIColumnType($stmt,$i);
        $column_size  = OCIColumnSize($stmt,$i);
        print "&lt;TR>";
        print "&lt;TD>$column_name&lt;/TD>";
        print "&lt;TD>$column_type&lt;/TD>";
        print "&lt;TD>$column_size&lt;/TD>";
        print "&lt;/TR>";
    }
    print "&lt;/TABLE>";
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
      </programlisting>
     </example>
    </para>
    <simpara>
     See also <function>OCINumCols</function>,
     <function>OCIColumnName</function>, and
     <function>OCIColumnSize</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ocicolumntype">
   <refnamediv>
    <refname>OCIColumnType</refname>
    <refpurpose>컬럼의 데이터 타입을 리턴한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>OCIColumnType</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
      <paramdef>int <parameter>col</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIColumnType</function>함수는 컬럼 숫자(1-based)에 부합되는
     컬럼의 데이터 타입을 리턴한다.
    </simpara>
    <para>
     <example>
      <title>OCIColumnType</title>
      <programlisting>
&lt;?php   
    print "&lt;HTML>&lt;PRE>\n";   
    $conn = OCILogon("scott", "tiger");
    $stmt = OCIParse($conn,"select * from emp");
    OCIExecute($stmt);
    print "&lt;TABLE BORDER=\"1\">";
    print "&lt;TR>";
    print "&lt;TH>Name&lt;/TH>";
    print "&lt;TH>Type&lt;/TH>";
    print "&lt;TH>Length&lt;/TH>";
    print "&lt;/TR>";
    $ncols = OCINumCols($stmt);
    for ( $i = 1; $i &lt;= $ncols; $i++ ) {
        $column_name  = OCIColumnName($stmt,$i);
        $column_type  = OCIColumnType($stmt,$i);
        $column_size  = OCIColumnSize($stmt,$i);
        print "&lt;TR>";
        print "&lt;TD>$column_name&lt;/TD>";
        print "&lt;TD>$column_type&lt;/TD>";
        print "&lt;TD>$column_size&lt;/TD>";
        print "&lt;/TR>";
    }
    OCIFreeStatement($stmt);  
    OCILogoff($conn);   
    print "&lt;/PRE>";
    print "&lt;/HTML>\n"; 
?>   
      </programlisting>
     </example>
    </para>
    <simpara>
     See also <function>OCINumCols</function>,
     <function>OCIColumnName</function>, 
     and <function>OCIColumnSize</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ociserverversion">
   <refnamediv>
    <refname>OCIServerVersion</refname>
    <refpurpose>서버 버전 정보를 포함하는 문자열을 리턴한다</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCIServerVersion</function></funcdef>
      <paramdef>int <parameter>conn</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <example>
      <title>OCIServerVersion</title>
      <programlisting>
&lt;?php
   $conn = OCILogon("scott","tiger");
   print "Server Version: " . OCIServerVersion($conn);
   OCILogOff($conn);
?>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocistatementtype">
   <refnamediv>
    <refname>OCIStatementType</refname>
    <refpurpose>OCI 구문(statement)의 타입을 리턴한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>OCIStatementType</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIStatementType</function> 함수는 다음중 하나를 리턴한다:
     <orderedlist>
      <listitem><simpara>			"SELECT"</simpara></listitem>
      <listitem><simpara>			"UPDATE"</simpara></listitem>
      <listitem><simpara>			"DELETE"</simpara></listitem>
      <listitem><simpara>			"INSERT"</simpara></listitem>
      <listitem><simpara>			"CREATE"</simpara></listitem>
      <listitem><simpara>			"DROP"</simpara></listitem>
      <listitem><simpara>			"ALTER"</simpara></listitem>
      <listitem><simpara>			"BEGIN"</simpara></listitem>
      <listitem><simpara>			"DECLARE"</simpara></listitem>
      <listitem><simpara>			"UNKNOWN"</simpara></listitem>
     </orderedlist></para>
    <para>
     <example>
      <title>Code examples</title>
      <programlisting>
&lt;?php
    print "&lt;HTML>&lt;PRE>";
    $conn = OCILogon("scott","tiger");
    $sql  = "delete from emp where deptno = 10";
   
    $stmt = OCIParse($conn,$sql);
    if ( OCIStatementType($stmt) == "DELETE" ) {
        die "You are not allowed to delete from this table&lt;BR>";
    }
   
    OCILogoff($conn);
    print "&lt;/PRE>&lt;/HTML>";
?>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocinewcursor">
   <refnamediv>
    <refname>OCINewCursor</refname>
    <refpurpose>
     Return a new cursor (Statement-Handle) - use to bind ref-cursors.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCINewCursor</function></funcdef>
      <paramdef>int <parameter>conn</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCINewCursor</function> allocates a new statement handle
     on the specified connection.
    </para>
    <para>
     <example>
      <title>Using a REF CURSOR from a stored procedure</title>
      <programlisting>
&lt;?php   
// suppose your stored procedure info.output returns a ref cursor in :data

$conn = OCILogon("scott","tiger");
$curs = OCINewCursor($conn);
$stmt = OCIParse($conn,"begin info.output(:data); end;");

ocibindbyname($stmt,"data",&amp;$curs,-1,OCI_B_CURSOR);
ociexecute($stmt);
ociexecute($curs);

while (OCIFetchInto($curs,&amp;$data)) {
    var_dump($data);
}
 
OCIFreeCursor($stmt);
OCIFreeStatement($curs);
OCILogoff($conn);
?>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Using a REF CURSOR in a select statement</title>
      <programlisting>
&lt;?php   
print "&lt;HTML>&lt;BODY>";
$conn = OCILogon("scott","tiger");
$count_cursor = "CURSOR(select count(empno) num_emps from emp " .
                "where emp.deptno = dept.deptno) as EMPCNT from dept";
$stmt = OCIParse($conn,"select deptno,dname,$count_cursor");

ociexecute($stmt);
print "&lt;TABLE BORDER=\"1\">";
print "&lt;TR>";
print "&lt;TH>DEPT NAME&lt;/TH>";
print "&lt;TH>DEPT #&lt;/TH>";
print "&lt;TH># EMPLOYEES&lt;/TH>";
print "&lt;/TR>";

while (OCIFetchInto($stmt,&amp;$data,OCI_ASSOC)) {
    print "&lt;TR>";
    $dname  = $data["DNAME"];
    $deptno = $data["DEPTNO"];
    print "&lt;TD>$dname&lt;/TD>";
    print "&lt;TD>$deptno&lt;/TD>";
    ociexecute($data[ "EMPCNT" ]);
    while (OCIFetchInto($data[ "EMPCNT" ],&amp;$subdata,OCI_ASSOC)) {
        $num_emps = $subdata["NUM_EMPS"];
        print  "&lt;TD>$num_emps&lt;/TD>";
    }
    print "&lt;/TR>";
}
print "&lt;/TABLE>";
print "&lt;/BODY>&lt;/HTML>";
OCIFreeStatement($stmt);
OCILogoff($conn);
?>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifreestatement">
   <refnamediv>
    <refname>OCIFreeStatement</refname>
    <refpurpose>
     구문(statement)에 연관된 모든 자원을 해제한다.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFreeStatement</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFreeStatement</function> 함수는 자원 해제에 성공하면 &true;를
     리턴하고, 실패하면 &false;를 리턴한다.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifreecursor">
   <refnamediv>
    <refname>OCIFreeCursor</refname>
    <refpurpose>
     커서(cursor)에 연관된 모든 자원을 해제한다.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFreeCursor</function></funcdef>
      <paramdef>int <parameter>stmt</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFreeCursor</function> 함수는 자원 해제에 성공하면 &true;를,
     실패하면 &false;를 리턴한다.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.ocifreedesc">
   <refnamediv>
    <refname>OCIFreeDesc</refname>
    <refpurpose>큰 객체(large object) descriptor를 삭제한다.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIFreeDesc</function></funcdef>
      <paramdef>object <parameter>lob</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>OCIFreeDesc</function>함수는 성공하면 &true;를,
     실패하면 &false;를 리턴한다.
    </para>
   </refsect1>
  </refentry>
  
  <refentry id="function.ociparse">
   <refnamediv>
    <refname>OCIParse</refname>
    <refpurpose>질의(query)를 해석하고 구문(statement)를 리턴한다</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>OCIParse</function></funcdef>
      <paramdef>int <parameter>conn</parameter></paramdef>
      <paramdef>strint <parameter>query</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIParse</function> 함수는 <parameter>conn</parameter>인수를
     사용하는  <parameter>query</parameter>를 해석한다.
     질의(query)가 유효하면 구문(statement)를 리턴한다.
     그렇지 않으면 &false;를 리턴한다.
     <parameter>query</parameter>인수는 어떤 유효한 SQL 구문(statement)
     도 될 수 있다.
    </simpara>
   </refsect1>
  </refentry>
  <refentry id="function.ocierror">
   <refnamediv>
    <refname>OCIError</refname>
    <refpurpose>stmt|conn|global의 제일 마지막 에러를 리턴한다.
    아무 에러도 없었다면 &false;를 리턴한다.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>OCIError</function></funcdef>
      <paramdef>int 
       <parameter><optional>stmt|conn|global</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIError</function>함수는 마지막 에러를 리턴한다.
     선택적 인수<parameter>stmt|conn|global</parameter>가 제공되지않으면,
     제일 마지막에 발행한 에러가 리턴된다.  
     아무 에러도 없었다면 <function>OCIError</function>함수는 &false;를 리턴한다.
     <function>OCIError</function>함수는 연관배열(associative array)로서
     에러를 리턴한다. 이 배열은 오라클 에러 코드인 
     <parameter>code</parameter>인수와 오라클 에러문자열인
     <parameter>message</parameter>인수로 구성된다.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ociinternaldebug">
   <refnamediv>
    <refname>OCIInternalDebug</refname>
    <refpurpose>
     내부 디버그 출력을 활성화 시키거나, 비활성화 시킨다.
     기본값으로 비활성화 되어있다.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>OCIInternalDebug</function></funcdef>
      <paramdef>int <parameter>onoff</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     <function>OCIInternalDebug</function> enables internal debug
     output.  Set <parameter>onoff</parameter> to 0 to turn debug
     output off, 1 to turn it on.
     <function>OCIInternalDebug</function>함수는 내부 디버그 출력을
     활성화 시킨다. 
     <parameter>onoff</parameter>인수를 0으로 놓으면 비활성화 되고,
     1로 놓으면 활성화 된다.
    </simpara>
   </refsect1>
  </refentry>
 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
