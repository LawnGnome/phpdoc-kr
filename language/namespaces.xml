<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.4 Maintainer: acidd15 Status: wip -->
<chapter xml:id="language.namespaces" xmlns="http://docbook.org/ns/docbook"
 version="1.1">
 <title>네임스페이스</title>

 <sect1 xml:id="language.namespaces.rationale">
  <title>네임스페이스에 관하여</title>
  <simpara>
   PHP에서 네임스페이스는 광범위한 PHP 라이브러리들 사이에 발생하는 
   스코프 문제를 해결하기 위해 디자인되었다.
   
   PHP에서는 모든 클래스 정의가 전역이다. 그러므로 라이브러리 
   개발자가 어떤 유틸리티 및 공용 API 클래스 라이브러리를 만들때는 
   다른 라이브러리들에 비슷한 기능이 존재하는지 알아야하고 이런 
   라이브러리들이 함께 사용되기 위해서는 고유한 이름을 지어야만 한다.
   
   보통은 클래스 이름 앞에 고유한 식별 문자열을 덧붙인다 - 예를 들면 데이터베이스 클래스는 
   <classname>My_Library_DB</classname> 등과 같이 할수 있을것이다.
   
   이 경우에는 라이브러리가 늘어날수록, 고유한 문자열을 붙이는것도 늘어나서 매우 긴 이름을 가지게 될것이다.
  </simpara>
  <simpara>
   매번 클래스를 참조할때마다 긴이름을 사용하지않고, 
   그리고 코드를 알아보기 어렵기 만들지 않으면서 
   전역공간을 공유하기 위한 문제를 해결하기 위해 네임스페이스는 개발자가 네이밍 스코프를 관리할수 있도록 허용한다.
  </simpara>
  <simpara>
   네임스페이스는 PHP 5.3.0 버전부터 존재한다. 네임스페이스는 실험단계이고 변경이 될 수 있다.
   </simpara>
 </sect1>

 <sect1 xml:id="language.namespaces.definition">
  <title>네임스페이스 정의</title>
  <para>
   네임스페이스는 <literal>namespace</literal> 키워드를 사용해 정의할 수 있으며, 파일의 맨처음에 위치해야만 한다. 예:
   <example>
    <title>Defining namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
    namespace MyProject::DB;
    
    const CONNECT_OK = 1;

    class Connection { /* ... */ }
    
    function connect() { /* ... */  }
    
?>
]]>
    </programlisting>
   </example>
   동일한 네임스페이스명도 여러 파일안에서 사용할 수 있다.
  </para>
  
  <para>
  네임스페이스는 클래스, 상수 및 함수 정의를 포함할 수 있지만 그 이외의 구조를 가지는 코드는 포함할 수가 없다.
  </para>

  <para>
   네임스페이스 정의는 다음과 같이 할수 있다:
   <itemizedlist>
    <listitem>
     <simpara>
      네임스페이스 내부에 정의한 모든 클래스, 함수와 상수명들 앞에는 자동으로 네임스페이스명이 붙는다.
      클래스명은 항상 풀네임(full name)이며, i.e. 앞의 예제에 있는 클래스를 호출하면 
      <classname>MyProject::DB::Connection</classname> 이 된다.
     </simpara>
    </listitem>
    <listitem>
    <simpara>
     상수 정의는, 네임스페이스명과 상수명으로 조합하여 상수를 만든다.
     클래스 상수와 같이, 네임스페이스 상수도 정적인 값만 가질수 있다.
    </simpara>
    </listitem>
    <listitem>
     <para>
       수식이 되지 않은 클래스명은 (i.e., <literal>::</literal> 를 포함하지 않는) 실행시에 다음순서에 의해 처리가 이루어진다.
      <orderedlist>
       <listitem>
        <simpara>
         클래스는 <link linkend="language.oop5.autoload">autoload</link> 하지 않고, 
         현재 네임스페이스(i.e. 현재 네임스페이스명을 앞에 붙여) 내부를 찾는다. 
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         클래스는 autoload 하지 않고, 전역 네임스페이스 내부를 찾는다.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         현재 네임스페이스에서 autoload 한다.
        </simpara>
       </listitem>
       <listitem>
        <simpara>앞의 단계가 모두 실패하면, 클래스를 찾는것은 실패한다.</simpara>
       </listitem>
      </orderedlist>
     </para>
    </listitem>
    <listitem>
     <para>
      수식이 되지 않은 함수명은 (i.e., <literal>::</literal> 를 포함하지 않는) 첫 실행시 차례대로 현재 네임스페이스와 전역공간에서 찾는다.
     </para>
    </listitem>
    <listitem>
    <para>
     수식이 되지 않은 상수 이름들은 차례대로 현재 내임스페이스와 전역에 정의된 상수들 사이에서 우선적으로 찾는다.
    </para>
    </listitem>
   </itemizedlist>
  완전한 <link linkend="language.namespaces.rules">이름 분석 규칙</link>도 참고하기 바란다.
  </para>
 
 </sect1>

 <sect1 xml:id="language.namespaces.using">
  <title>Using namespaces</title>
  <para>
   Every class and function in a namespace can be referred to by the full name -
   e.g.  <classname>MyProject::DB::Connection</classname> or
   <classname>MyProject::DB::connect</classname> - at any time.
   <example>
    <title>Using namespaced name</title>
    <programlisting role="php">
     <![CDATA[
<?php
    require 'MyProject/Db/Connection.php';
    $x = new MyProject::DB::Connection;
    MyProject::DB::connect();
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   Namespaces can be imported into current context (global or namespace) using
   the <literal>use</literal> operator. The syntax for the operator is:
   <informalexample>
    <programlisting role="php">
     <![CDATA[
<?php
/* ... */
use Some::Name as Othername;

// The simplified form of use:
use Foo::Bar;
// which is the same as :
use Foo::Bar as Bar;
?>
]]>
    </programlisting>
   </informalexample>
   The imported name works as follows: every time that the compiler encounters
   the local name <literal>Othername</literal> (as stand-alone name or as 
   prefix to the longer name separated by <literal>::</literal>) the imported 
   name <literal>Some::Name</literal> is substituted instead.
  </para>

  <para>
   <literal>use</literal> can be used only in global scope, not inside 
   function or class. Imported names have effect from the point of import to 
   the end of the current file. It is recommended to put imports at the 
   beginning of the file to avoid confusion.
  </para>

  <para>
   <example>
    <title>Importing and accessing namespace</title>
    <programlisting role="php">
     <![CDATA[
<?php
    require 'MyProject/Db/Connection.php';
    use MyProject::DB;
    use MyProject::DB::Connection as DbConnection;
    
    $x = new MyProject::DB::Connection();
    $y = new DB::connection();
    $z = new DbConnection();
    DB::connect();
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <note>
    <simpara>
     The import operation is compile-time only, all local names are converted to
     their full equivalents by the compiler. Note that it won't translate names
     in strings, so callbacks can't rely on import rules.
    </simpara>
   </note>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.global">
  <title>Global space</title>
  <para>
   Without any namespace definition, all class and function definitions are
   placed into the global space - as it was in PHP before namespaces were
   supported. Prefixing a name with <literal>::</literal> will specify that 
   the name is required from the global space even in the context of the 
   namespace.
   <example>
    <title>Using global space specification</title>
    <programlisting role="php">
     <![CDATA[
<?php
    namespace A::B::C;
 
 /* This function is A::B::C::fopen */
    function fopen() { 
         /* ... */
         $f = ::fopen(...); // call global fopen
         return $f;
    } 
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.constant">
  <title>__NAMESPACE__</title>
  <para>
   The compile-time constant <constant>__NAMESPACE__</constant> is defined to
   the name of the current namespace. Outside namespace this constant has the 
   value of empty string. This constant is useful when one needs to compose 
   full name for local namespaced names.
   <example>
    <title>Using __NAMESPACE__</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A::B::C;
         
function foo() {
// do stuff
}

set_error_handler(__NAMESPACE__ . "::foo");
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.rules">
  <title>Name resolution rules</title>
  <para>
   Names are resolved following these resolution rules:
   <orderedlist>
    <listitem>
     <simpara>
      All qualified names are translated during compilation according to current
      import rules. In example, if the namespace A::B::C is imported, a call to 
      <code>C::D::e()</code> is translated to <code>A::B::C::D::e()</code>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Unqualified class names are translated during compilation according to current
      import rules (full name substituted for short imported name). In example, if 
      the namespace <literal>A::B::C</literal> is imported, <code>new C()</code> is 
      translated to <code>new A::B::C()</code>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Inside namespace, calls to unqualified functions that are defined in the
      current namespace (and are known at the time the call is parsed) are
      interpreted as calls to these namespace functions, at compile time.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Inside namespace (say A::B), calls to unqualified functions that are not
      defined in current namespace are resolved at run-time. Here is how a 
      call to function <literal>foo()</literal> is resolved:
     </simpara>
      <orderedlist>
       <listitem>
        <simpara>
         It looks for a function from the current namespace:
         <literal>A::B::foo()</literal>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         It tries to find and call the <emphasis>internal</emphasis> function
         <literal>foo()</literal>.
        </simpara>
       </listitem>
      </orderedlist>
      <simpara>
      To call a user defined function in the global namespace, 
      <literal>::foo()</literal> has to be used.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Inside namespace (say <literal>A::B</literal>), calls to unqualified class names are 
      resolved at run-time. Here is how a call to 
      <code>new C()</code> is resolved:
     </simpara>
     <orderedlist>
      <listitem>
       <simpara>
        It looks for a class from the current namespace:
        <literal>A::B::C</literal>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        It tries to find and call the <emphasis>internal</emphasis> class
        <literal>C</literal>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        It attemts to autoload <literal>A::B::C</literal>.
       </simpara>
      </listitem>
     </orderedlist>
     <simpara>
      To reference a user defined class in the global namespace, 
      <code>new ::C()</code> has to be used.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Calls to qualified functions are resolved at run-time. Here is how a call
      to <literal>A::B::foo()</literal> is resolved:
     </simpara>
      <orderedlist>
       <listitem>
        <simpara>
         It looks for a function <literal>foo()</literal> in the namespace
         <literal>A::B</literal>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         It looks for a class <literal>A::B</literal> and call its static 
         method <literal>foo()</literal>. It will autoload the class if 
         necessary.
        </simpara>
       </listitem>
      </orderedlist>
    </listitem>
    <listitem>
     <simpara>
      Qualified class names are resolved in compile-time as class from corresponding
      namespace. For example, <code>new A::B::C()</code> refers to class 
      <classname>C</classname> from namespace <literal>A::B</literal>.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <example>
   <title>Name resolutions illustrated</title>
   <programlisting role="php">
<![CDATA[
<?php
namespace A;

// function calls

foo();      // first tries to call "foo" defined in namespace "A"
            // then calls internal function "foo"

::foo();    // calls function "foo" defined in global scope

// class references

new B();    // first tries to create object of class "B" defined in namespace "A"
            // then creates object of internal class "B"

new ::B();  // creates object of class "B" defined in global scope

// static methods/namespace functions from another namespace

B::foo();   // first tries to call function "foo" from namespace "A::B"
            // then calls method "foo" of internal class "B"

::B::foo(); // first tries to call function "foo" from namespace "B"
            // then calls method "foo" of class "B" from global scope

// static methods/namespace functions of current namespace

A::foo();   // first tries to call function "foo" from namespace "A::A"
            // then tries to call method "foo" of class "A" from namespace "A"
            // then tries to call function "foo" from namespace "A"
            // then calls method "foo" of internal class "A" 

::A::foo(); // first tries to call function "foo" from namespace "A"
            // then calls method "foo" of class "A" from global scope
?>
]]>
   </programlisting>
  </example>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
-->
