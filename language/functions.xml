<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 1.46 Maintainer: progcom Status: ready -->
<!-- CREDITS: fuzzy74 -->
 <chapter id="language.functions">
  <title>함수</title>

  <sect1 id="functions.user-defined">
   <title>사용자 선언 함수</title>
 
   <para>
    다음과 같은 문법을 사용하여 함수를 선언한다:
   </para>
   <para>
    <example>
     <title>함수 사용을 설명하기 위한 가상 코드</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo ($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "예제 함수.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <!--
    
    status of func(const $param) ?
    zend doesn't care at all whether or not you specify it.
    I've never seen it before... what's its use? (or was...)
    
    -->
   <simpara>
    모든 유효 PHP코드는 특정 함수 내에서 뿐만 아니라, 여러 다른 함수나
    <link linkend="keyword.class">class</link>정의 안에서도 
    나타날수있다.
   </simpara>
   <simpara>
    PHP 3에서는 함수가 참조되기 전에 선언되어야 한다. 다음 두 예제 코드와 
    같이 함수가 조건적으로 선언되는 경우를 <emphasis>제외하고</emphasis>
    PHP 4는 이런 제약이 없다. 
   </simpara>
   <para>
    아래 예제 코드와 같이 함수가 조건적으로 선언되면 그 함수가 호출되기
    <emphasis>전에</emphasis> 함수를 선언해야 한다.
   </para>
   <para>
    <example>
     <title>조건적인 함수</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* We can't call foo() from here 
   since it doesn't exist yet,
   but we can call bar() */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}

/* Now we can safely call foo()
   since $makefoo evaluated to true */

if ($makefoo) foo();

function bar() 
{
  echo "I exist immediately upon program start.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>함수 안의 함수</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "foo()를 호출하기 전까지는 존재하지 않습니다.\n";
  }
}

/* bar()를 호출할 수 없습니다.
   아직 존재하지 않습니다. */

foo();

/* 이제 bar()를  호출할 수
   있습니다. foo()를 실행하여
   접근할 수 있게 되었습니다. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    PHP는 함수 오버로딩(overloading)을 지원하지 않으며, 함수 정의를
    해제하거나 이미 선언된 함수를 다시 선언할수 없다.
   </simpara>
   <note>
    <simpara>
     함수명은 선언시에 그 함수를 호출하기 편하게 만들겠지만,
     대소문자 구별을 하지 않는다. 
    </simpara>
   </note>   
   <simpara>
    PHP 3에서 함수는 기본 인자(default argument)를 지원되지만, 
    가변 인자 갯수(variable-length argument)를 지원하지 않는다. (자세한 정보는 
    <link linkend="functions.arguments.default">기본 인자</link>섹션을 참고). 
    PHP 4는 둘 다 지원된다: 자세한 정보는 
    <link linkend="functions.variable-arg-list">가변 인자 목록</link>섹션과
    <function>func_num_args</function>,
    <function>func_get_arg</function>,
    <function>func_get_args</function>함수 레퍼런스를 참고.
   </simpara>

  </sect1>
 
  <sect1 id="functions.arguments">
   <title>함수 인자</title>
 
   <simpara>
    함수 인자를 통해서 함수에 정보를 넘겨줄수 있다. 이런 함수 인자는
    콤마(,)로 구별되는 변수나 상수의 목록이다.
   </simpara> 
   <para>
    PHP는 값에 의한 인자 전달(passing by value) (기본값),
    <link linkend="functions.arguments.by-reference">참조에 의한 전달(passing by reference)</link>, 
    <link linkend="functions.arguments.default">기본 인자 값(default argument value)</link>기능
    을 지원한다. 가변 인자 목록(variable-length argument)은 PHP 4이후 버전에서만 지원된다;
    더 자세한 정보는
    <link linkend="functions.variable-arg-list">가변 인자 목록</link>섹션과
    <function>func_num_args</function>,
    <function>func_get_arg</function>,
    <function>func_get_args</function>함수 레퍼런스를 참고.
    PHP 3에서는 함수에 인자 배열을 넘겨줌으로써 비슷한 효과를 낼수있다:
   </para>
   <para>
    <example>
     <title>함수에 배열 넘겨주기</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
 
   <sect2 id="functions.arguments.by-reference">
    <title>참조에 의한 인자 전달하기</title>
 
    <simpara>
     기본적으로, 함수 인자는 값에 의해 전달된다 (그래서 함수내의 인자값
     이 변경되도 함수 밖에서는 바뀌지 않는다). 함수가 그 인자까지 변경가능하게
     하려면, 참조에 의해 인자를 전달해야 한다.
    </simpara>
    <para>
     함수의 인자를 참조로 전달하려면, 함수 선언시에 엠퍼센트(&amp;)를 인자명 앞에
     덧붙이면 된다: 
    </para>
    <para>
     <example>
      <title>참조에 의해 함수 인자 전달하기</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'and something extra.';
}
$str = 'This is a string, ';
add_some_extra($str);
echo $str;    // outputs 'This is a string, and something extra.'
?>
]]>
      </programlisting>
     </example>
    </para>
 
   </sect2>
 
   <sect2 id="functions.arguments.default">
    <title>기본 인수 값</title>
 
    <para>
     함수는 다음과 같이 스칼라 인자에 대해 C++스타일 기본값으로 지정할수있다:
    </para>
    <para>
     <example>
      <title>함수에 기본 인자 사용하기</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee ($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
echo makecoffee ();
echo makecoffee ("espresso");
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     위 예제 코드의 출력은 다음과 같다:
    </para>
    <para>
     <screen>
Making a cup of cappuccino.
Making a cup of espresso.
     </screen>
    </para>
 
    <simpara>
     기본값은 상수 표현식이 될수 있으나 (예를 들면) 변수나 
     클래스 멤버가 될수는 없다.
    </simpara>
    <para>
     기본 인자를 사용할때에는 모든 기본값은 기본값을 쓰지 않는 인자의
     오른쪽으로 가야 한다; 그렇지 않으면, 기대하던대로 작동하지 않을것이다.
     다음 예제 코드를 참고:
    </para>
    <para>
     <example>
      <title>기본 함수 인자가 잘못 사용된 예</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt ($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt ("raspberry");   // won't work as expected
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     위 예제 코드의 출력은 다음과 같다:
    </para>
    <para>
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Making a bowl of raspberry .
     </screen>
    </para>
    <para>
     위 코드를 아래 코드와 비교하라:
    </para>
    <para>
     <example>
      <title>기본 함수 인자의 정확한 사용예</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt ($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt ("raspberry");   // works as expected
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     이 예제코드의 출력은 다음과 같다:
    </para>
    <para>
     <screen>
Making a bowl of acidophilus raspberry.
     </screen>
    </para>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>가변 인자 목록</title>
	
    <simpara>
     PHP 4는 사용자 선언 함수에서 가변 변수 목록 기능을 지원한다.
     이런 기능은 <function>func_num_args</function>,
     <function>func_get_arg</function>,
     <function>func_get_args</function>함수를 사용하여 손쉽게 사용가능하다.
    </simpara>

    <simpara>
     특별한 문법이 필요하지 않다. 인자 목록은 함수선언부에서 밝혀야하고
     일반 인자와 동일하게 작동할것이다.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 id="functions.returning-values">
   <title>값 돌려주기</title>
 
   <para>
    선택적인 return문을 사용하여 값을 돌려준다. 리스트나 객체를 포함하여
    모든 타입을 돌려줄수있다. 이 구문에서 함수의 수행이 즉시 중단되고
    현재 함수를 호출한 코드줄로 제어를 되돌린다. 
    자세한 정보는 <function>return</function>섹션을 참고할것.
   </para>
   <para>
    <example>
     <title><function>return</function>의 사용예</title>
     <programlisting role="php">
<![CDATA[
<?php
function square ($num)
{
    return $num * $num;
}
echo square (4);   // outputs '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    함수는 여러 값을 돌려줄수 없다. 그러나 리스트를 돌려줌으로서
    비슷한 효과를 볼수있다.
   </para>
   <para>
    <example>
     <title>여러 값을 취하기 위해 배열을 돌려줌</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    함수에서 참조를 돌려주기위해서는, 함수 선언부와 돌려주는 변수값을
    지정하는 곳에서 참조 연산자 &amp; 를 사용해야 한다.
   </para>
   <para>
    <example>
     <title>함수에서 참조 돌려주기</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    참조에 관한 자세한 정보는, <link linkend="language.references">참조 표현</link>섹션을
    참고.
   </simpara>
  </sect1>
 
  <sect1 id="functions.variable-functions">
   <title>가변 함수</title>

   <para>
    PHP는 가변 함수에 대한 개념을 지원한다. 이 용어의 의미는 어떤 변수
    뒤에 괄호가 따라온다면, PHP는 그 변수의 값을 갖는 함수를 찾아서 실행하려
    할것이란 것이다. 이런 개념은 이기능 외에도 콜백과 함수 테이블 등등을 구현할수 
    있게 해준다.
   </para>
   <para>
    가변 함수는 <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function>와 같은 언어 구조와 함께 작동하지 않을것이다.
    이런 구조를 가변 변수로 사용하기 위해서는 보호 함수(wrapper function)를 
    사용할 필요가 있다.
   </para>
   <para>
    <example>
     <title>가변 변수 사용예</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "foo() 안입니다.<br />\n";
}

function bar($arg = '')
{
    echo "bar() 안입니다; 인수는 '$arg'입니다.<br />\n";
}

// echo를 감싸는 래퍼 함수입니다.
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // foo()를 호출합니다.

$func = 'bar';
$func('test');  // bar()를 호출합니다.

$func = 'echoit';
$func('test');  // echoit()을 호출합니다.
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    가변 함수 기능을 사용하여 객체의 메소드를 호출할수 있다.
    <example>
     <title>가변 메소드 사용예</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Bar() 메쏘드를 호출합니다.
    }
    
    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // $foo->Var()를 호출합니다.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    또 <function>call_user_func</function>,
    <link linkend="language.variables.variable">variable variables</link>, 
    <function>function_exists</function>섹션을 참고
   </para>
  </sect1>
  
  <sect1 id="functions.internal">
   <title>내부 (내장) 함수</title>
   
   <para>
    PHP는 많은 함수와 상수로 표준화되었다. 그리고 특정 PHP확장 컴파일이 요구하는 함수
    도 제공한다. 이런 함수는 확장을 컴파일하지 않으면 "undefined function"같은 치명적
    에러 메시지를 출력할 것이다. 예를 들면, <link linkend="ref.image">image</link>함수
    를 사용하기 위해서는 GD 지원이 가능하게 컴파일해야 한다.<function>mysql_connect</function>
    함수를 사용하려면 <link linkend="ref.mysql">MySQL</link>을 지원하도록
    컴파일해야 한다. <link linkend="ref.strings">문자열</link>과 
    <link linkend="ref.var">변수 관련</link> 함수와 같이 PHP의 모든 버전에
    포함되어있는 많은 핵심 함수가 존재한다.
    <function>phpinfo</function>나 <function>get_loaded_extensions</function>함수
    를 호출하면 현재 PHP에 올라간 확장에 어떤것인지 확인할수 있다. 많은 확장이 
    기본값으로 활성화되어있고, PHP 매뉴얼은 여러 확장에 의해 분할되어있다는 것에 
    주의해야 한다. PHP를 셋업하는 방법을 알고 싶다면,
    <link linkend="configuration">설정</link>,  
    <link linkend="installation">설치</link>, 각 확장에 대한 챕터를 보라.
   </para>
   <para>
    함수의 원형(prototype) 읽기와 이해는 <link linkend="about.prototypes">함수 선언 읽는 법</link>
    이라는 매뉴얼 섹션에서 설명한다.
    함수가 돌려주는 것이나 함수가 값으로 직접 전달하는지 이해하는것이 중요하다.
    예를 들면,  
    <function>str_replace</function>함수는 변경된 문자열을 돌려주는 반면에
    <function>usort</function>함수는 실질적으로 변수 자체에 전달하도록 동작한다.
    각 매뉴얼 페이지는 각함수에 대해서 함수 인자와 동작 변경,성공과 실패시 
    돌려주는 값과 유용한 정보에 대해서 나와있다. 이런 중요한 차이점(아직은 희박)
    을 아는 것은 PHP 코드를 정확하게 쓰는데 있어서 매우 결정적인 역할을 한다.
   </para>
   <para>
    더불어 <function>function_exists</function>, 
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function>, 
    <function>dl</function>섹션을 참고할것.
   </para>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
