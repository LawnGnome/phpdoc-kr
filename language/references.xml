<chapter id="language.references">
	<title>References Explained</title>
	<sect1 id="language.references.whatare">
		<title>참조(Reference)란 무엇인가.</title>
		<simpara>  
     참조란 PHP에서 동일한 값을 서로다른 이름으로 access 하는 것을 말한다.
     참조는 C언어 에서의 pointer와는 구별되며, simbol table과 같다고 할수 있다. PHP
     에서는 변수명과 변수값이 다르다는것을 주의 해야 한다. 따라서, 동일한 
     내용이 다른 이름을 가질수 있다. 이는 변수값이 파일이지만 변수명은 
     디렉토리의 요소인 UNIX에서 file과 filename과의 관계와 매우유사하다.
     참조는 UNIX 파일 시스템에서의 hardlinking으로 생각할수 있다.
    </simpara>
	</sect1>
	<sect1 id="language.references.whatdo">
		<title>참조로 할수 있는일은(What References Do)</title>
		<para>
     첫번째로 PHP에서의 참조는 두개의 다른 변수가 동일한 내용(content)를 
     가리킬수 있게 한다. 다시말해 다음과 같은 문장이 있다면
     <informalexample>
				<programlisting role="php">
 $a =&amp; $b 
      </programlisting>
			</informalexample>
     이는
 <varname>$a</varname> 와
<varname>$b</varname>
     는 동일한 변수라고 할수 있다
    <note>
				<para>
					<varname>$a</varname> 와
<varname>$b</varname> 는 이 문장에서는 완벽하게 동일한 변수이지만,
<varname>$a</varname> 가 
      <varname>$b</varname> 를 가리킨다. 이는 다시말해
      <varname>$a</varname> 와
<varname>$b</varname> 는 동일한 위치의 내용(content)를 지칭하고 있다.
      </para>
			</note>
		</para>
		<para>
    함수에서도 변수에서 적용되는 것과 동일하게 적용된다. 
<literal>new</literal>
 라는 연산자를 사용하여 참조를 돌려줄수 있다.(이는 PHP 4.0.4이후 버젼에 적용된다.)
    <informalexample>
				<programlisting role="php">
 $bar =&amp; new fooclass();
 $foo =&amp; find_var ($bar);
     </programlisting>
			</informalexample>
		</para>
		<note>
			<para>
      Unless you use the syntax above, the result of 
      <literal>$bar = new fooclass()</literal> will not be the same
       variable as <literal>$this</literal> in the constructor, meaning
      that if you have used reference to <literal>$this</literal> in
      the constructor, you should use reference assignment, or you get
      two different objects.
      </para>
		</note>
		<para>
    참조로 할수 있는 두번째 것은 참조에 의한 변수의 전달이다. 이는 함수 내에서

    생성된 지역변수와 함수를 호출한 영역의 변수가 동일한 값을 가리키게 할 수 있다.
     아래의 예를 보자
<informalexample>
				<programlisting role="php">
 function foo (&amp;$var) {
     $var++;
 }
 
 $a=5;
 foo ($a);
      </programlisting>
			</informalexample><varname>$a</varname> 의 값은 6이 된다. 이는 함수
<varname>foo</varname> 내의 지역변수

    <varname>$var</varname> 가 함수를 호출한 영역의 변수

    <varname>$a</varname>와 동일한 값(content)을 참조하기 때문이다. 

이에 대한 좀 더 자세한 설명은
<link linkend="language.references.pass">참조에 의한 전달(passing by reference)</link>을 확인해 보기 바란다.
    </para>
		<simpara>    세번째로 참조로서 할수 있는 것은

<link linkend="language.references.return">참조에 의한 return(return by reference)</link>이다.
    </simpara>
	</sect1>
	<sect1 id="language.references.arent">
		<title>참조를 사용함에 있어 주의 해야 할것(What References Are Not)</title>
		<para>
   앞서 말했듯이 참조는 C 언어에서의 pointer와는 다르다. 아래의 예를 보고

   그 결과가 우리가 기대했던 것과 다르다는 것을 안다면 참조(reference)와 

   pointer가 다르다는 것을 알수 있을 것이다.
     <informalexample>
				<programlisting role="php">
 function foo (&amp;$var) {
     $var =&amp; $GLOBALS["baz"];
 }
 foo($bar); 
      </programlisting>
			</informalexample>
		</para>
		<simpara>    위의 예에서 foo함수 내의 변수
<varname>$var</varname> 는 함수를 호출한 영역의 변수

<varname>$bar</varname> 와 동일한 값을 참조하지만 

 곧이어 전역변수

<varname>$GLOBALS["baz"]</varname>가 참조하는 값을 참조하도록 바뀐다.

 이제 이 함수내에서 참조의 메카니즘을 사용하여 함수를 호출한 영역의 변수

<varname>$bar</varname> 를 참조할수 있는 방법이 없다. 따라서 

 함수를 호출한 영역의 변수
<varname>$bar</varname> 는 함수 foo내에서는 무의 미할수 밖에 없다.

 (즉 함수를 호출한 영역의 변수는 함수내의 변수

<varname>$var</varname>에 의해 나타낼수 있지만,
<varname>$var</varname> 는 단지 변수값이지 symbol table에 정의된 변수명이 아니다.)

   </simpara>
	</sect1>
	<sect1 id="language.references.pass">
		<title>참조를 사용한 전달(Passing by Reference)</title>
		<para>  참조(reference)를 사용하여 변수를 함수로 넘겨 전달(pass)할수 있다. 그래서

  함수 내에서 변수의 값을 수정할 수 있다. 다음이 그 예이다.
<informalexample>
				<programlisting role="php">
 function foo (&amp;$var) {
     $var++;
 }
 
 $a=5;
 foo ($a);
 // $a is 6 here
      </programlisting>
			</informalexample>
  함수를 호출할때 참조를 이용하여 변수를 전달(pass)한다는 어떠한 표시도 없다는 것에 주의하자.

  단지 함수를 정의 할때 변수를 참조에 의해 전달 받는다는 표시가 있다. 함수를 정의할때 이를 

  정의 함으로써 참조에 의한 변수 전달이 가능하다.
  </para>
		<para>
  참조에 의해 변수를 넘겨 주는 방법은 다음의 세가지 방법이 있다:
   <itemizedlist>
				<listitem>
					<simpara>      변수에 의한 방법, 즉.

<literal>foo($a)</literal>
					</simpara>
				</listitem>
				<listitem>
					<simpara>      New라는 문장을 이용하는 방법, 즉.
<literal>foo(new foobar())</literal>
					</simpara>
				</listitem>
				<listitem>
					<para>      함수로 부터 넘겨 받는 참조에 의한 방법, 즉.
    <informalexample>
							<programlisting role="php">
 function &amp;bar()
 {
    $a = 5;
    return $a;
 }
 foo(bar());
      </programlisting>
						</informalexample><link linkend="language.references.return">참조에 의한 리턴(returning by reference)</link>의 자세한 설명을 볼수 있다. 
      </para>
				</listitem>
			</itemizedlist>
		</para>
		<para>  위의 나열한 세가지 방법외에는 참조에 의한 전달(pass)을 할수 없다.

  예를 들면 아래 예와 같은 방법으로 참조에 의한 전달은 그 의미가 그 의미가 정확하지 못하다.
<informalexample>
				<programlisting role="php">
 function bar() //  &amp; 가 빠져있음에 유의하자;
 {
         $a = 5;
         return $a;
 }
 foo(bar));
 
 foo($a = 5) // 표현식(Expression)은 변수가 아니다.
 foo(5) // 상수(Constant)는 변수가 아니가.
      </programlisting>
			</informalexample> 이 모든것은 PHP 4.0.4 이상의 버젼에 해당된다.
  </para>
	</sect1>
	<sect1 id="language.references.return">
		<title>참조값 리턴(Returning References)</title>
		<para>
   참조값 리턴은 변수가 어떤값을 참조하는 지를 찾는 함수를 사용할때 

   유용하다. 참조값 리턴의 문법은 다음과 같다
<informalexample>
				<programlisting role="php">
 function &amp;find_var ($param) {
     ...code...
     return $found_var;
 }
 
 $foo =&amp; find_var ($bar);
 $foo->x = 2; 
      </programlisting>
			</informalexample>
  위의 예에서 함수
<varname>find_var</varname>에 의해 리턴된 객체의 속성은 복사되어 지는 것이 아니라 정의(set)되어 진다.

참조의 문법을 사용하지 않고도 가능하다.

</para>
		<note>
			<simpara>
   참조값 리턴 이라는 것을 표시 하기위해 인수전달과는 달리 함수를 호출하는 

   쪽과 호출되어지는 함수 양쪽에
     <literal>&amp;</literal>기호가 있어야 한다. 

이로 인해 일반적으로 함수값의 리턴방식인 복사에 의한 방법이 아니라

 참조를 사용한 리턴이
<varname>$foo</varname>로 가능해 진 것이다.
     </simpara>
		</note>
	</sect1>
	<sect1 id="language.references.unset">
		<title>참조지시 없애기(Unsetting References)</title>
		<para>
   참조된 값을 없애려면 변수명과 그가 가리키는 내용(content)와의 연결고리를 

   끊으면 된다. 이렇게 한다고 해서 변수가 가리키는 내용 자체가 없어진다는 것을

   의미하지는 않는다. 아래의 예를 보자:
    <informalexample>
				<programlisting role="php">
 $a = 1;
 $b =&amp; $a;
 unset ($a); 
      </programlisting>
			</informalexample>   변수
<varname>$b</varname>의 참조된 값을 없앤것이 아니라 단지 변수
<varname>$a</varname>가 지시하는 것을 없앴다. 
    </para>
		<simpara>   다시말해, 이는 Unix 시스템에서 
    <command>unlink</command>를 호출하는 것과 상당히 유사하다.

   </simpara>
	</sect1>
	<sect1 id="language.references.spot">
		<title>Spotting References</title>
		<simpara>
     Many syntax constructs in PHP are implemented via referencing
     mechanisms, so everything told above about reference binding also
     apply to these constructs. Some constructs, like passing and
     returning by-reference, are mentioned above. Other constructs that
     use references are:
    </simpara>
		<sect2 id="references.global">
			<title>
				<literal>global</literal> References</title>
			<para>
      When you declare variable as <command>global $var</command> you
      are in fact creating reference to a global variable. That means,
      this is the same as:
      <informalexample>
					<programlisting role="php">
 $var =&amp; $GLOBALS["var"];
       </programlisting>
				</informalexample>
			</para>
			<simpara>
      That means, for example, that unsetting <varname>$var</varname>
      won't unset global variable.
     </simpara>
		</sect2>
		<sect2 id="references.this">
			<title>
				<literal>$this</literal>
			</title>
			<simpara>
      In an object method, <varname>$this</varname> is always reference
      to the caller object.
     </simpara>
		</sect2>
	</sect1>
</chapter>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
