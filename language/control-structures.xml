<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.11 $ -->
<!-- EN-Revision: 1.78 -->
 <chapter id="control-structures">
  <title>제어 구조</title>

  <simpara>
   모든 PHP 스크립트는 연속적인 구문으로 이루어진다. 하나의 구문은 지정문
   이 될수도 있고, 함수 호출, 반복문, 조건문이 될수 있으며 심지어는 아무
   내용이 없는 빈 문장일수도 있다. 한 구문은 보통 세미콜른(;)으로 끝난다.
   또한 여러개의 구문을 중괄호({,})를 사용하여 하나의 그룹으로 만들어 사용할 수도 있다.
   이 구문 그룹은 그 그룹의 모든 구문들이 하나의 구문인 것처럼 인식된다.
   이 장에서는 여러 가지 구문형태에 대해 알아본다.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    <literal>if</literal>문은 PHP를 포함해서 모든 언어에 있어서 가장
    중요한 기능(feature) 중 하나이다. 이 제어문으로 각각 다른 코드에 대해
    조건적인 수행을 가능케한다. <literal>if</literal>문의 기능은 C와 비슷하다:
    <informalexample>
     <programlisting>
<![CDATA[
if (expr)
    statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <link linkend="language.expressions">표현식에 관한 섹션</link>에서 설명된것처럼
    <replaceable>expr</replaceable>은 논리(Boolean)값으로 취급된다.
    <replaceable>expr</replaceable>이 &true;와 같다면 PHP는 <replaceable>statement</replaceable>를
    수행할것이고, &false;라면 무시될것이다. 무슨값이 &false;인지 알려면
    <link linkend="language.types.boolean.casting">'Converting to boolean'</link>에 관한 섹션을 참고하세요.
   </simpara>
   <para>
    다음 예는 <replaceable>$a</replaceable>가 <replaceable>$b</replaceable>보다
    크다면 <computeroutput>a는 b보다 크다</computeroutput>를 출력할 것입니다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    print "a는 b보다 크다";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    종종 하나 이상의 구문을 조건적으로 수행시켜야 하는 때가 있습니다.
    물론 <literal>if</literal>절로 각 구문을 감싸줄 필요는 없습니다.
    대신, 구문 그룹안에 몇개의 구문을 그룹화할 수 있습니다. 예를 들면,
    이코드는 <replaceable>$a</replaceable>가 <replaceable>$b</replaceable>보다
    크다면 <computeroutput>a는 b보다 크다</computeroutput>라고 출력할것이고,
    <replaceable>$a</replaceable>의 값을 <replaceable>$b</replaceable>로
    지정하게 될것입니다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    print "a는 b보다 크다";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>If</literal>문은 다른 <literal>if</literal>문안에 무한정으로
    내포될수 있습니다. 이와 같은 기능은 프로그램의 여러부분을 조건적으로
    수행하기 위한 유연성을 제공합니다.
   </simpara>
  </sect1>

  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    가끔은 특정 조건에 맞을때 구문 수행하지 않고, 조건과 맞지 않을 때 
    다른 구문을 수행하게 하고 싶은 때가 있다. <literal>else</literal>
    문은 이 목적을 위한 것이다. <literal>if</literal>문 다음의
    <literal>else</literal>문은 <literal>if</literal>구문안의 표현식이
    &false;일때 수행된다. 예를 들면, 다음 코드는 <replaceable>$a</replaceable>가
    <replaceable>$b</replaceable>보다 크다면 <computeroutput>a는 b보다 크다</computeroutput> 
    를 출력할것이고, 그렇지않다면 <computeroutput>a는 b보다 크지 않다</computeroutput>를 
    출력할것이다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    print "a는 b보다 크다";
} else {
    print "a는 b보다 크지 않다";
}
?>
]]>
     </programlisting>
    </informalexample>
    <literal>else</literal>문은 <literal>if</literal>문이 &false;일때만
    수행이 된다. 그리고 그들 모두 &false;값이 될수있다면 <literal>elseif</literal>문
    을 쓸수 있습니다.
    (<link linkend="control-structures.elseif">elseif</link>를 보세요)
   </para>
  </sect1>

  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, as its name suggests, is a combination
    of <literal>if</literal> and <literal>else</literal>.  Like
    <literal>else</literal>, it extends an <literal>if</literal>
    statement to execute a different statement in case the original
    <literal>if</literal> expression evaluates to
    &false;.  However, unlike
    <literal>else</literal>, it will execute that alternative
    expression only if the <literal>elseif</literal> conditional
    expression evaluates to &true;.  For example, the
    following code would display <computeroutput>a is bigger than
    b</computeroutput>, <computeroutput>a equal to b</computeroutput>
    or <computeroutput>a is smaller than b</computeroutput>:

    <literal>elseif</literal>, 이 이름에서 알수 있듯이,
    <literal>if</literal>와 <literal>else</literal>의 조합이다.
    <literal>else</literal>처럼 이 구문은 <literal>if</literal>절 
    다음에 와서 원래 <literal>if</literal>표현식이 &false;와 같은 경우에
    다른 구문을 수행한다. 그러나, <literal>else</literal>와는 달리
    <literal>elseif</literal>조건 표현식이 &true;일 때만 대체 표현식을
    수행할것이다. 예를 들면 다음 코드는 <computeroutput>a는 b보다 크다</computeroutput>,
    <computeroutput>a는 b와 같다</computeroutput>나 
    <computeroutput>a는 b보다 작다</computeroutput>을 출력할것이다.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    print "a는 b보다 크다";
} elseif ($a == $b) {
    print "a는 b와 같다";
} else {
    print "a는 b보다 작다";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    같은 <literal>if</literal>절 안에 몇개의 <literal>elseif</literal>절이
    존재할수 있다. 가장 먼저 &true;가 되는 <literal>elseif</literal>표현식이 
    수행될것이다. PHP에서는 'else if' (두 단어)로 쓸수 있고 'elseif' (한 단어)
    와 방식은 같다. 문장적(syntactic)으로는 다르다 (C에 익숙하다면,
    이것은 같은 방식이다) 그러나 그 둘 모두 완전히 같은 결과를 보여줄것이다.
   </simpara>
   <simpara>
    <literal>elseif</literal>절은 선행 <literal>if</literal> 표현식과
    다른 <literal>elseif</literal>표현식이 &false;이고,
    이 <literal>elseif</literal>표현식이 &true;일때만 수행된다.
   </simpara>
  </sect1>

  <sect1 id="control-structures.alternative-syntax">
   <title>제어 구조의 대체 문법</title>
   <para>
    PHP는 제어 구조를 위해 대체 문법을 제공한다; 즉
    <literal>if</literal>, <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal>, 그리고 <literal>switch</literal>.
    각 경우에 대체 문법의 기본형태는 괄호열기를 콜른 (:)으로 대체하고
    괄호닫기는 각각 <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal>, 또는
    <literal>endswitch;</literal>으로 대체한다.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A는 5와 같다
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    위 예에서는 대체 문법으로 쓰여진 <literal>if</literal>구문안에 "A는 5와 같다"
    HTML 블록이 포함되어있다. 이 HTML 블록은 $a가 5와 같을때만 출력될것이다.
   </simpara>
   <para>
    대체 문법은 <literal>else</literal>와 <literal>elseif</literal>문에도
    적용이 된다. 다음은 <literal>elseif</literal>와 <literal>else</literal>문
    과 같이 있는 <literal>if</literal>문 절의 대체 형태이다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    print "a는 5와 같다";
    print "...";
elseif ($a == 6):
    print "a는 6과 같다";
    print "!!!";
else:
    print "a는 5도 아니고 6도 아니다";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    더 많은 예는<link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>와 <link
    linkend="control-structures.if">if</link>섹션에 있다.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>while</literal>는 PHP에서 제일 간단한 루프형이다.
    C와 똑같은 방식으로 동작한다. <literal>while</literal>문의
    기본적인 형태는 다음과 같다:
    <informalexample>
     <programlisting>
<![CDATA[
while (expr) statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>while</literal>문의 의미는 단순하다. <literal>while</literal>
    표현식이 계속 &true;이면, PHP에게 내포되어있는 구문(들)을 반복 수행하도
    록 하라는것이다. 표현식의 값은 루프의 시작에서 매번 체크가 된다. 그래서
    이 표현식 값이 내포된 구문(들)의 수행동안에 바뀔지라도 반복(iteration)
    의 끝이 아니면 수행은 끝나지 않게 된다.(루프에서 PHP가 구문을 한번수행
    할때 한번 반복(iteration)이다) 시작된지 얼마안되어 <literal>while</literal>표현식이 
    &false;로 판명되면, 내포된 구문(들)은 즉시 수행을 멈출것이다.
   </simpara>
   <para>
    <literal>if</literal>문과 마찬가지로 중괄호나 대체문법을 사용하여
    구문의 그룹을 둘러쌉으로써 <literal>while</literal>루프 안에 여러
    구문을 그룹화할수 있다
    <informalexample>
     <programlisting>
<![CDATA[
while (expr): statement ... endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    다음 예는 모두 동일하다. 둘다 1부터 10까지의 숫자를 출력한다.:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* example 1 */

$i = 1;
while ($i <= 10) {
    print $i++;  /* the printed value would be
                    $i before the increment
                    (post-increment) */
}

/* example 2 */

$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    <literal>do..while</literal>루프는 시작부분이 아니라 각 반복(iteration)의
    끝부분에서 표현식이 참인지 체크한다는것을 제외하고 <literal>while</literal>루프와
    매우 비슷하다. 일반적인 <literal>while</literal>문과의 주요한 차이점은
    <literal>do..while</literal>문의 첫번째 반복이 반드시 수행된다는것이다
    (반복의 끝부분에서 표현식이 참인지 체크한다), 이와 같은 경우는
    일반 <literal>while</literal>루프로 수행시킬수 없을것이다. (while루프에서는
    각 반복의 시작부분에서 표현식이 참인지 체크되고, 시작부터 바로 그 값이 
    &false;이면 그 루프는 즉시 수행을 멈추게 된다)
   </simpara>
   <para>
    다음에 <literal>do..while</literal>루프의 한가지 문법을 보인다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
   print $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     위 루프는 정확히 한번 수행된다. 첫번째 반복(iteration) 이후에 표현식이
     참인지 체크할때, &false;가 되므로 ($i는 0보다 크지 않다) 루프 수행이 멈춘다. 
   </simpara>
   <para>
    고급 C 유저는 <literal>do..while</literal>루프의 다른 사용법에 익숙할것이다.
    즉, <literal>do..while</literal>(0)으로 감싸고, <link linkend="control-structures.break"><literal>break</literal></link>절을
    사용해서 코드 블록의 중간에서 수행을 멈출수 있도록 해준다.
    다음 코드 예는 이런 경우를 보여준다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        print "i는 충분히 크지 않다";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "i is ok";

    /* process i */

} while(0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    이 코드를 바로 또는 전혀 이해할수 없다고 걱정하지 마라.
    이런 '기능'을 사용하지 않고도 일반스크립트나 심지어 굉장한 스크립트를
    작성할 수 있다.
   </simpara>
  </sect1>

  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>for</literal>루프는 PHP에서 제일 복잡한 루프이다.
    C와 똑같은 방식으로 동작한다. <literal>for</literal>루프의 문법은 
    다음과 같다:
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3) statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    첫번째 표현식(<replaceable>expr1</replaceable>)은 루프의 시작에서
    바로 조건없이 평가된다 (수행된다).
   </simpara>
   <simpara>
    각 반복(iteration)의 시작부분에서 <replaceable>expr2</replaceable>이 평
    가된다. 이 표현식이 &true;이면 루프는 계속되고 내포된 구문(들)이
    수행된다. &false;이면, 루프 수행을 멈춘다.
   </simpara>
   <simpara>
    <replaceable>expr3</replaceable>표현식은 각 반복의 끝부분에서
    평가된다 (수행된다).
   </simpara>
   <simpara>
    각 표현식은 비어 있을수 있다. <replaceable>expr2</replaceable>이 비어있다는
    것은 루프가 무제한 수행되어야 한다는 것을 의미한다 (PHP는 C처럼 &true;로 인식)
    이런 기법은 생각처럼 필요없지는 않다. 왜냐 하면 종종 <literal>for</literal>문의 
    표현식 대신에 <link linkend="control-structures.break"><literal>break</literal></link>문으로
    루프를 끝낼 필요가 있기 때문이다.
   </simpara>
   <para>
    다음 예제 코드들을 보세요. 이 코드 모두 1부터 10까지의 숫자를 출력한다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* example 1 */

for ($i = 1; $i <= 10; $i++) {
    print $i;
}

/* example 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    print $i;
}

/* example 3 */

$i = 1;
for (;;) {
    if ($i > 10) {
        break;
    }
    print $i;
    $i++;
}

/* example 4 */

for ($i = 1; $i <= 10; print $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    물론, 첫번째 예제(또는 네번째) 코드가 가장 좋은 방법이다. 그러나 
    <literal>for</literal>루프에서 빈 표현식을 사용해야 하는 경우도 부딪히게
    될것이다.
   </simpara>
   <para>
    PHP는 <literal>for</literal>루프에 대한 대체 "콜른 문법"을 지원한다.
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3): statement; ...; endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
   <para>
    다른 언어에서는 배열이나 해쉬를 편리하게 사용하기위해 <literal>foreach</literal>구문도 
    지원합니다. PHP 3는 이 구조를 지원하지 않지만, PHP 4는 지원합니다.
    (<link linkend="control-structures.foreach">foreach</link>를 보세요)
    PHP 3에서는 <link linkend="control-structures.while">while</link>문과
    <function>list</function>, <function>each</function>함수를 조합하여 같은 
    효과를 볼수있습니다. 이런 예제는 위 함수에 대한 문서를 보세요.
   </para>

  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4(PHP 3는 아님)는 펄이나 다른 언어와 같이 <literal>foreach</literal>구문을 지원합니다.
    이런 구문은 간단하게 배열에 대한 작업을 수행하는 가장 쉬운 기법입니다.
    <literal>foreach</literal>는 배열에서만 작동하고 다른 데이터형을 갖는 변수나
    초기화되지 않은 변수에 대해서 이 구문을 사용하려한다면 에러 메시지를 만날것입니다.
    이 구문은 두가지 문법이 있습니다; 두번째보다는 첫번째문법이 더 유용한 사용법입니다:
    <informalexample>
     <programlisting>
<![CDATA[
foreach (array_expression as $value) statement
foreach (array_expression as $key => $value) statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    첫번째 형태는 <literal>array_expression</literal>에서 주어진 배열에
    대해 루프를 돈다. 각 루프에서 현재 배열요소(element)의 값은 <literal>$value</literal>
    로 지정되고 내부적인 배열 포인터는 하나씩 이동하게 된다 (그래서
    다음 루프에서 다음 배열 요소를 보게 될것이다)
   </simpara>
   <simpara>
    두번째 루프도 같은 일을 한다. 단 현재 배열요소의 키(key)값은
    각 루프의 <literal>$key</literal>변수로 지정된다.
   </simpara>
   <para>
    <note>
     <para>
      <literal>foreach</literal>문이 처음 실행할때, 내부적인 배열 포인터는
      자동적으로 배열의 첫번째 요소(element)로 리셋된다. 따라서 
      <literal>foreach</literal>절 이전에 <function>reset</function>함수를
      호출할 필요는 없다.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal>는 특정 배열의 복사본에 작용하는것이며 
      배열 자체를 직접 건드리지 않는다. 따라서, 배열 포인터는 <function>each</function>함수
      에 의해 변경이 되는것이 아니다. 넘어온 배열요소에 대한 변화는 원래 
      배열에는 영향을 주지 않는다. 하지만, 원래 배열의 내부적 포인터는
      배열 처리에 의해 <emphasis>이동한다</emphasis>. foreach루프는 
      완료될때까지 루프를 돌고, 배열의 내부적 포인터는 배열 끝을 가리키게된다.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal>는 '@'를 사용해서 에러메시지를 출력하지 못하도록
      할수는 없다.
     </para>
    </note>
   </para>
   <para>
    다음 예는 기능적으로 동일하다는것을 알 필요가 있다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("one", "two", "three");
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Value: $value<br>\n";
}

foreach ($arr as $value) {
    echo "Value: $value<br>\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    다음 예도 기능적으로 동일하다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Key: $key; Value: $value<br>\n";
}

foreach ($arr as $key => $value) {
    echo "Key: $key; Value: $value<br>\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    더 많은 예제 코드들이 사용법에 대해서 설명해준다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* foreach example 1: value only */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
   print "Current value of \$a: $v.\n";
}

/* foreach example 2: value (with key printed for illustration) */

$a = array (1, 2, 3, 17);

$i = 0; /* for illustrative purposes only */

foreach ($a as $v) {
    print "\$a[$i] => $v.\n";
    $i++;
}

/* foreach example 3: key and value */

$a = array (
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "seventeen" => 17
);

foreach ($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}

/* foreach example 4: multi-dimensional arrays */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* foreach example 5: dynamic arrays */

foreach (array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal>는 현재 <literal>for</literal>, <literal>foreach</literal>
    <literal>while</literal>, <literal>do..while</literal> 또는
    <literal>switch</literal>절의 수행을 멈춘다.
   </simpara>
   <simpara>
    <literal>break</literal>는 숫자 인자 옵션을 허용함으로써
    내포된 구문구조의 깊이를 표시하고 거기서 빠져나올수 있게 해준다.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array ('one', 'two', 'three', 'four', 'stop', 'five');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* You could also write 'break 1;' here. */
    }
    echo "$val<br>\n";
}

/* Using the optional argument. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5<br>\n";
        break 1;  /* Exit only the switch. */
    case 10:
        echo "At 10; quitting<br>\n";
        break 2;  /* Exit the switch and the while. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal>는 루프 구조의 절안에서 현재 루프 반복의 
    나머지부분을 건너뛰게 하고 다음 반복의 시작으로 실행을 속행시켜준다.
   </simpara>
   <note>
    <simpara>
     PHP에서 <link linkend="control-structures.switch">switch</link>구문은 
     <literal>continue</literal>에 의해 루프 구조로 사용할수 있다는것을 참고할것.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal>는 숫자 인자 옵션을 사용하여 루프의 깊이를
    표시할수 있고, 루프의 끝까지 건너뛸수 있다.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list ($key, $value) = each ($arr)) {
    if (!($key % 2)) { // skip odd members
        continue;
    }
    do_something_odd ($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Outer<br>\n";
    while (1) {
        echo "&nbsp;&nbsp;Middle<br>\n";
        while (1) {
            echo "&nbsp;&nbsp;Inner<br>\n";
            continue 3;
        }
        echo "This never gets output.<br>\n";
    }
    echo "Neither does this.<br>\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
  </sect1>

  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal>구문은 연속적인 같은 표현식을 갖는 
    연속적인 IF구문과 비슷하다. 많은 경우, 하나의 변수(또는 표현식)으로
    다른 많은 값과 비교할 필요가 있으며, 그 값이 동일한 코드의 파편들을
    수행할 필요가 생기게 된다. 정확히 이런 목적을 위해 <literal>switch</literal>구문이 
    사용된다.
   </simpara>
   <note>
    <simpara>
     다른 언어와는 달리 <link linkend="control-structures.continue">continue</link>문은 
     switch문에서 사용할수 있고, <literal>break</literal>문과 비슷하게 동작한다.
     루프 내에 switch문을 포함하고 있고 바깥 루프의 다음 반복문으로 진행하고 싶다면
     <literal>continue 2</literal>를 사용한다.
    </simpara>
   </note>
   <para>
    다음 예제 코드들은 같은 일을 서로 다르게 표현한 것이다. 하나는
    <literal>if</literal>문을 연속적으로 사용한것이고, 다른 것은
    <literal>switch</literal>문을 사용하고 있다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    print "i equals 0";
} elseif ($i == 1) {
    print "i equals 1";
} elseif ($i == 2) {
    print "i equals 2";
}

switch ($i) {
    case 0:
        print "i equals 0";
        break;
    case 1:
        print "i equals 1";
        break;
    case 2:
        print "i equals 2";
        break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    실수하지 않기 위해 <literal>switch</literal>문이 어떻게 동작하는지
    이해할 필요가 있다. <literal>switch</literal>문은 한줄씩 수행된다
    (실제는, 한구문씩). 처음에는 아무 코드도 수행되지 않는다. 오직
    값을 갖는 <literal>case</literal>문이 발견될때에만 구문을 수행하기 
    시작한다. PHP는 <literal>switch</literal>블록의 끝부분이 될때까지,
    또는 <literal>break</literal>문와 첫번째 조우를 할때까지
    구문을 계속 수행해 간다. 만약 각 case 구문 목록의 끝부분에
    <literal>break</literal>문을 쓰지않는다면 PHP는 다음 case문으로 계속
    진행하게 된다. 예를 들면 다음과 같다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
        print "i는 0과 같다";
    case 1:
        print "i는 1과 같다";
    case 2:
        print "i는 2와 같다";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    이 예제 코드에서, $i가 0과 같으면, PHP는 모든 print구문을 수행할것이다!
    $i가 1이면 밑의 두 print구문을 수행한다. $i가 2일때만 원하는 동작
    ('i는 2와 같다')을 보게 될것이다. 따라서 <literal>break</literal>문을 
    반드시 빠뜨려서는 안된다. (어떤 경우에는 일부러 빠뜨릴수 있을지 모르지만)
   </simpara>
   <simpara>
    <literal>switch</literal>구문에서, 조건문은 오직 한번만 평가되고
    각 <literal>case</literal>문에서 결과가 비교되어진다.
    <literal>elseif</literal>문에서는 조건문은 다시 평가된다. 조건문이 
    한번 이상의 비교가 필요한 복잡한 것이거나 거친(tight) 루프안에 있다면
    <literal>switch</literal>문 좀 더 빠를것이다.
   </simpara>
   <para>
    case에 대한 구문 목록은 비어있을수 있다. 이것은 단순히 다음 case문으로
    제어권을 넘겨줄 뿐이다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "i is less than 3 but not negative";
        break;
    case 3:
        print "i is 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    특별한 case가 바로 <literal>default</literal> case문이다. 이것은 다른 case문과
    모두 조건이 맞지 않을때의 경우를 위한것이고, <literal>case</literal>구문의 
    마지막에 위치해야 한다. 예제 코드는 다음과 같다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
        print "i는 0과 같다";
        break;
    case 1:
        print "i는 1과 같다";
        break;
    case 2:
        print "i는 2와 같다";
        break;
    default:
        print "i는 0, 1, 2 어느것도 아니다";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>case</literal>의 표현식은 정수나 부동소수점 수와 문자열같은
    단순형으로 평가되는 어던 표현식도 될수 있다. 여기에 단순형으로
    재참조(dereference)되지 않는 배열이나 객체를 사용할수는 없다.
   </para>
   <para>
    switch문을 위한 제어 구조의 대체 문법이 지원된다. 더 자세한 정보는
    <link linkend="control-structures.alternative-syntax">제어 구조의 대체 문법</link>을 참고.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
    case 0:
        print "i equals 0";
        break;
    case 1:
        print "i equals 1";
        break;
    case 2:
        print "i equals 2";
        break;
    default:
        print "i is not equal to 0, 1 or 2";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    <literal>declare</literal>구문은 코드 블록의 수행 디렉티브(directive)를
    활성화하기 위해 사용된다.
    <literal>declare</literal>문법은 다른 흐름 제어 구조의 문법과
    비슷하다:
    <informalexample>
     <programlisting>
<![CDATA[
declare (directive) statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>directive</literal>부분은 <literal>declare</literal>블록의 동작이
    활성화되도록 해준다. 현재는 오직 한 디렉티브만 인식된다:
    <literal>ticks</literal> 디렉티브. (더 자세한 정보는
    <link linkend="control-structures.declare.ticks">ticks</link> 디렉티브를 볼것)
   </para>
   <para>
    <literal>declare</literal>블록의 <literal>statement</literal>부분이 수행될것이다
    - 어떻게 수행이 되고 수행중에 어떤 사이드 이펙트가 발생할지는 
    <literal>directive</literal>블록의 디렉티브에 달려있다.
   </para>
   <para>
    <literal>declare</literal> 구문은 전역 유효영역 안에서 사용할수 있다.
    그래서 모든 코드가 그 디렉티브에 영향을 받는다. 
    <informalexample>
     <programlisting>
<![CDATA[
<?php
// these are the same:

// you can use this:
declare(ticks=1) {
    // entire script here
}

// or you can use this:
declare(ticks=1);
// entire script here
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 id="control-structures.declare.ticks">
    <title>틱(Ticks)</title>
    <para>A tick is an event that occurs for every
    <replaceable>N</replaceable> low-level statements executed
    by the parser within the <literal>declare</literal> block.
    The value for <replaceable>N</replaceable> is specified
    using <literal>ticks=<replaceable>N</replaceable></literal>
    within the <literal>declare</literal> blocks's
    <literal>directive</literal> section.
   </para>
   <para>
    The event(s) that occur on each tick are specified using the
    <function>register_tick_function</function>. See the example 
    below for more details. Note that more than one event can occur
    for each tick.
   </para>
   <para>
    <example>
     <title>Profile a section of PHP code</title>
     <programlisting role="php">
<![CDATA[
<?php
// A function that records the time when it is called
function profile ($dump = FALSE)
{
    static $profile;

    // Return the times stored in profile, then erase it
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }

    $profile[] = microtime ();
}

// Set up a tick handler
register_tick_function("profile");

// Initialize the function before the declare block
profile ();

// Run a block of code, throw a tick every 2nd statement
declare (ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text (md5($x), md5($x*$x)), "<br />;";
    }
}

// Display the data stored in the profiler
print_r (profile (TRUE));
?>
]]>
     </programlisting>
    </example>
    The example profiles the PHP code within the 'declare'
    block, recording the time at which every second low-level
    statement in the block was executed. This information can
    then be used to find the slow areas within particular
    segments of code. This process can be performed using other
    methods: using ticks is more convenient and easier to
    implement.
   </para>
   <simpara>
    Ticks are well suited for debugging, implementing simple
    multitasking, backgrounded I/O and many other tasks.
   </simpara>
   <simpara>
    See also <function>register_tick_function</function> and
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>

  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    If called from within a function, the <function>return</function>
    statement immediately ends execution of the current function, and
    returns its argument as the value of the function
    call. <function>return</function> will also end the execution of
    an <function>eval</function> statement or script file.
   </simpara>
   <simpara>
    If called from the global scope, then execution of the current
    script file is ended. If the current script file was
    <function>include</function>ed or <function>require</function>ed,
    then control is passed back to the calling file. Furthermore, if
    the current script file was <function>include</function>ed, then
    the value given to <function>return</function> will be returned as
    the value of the <function>include</function> call. If
    <function>return</function> is called from within the main script
    file, then script execution ends. If the current script file was
    named by the <link
    linkend="ini.auto-prepend-file">auto_prepend_file</link> or <link
    linkend="ini.auto-append-file">auto_append_file</link>
    configuration options in &php.ini;, 
    then that script file's execution is ended.
   </simpara>
   <simpara>For more information, see <link
   linkend="functions.returning-values">Returning values</link>.
   </simpara>
   <para>
    <note>
     <simpara>
      Note that since <function>return</function> is a language
      construct and not a function, the parentheses surrounding its
      arguments are <emphasis>not</emphasis> required--in fact, it is
      more common to leave them out than to use them, although it
      doesn't matter one way or the other.
     </simpara>
    </note>
   </para>
  </sect1>


 <sect1 id="function.require">
   <title><function>require</function></title>

   <simpara>
    The <function>require</function> statement includes and evaluates
    the specific file.
   </simpara>
   <simpara>
     <function>require</function> includes and evaluates a specific file.  
     Detailed information on how this inclusion works is described in the 
     documentation for <function>include</function>.
   </simpara>
   <simpara>
     <function>require</function> and <function>include</function> 
     are identical in every way except how they handle failure.  
     <function>include</function> produces a 
     <link linkend="internal.e-warning">Warning</link> while 
     <function>require</function> results in a <link linkend="internal.e-error">
     Fatal Error</link>.  In other words, don't hesitate to use 
     <function>require</function> if you want a missing file to halt processing 
     of the page.  <function>include</function> does not behave this way, the
     script will continue regardless.  Be sure to have an appropriate
     <link linkend="ini.include-path">include_path</link> setting as well.
   </simpara>
   <para>
    <example>
     <title>Basic <function>require</function> examples</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    See the <function>include</function> documentation for more examples.
   </simpara>
   <para>
    <note>
     <simpara>
      Prior to PHP 4.0.2, the following applies: <function>require</function>
      will always attempt to read the target file, even if the line it's on
      never executes.  The conditional statement won't affect
      <function>require</function>. However, if the line on which the
      <function>require</function> occurs is not executed, neither will any of
      the code in the target file be executed.  Similarly, looping structures
      do not affect the behaviour of <function>require</function>. Although
      the code contained in the target file is still subject to the loop, the
      <function>require</function> itself happens only once.
     </simpara>
    </note>
   </para>
   
   &note.language-construct;
   
   &warn.no-win32-fopen-wrapper;
   
   <simpara>
    See also <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>, 
    <function>file</function>, <function>readfile</function>, 
    <function>virtual</function> and <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    The <function>include</function> statement includes and evaluates
    the specified file.
   </simpara>
   <simpara>
     The documentation below also applies to <function>require</function>.
     The two constructs are identical in every way except how they handle
     failure.  <function>include</function> produces a 
     <link linkend="internal.e-warning">Warning</link> while <function>require</function>
     results in a <link linkend="internal.e-error">Fatal Error</link>.
     In other words, use <function>require</function> if you want 
     a missing file to halt processing of the page.  <function>include</function> does 
     not behave this way, the script will continue regardless.  Be sure to have an 
     appropriate <link linkend="ini.include-path">include_path</link> setting as well.
   </simpara>
   <simpara>
     When a file is included, the code it contains inherits the
     <link linkend="language.variables.scope">variable scope</link> of the
     line on which the include occurs.  Any variables available at that line
     in the calling file will be available within the called file, from that
     point forward.
   </simpara>
   <para>
     <example>
      <title>Basic <function>include</function> example</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     If the include occurs inside a function within the calling file,
     then all of the code contained in the called file will behave as
     though it had been defined inside that function.  So, it will follow
     the variable scope of that function.
   </simpara>
   <para>
     <example>
     <title>Including within functions</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php is in the scope of foo() so     *
 * $fruit is NOT available outside of this  *
 * scope.  $color is because we declared it *
 * as global.                               */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     When a file is included, parsing drops out of PHP mode and
     into HTML mode at the beginning of the target file, and resumes
     again at the end.  For this reason, any code inside the target
     file which should be executed as PHP code must be enclosed within
     <link linkend="language.basic-syntax.phpmode">valid PHP start
     and end tags</link>.
   </simpara>
   <simpara>
     If "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
     are enabled in PHP (which they are in the default configuration),
     you can specify the file to be included using an URL (via HTTP or
     other supported wrapper - see <xref linkend="wrappers"/> for a list
     of protocols) instead of a local pathname.  If the target server interprets
     the target file as PHP code, variables may be passed to the included
     file using an URL request string as used with HTTP GET.  This is
     not strictly speaking the same thing as including the file and having
     it inherit the parent file's variable scope; the script is actually
     being run on the remote server and the result is then being
     included into the local script.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title><function>include</function> through HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* This example assumes that www.example.com is configured to parse .php
 * files and not .txt files. Also, 'Works' here means that the variables
 * $foo and $bar are available within the included file. */

// Won't work; file.txt wasn't handled by www.example.com as PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Won't work; looks for a file named 'file.php?foo=1&bar=2' on the
// local filesystem.
include 'file.php?foo=1&bar=2';

// Works.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Works.
include 'file.php';  // Works.

?>
]]>
     </programlisting>
    </example>
    See also <link linkend="features.remote-files">Remote files</link>,
    <function>fopen</function> and <function>file</function> for related 
    information.
   </para>
   <para>
     Because <function>include</function> and <function>require</function>
     are special language constructs, you must enclose them within a statement
     block if it's inside a conditional block.
   </para>
   <para>
    <example>
     <title>include() and conditional blocks</title>
     <programlisting role="php">
<![CDATA[
<?php

// This is WRONG and will not work as desired.
if ($condition)
    include $file;
else
    include $other;


// This is CORRECT.
if ($condition) {
    include $file;
} else {
    include $other;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Handling Returns: It is possible to execute a <function>return</function> 
    statement inside an included file in order to terminate processing in that 
    file and return to the script which called it.  Also, it's possible to return 
    values from included files.  You can take the value of the include call as 
    you would a normal function.
   </simpara>
   <para>
    <note>
     <simpara>
      In PHP 3, the return may not appear inside a block unless it's
      a function block, in which case the <function>return</function> applies 
      to that function and not the whole file.
     </simpara>
    </note>
   </para>
   <para>
    <example>
     <title><function>include</function> and the <function>return</function> statement</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // prints 'PHP'

$bar = include 'noreturn.php';

echo $bar; // prints 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> is the value <literal>1</literal> because the include 
    was successful.  Notice the difference between the above examples.  The first uses 
    <function>return</function> within the included file while the other does not.  
    A few other ways to "include" files into variables are with 
    <function>fopen</function>, <function>file</function> or by using 
    <function>include</function> along with 
    <link linkend="ref.outcontrol">Output Control Functions</link>.
   </simpara>
   
   &note.language-construct;

   <simpara>
    See also <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>, and
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
 </sect1>

 <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    The <function>require_once</function> statement includes and evaluates
    the specified file during the execution of the script.
    This is a behavior similar to the <function>require</function> statement,
    with the only difference being that if the code from a file has already
    been included, it will not be included again.  See the documentation for
    <function>require</function> for more information on how this statement 
    works.
   </para>
   <para>
    <function>require_once</function> should be used in cases where
    the same file might be included and evaluated more than once during a
    particular execution of a script, and you want to be sure that it is
    included exactly once to avoid problems with function redefinitions,
    variable value reassignments, etc.
   </para>
   <para>
     For examples on using <function>require_once</function> and
     <function>include_once</function>, look at the 
     <ulink url="&url.php.pear;">PEAR</ulink> code included in the 
     latest PHP source code distributions.
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function> was added in PHP 4.0.1pl2
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Be aware, that the behaviour of <function>require_once</function>
      and <function>include_once</function> may not be what you expect
      on a non case sensitive operating system (such as Windows).
      <example>
       <title><function>require_once</function> is case sensitive</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // this will include a.php
require_once("A.php"); // this will include a.php again on Windows!
?>
]]>
        </programlisting>
      </example>
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    See also: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    and <function>virtual</function>.
   </para>
  </sect1>

 <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    The <function>include_once</function> statement includes and evaluates
    the specified file during the execution of the script.
    This is a behavior similar to the <function>include</function> statement,
    with the only difference being that if the code from a file has already
    been included, it will not be included again.  As the name suggests, 
    it will be included just once.
   </para>
   <para>
    <function>include_once</function> should be used in cases where 
    the same file might be included and evaluated more than once during a
    particular execution of a script, and you want to be sure that it is
    included exactly once to avoid problems with function redefinitions,
    variable value reassignments, etc.
   </para>
   <para>
    For more examples on using <function>require_once</function> and
    <function>include_once</function>, look at the
    <ulink url="&url.php.pear;">PEAR</ulink> code included in the latest
    PHP source code distributions.
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function> was added in PHP 4.0.1pl2
     </para>
    </note>
   </para>
   <para>
   <note>
     <para>
      Be aware, that the behaviour of <function>include_once</function>
      and <function>require_once</function> may not be what you expect
      on a non case sensitive operating system (such as Windows).
      <example>
       <title><function>include_once</function> is case sensitive</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // this will include a.php
include_once("A.php"); // this will include a.php again on Windows!
?>
]]>
        </programlisting>
      </example>
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    See also <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    and <function>virtual</function>.
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
