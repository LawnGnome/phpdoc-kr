<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.13 $ -->
<!-- EN-Revision: 1.78 -->
 <chapter id="control-structures">
  <title>제어 구조</title>

  <simpara>
   모든 PHP 스크립트는 연속적인 구문으로 이루어진다. 하나의 구문은 지정문
   이 될수도 있고, 함수 호출, 반복문, 조건문이 될수 있으며 심지어는 아무
   내용이 없는 빈 문장일수도 있다. 한 구문은 보통 세미콜른(;)으로 끝난다.
   또한 여러개의 구문을 중괄호({,})를 사용하여 하나의 그룹으로 만들어 사용할 수도 있다.
   이 구문 그룹은 그 그룹의 모든 구문들이 하나의 구문인 것처럼 인식된다.
   이 장에서는 여러 가지 구문형태에 대해 알아본다.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    <literal>if</literal>문은 PHP를 포함해서 모든 언어에 있어서 가장
    중요한 기능(feature) 중 하나이다. 이 제어문으로 각각 다른 코드에 대해
    조건적인 수행을 가능케한다. <literal>if</literal>문의 기능은 C와 비슷하다:
    <informalexample>
     <programlisting>
<![CDATA[
if (expr)
    statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <link linkend="language.expressions">표현식에 관한 섹션</link>에서 설명된것처럼
    <replaceable>expr</replaceable>은 논리(Boolean)값으로 취급된다.
    <replaceable>expr</replaceable>이 &true;와 같다면 PHP는 <replaceable>statement</replaceable>를
    수행할것이고, &false;라면 무시될것이다. 무슨값이 &false;인지 알려면
    <link linkend="language.types.boolean.casting">'Converting to boolean'</link>에 관한 섹션을 참고하세요.
   </simpara>
   <para>
    다음 예는 <replaceable>$a</replaceable>가 <replaceable>$b</replaceable>보다
    크다면 <computeroutput>a는 b보다 크다</computeroutput>를 출력할 것입니다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    print "a는 b보다 크다";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    종종 하나 이상의 구문을 조건적으로 수행시켜야 하는 때가 있습니다.
    물론 <literal>if</literal>절로 각 구문을 감싸줄 필요는 없습니다.
    대신, 구문 그룹안에 몇개의 구문을 그룹화할 수 있습니다. 예를 들면,
    이코드는 <replaceable>$a</replaceable>가 <replaceable>$b</replaceable>보다
    크다면 <computeroutput>a는 b보다 크다</computeroutput>라고 출력할것이고,
    <replaceable>$a</replaceable>의 값을 <replaceable>$b</replaceable>로
    지정하게 될것입니다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    print "a는 b보다 크다";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>If</literal>문은 다른 <literal>if</literal>문안에 무한정으로
    내포될수 있습니다. 이와 같은 기능은 프로그램의 여러부분을 조건적으로
    수행하기 위한 유연성을 제공합니다.
   </simpara>
  </sect1>

  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    가끔은 특정 조건에 맞을때 구문 수행하지 않고, 조건과 맞지 않을 때 
    다른 구문을 수행하게 하고 싶은 때가 있다. <literal>else</literal>
    문은 이 목적을 위한 것이다. <literal>if</literal>문 다음의
    <literal>else</literal>문은 <literal>if</literal>구문안의 표현식이
    &false;일때 수행된다. 예를 들면, 다음 코드는 <replaceable>$a</replaceable>가
    <replaceable>$b</replaceable>보다 크다면 <computeroutput>a는 b보다 크다</computeroutput> 
    를 출력할것이고, 그렇지않다면 <computeroutput>a는 b보다 크지 않다</computeroutput>를 
    출력할것이다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    print "a는 b보다 크다";
} else {
    print "a는 b보다 크지 않다";
}
?>
]]>
     </programlisting>
    </informalexample>
    <literal>else</literal>문은 <literal>if</literal>문이 &false;일때만
    수행이 된다. 그리고 그들 모두 &false;값이 될수있다면 <literal>elseif</literal>문
    을 쓸수 있습니다.
    (<link linkend="control-structures.elseif">elseif</link>를 보세요)
   </para>
  </sect1>

  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, 이 이름에서 알수 있듯이,
    <literal>if</literal>와 <literal>else</literal>의 조합이다.
    <literal>else</literal>처럼 이 구문은 <literal>if</literal>절 
    다음에 와서 원래 <literal>if</literal>표현식이 &false;와 같은 경우에
    다른 구문을 수행한다. 그러나, <literal>else</literal>와는 달리
    <literal>elseif</literal>조건 표현식이 &true;일 때만 대체 표현식을
    수행할것이다. 예를 들면 다음 코드는 <computeroutput>a는 b보다 크다</computeroutput>,
    <computeroutput>a는 b와 같다</computeroutput>나 
    <computeroutput>a는 b보다 작다</computeroutput>을 출력할것이다.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    print "a는 b보다 크다";
} elseif ($a == $b) {
    print "a는 b와 같다";
} else {
    print "a는 b보다 작다";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    같은 <literal>if</literal>절 안에 몇개의 <literal>elseif</literal>절이
    존재할수 있다. 가장 먼저 &true;가 되는 <literal>elseif</literal>표현식이 
    수행될것이다. PHP에서는 'else if' (두 단어)로 쓸수 있고 'elseif' (한 단어)
    와 방식은 같다. 문장적(syntactic)으로는 다르다 (C에 익숙하다면,
    이것은 같은 방식이다) 그러나 그 둘 모두 완전히 같은 결과를 보여줄것이다.
   </simpara>
   <simpara>
    <literal>elseif</literal>절은 선행 <literal>if</literal> 표현식과
    다른 <literal>elseif</literal>표현식이 &false;이고,
    이 <literal>elseif</literal>표현식이 &true;일때만 수행된다.
   </simpara>
  </sect1>

  <sect1 id="control-structures.alternative-syntax">
   <title>제어 구조의 대체 문법</title>
   <para>
    PHP는 제어 구조를 위해 대체 문법을 제공한다; 즉
    <literal>if</literal>, <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal>, 그리고 <literal>switch</literal>.
    각 경우에 대체 문법의 기본형태는 괄호열기를 콜른 (:)으로 대체하고
    괄호닫기는 각각 <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal>, 또는
    <literal>endswitch;</literal>으로 대체한다.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A는 5와 같다
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    위 예에서는 대체 문법으로 쓰여진 <literal>if</literal>구문안에 "A는 5와 같다"
    HTML 블록이 포함되어있다. 이 HTML 블록은 $a가 5와 같을때만 출력될것이다.
   </simpara>
   <para>
    대체 문법은 <literal>else</literal>와 <literal>elseif</literal>문에도
    적용이 된다. 다음은 <literal>elseif</literal>와 <literal>else</literal>문
    과 같이 있는 <literal>if</literal>문 절의 대체 형태이다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    print "a는 5와 같다";
    print "...";
elseif ($a == 6):
    print "a는 6과 같다";
    print "!!!";
else:
    print "a는 5도 아니고 6도 아니다";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    더 많은 예는<link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>와 <link
    linkend="control-structures.if">if</link>섹션에 있다.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>while</literal>는 PHP에서 제일 간단한 루프형이다.
    C와 똑같은 방식으로 동작한다. <literal>while</literal>문의
    기본적인 형태는 다음과 같다:
    <informalexample>
     <programlisting>
<![CDATA[
while (expr) statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>while</literal>문의 의미는 단순하다. <literal>while</literal>
    표현식이 계속 &true;이면, PHP에게 내포되어있는 구문(들)을 반복 수행하도
    록 하라는것이다. 표현식의 값은 루프의 시작에서 매번 체크가 된다. 그래서
    이 표현식 값이 내포된 구문(들)의 수행동안에 바뀔지라도 반복(iteration)
    의 끝이 아니면 수행은 끝나지 않게 된다.(루프에서 PHP가 구문을 한번수행
    할때 한번 반복(iteration)이다) 시작된지 얼마안되어 <literal>while</literal>표현식이 
    &false;로 판명되면, 내포된 구문(들)은 즉시 수행을 멈출것이다.
   </simpara>
   <para>
    <literal>if</literal>문과 마찬가지로 중괄호나 대체문법을 사용하여
    구문의 그룹을 둘러쌉으로써 <literal>while</literal>루프 안에 여러
    구문을 그룹화할수 있다
    <informalexample>
     <programlisting>
<![CDATA[
while (expr): statement ... endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    다음 예는 모두 동일하다. 둘다 1부터 10까지의 숫자를 출력한다.:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* example 1 */

$i = 1;
while ($i <= 10) {
    print $i++;  /* the printed value would be
                    $i before the increment
                    (post-increment) */
}

/* example 2 */

$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    <literal>do..while</literal>루프는 시작부분이 아니라 각 반복(iteration)의
    끝부분에서 표현식이 참인지 체크한다는것을 제외하고 <literal>while</literal>루프와
    매우 비슷하다. 일반적인 <literal>while</literal>문과의 주요한 차이점은
    <literal>do..while</literal>문의 첫번째 반복이 반드시 수행된다는것이다
    (반복의 끝부분에서 표현식이 참인지 체크한다), 이와 같은 경우는
    일반 <literal>while</literal>루프로 수행시킬수 없을것이다. (while루프에서는
    각 반복의 시작부분에서 표현식이 참인지 체크되고, 시작부터 바로 그 값이 
    &false;이면 그 루프는 즉시 수행을 멈추게 된다)
   </simpara>
   <para>
    다음에 <literal>do..while</literal>루프의 한가지 문법을 보인다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
   print $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     위 루프는 정확히 한번 수행된다. 첫번째 반복(iteration) 이후에 표현식이
     참인지 체크할때, &false;가 되므로 ($i는 0보다 크지 않다) 루프 수행이 멈춘다. 
   </simpara>
   <para>
    고급 C 유저는 <literal>do..while</literal>루프의 다른 사용법에 익숙할것이다.
    즉, <literal>do..while</literal>(0)으로 감싸고, <link linkend="control-structures.break"><literal>break</literal></link>절을
    사용해서 코드 블록의 중간에서 수행을 멈출수 있도록 해준다.
    다음 코드 예는 이런 경우를 보여준다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        print "i는 충분히 크지 않다";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "i is ok";

    /* process i */

} while(0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    이 코드를 바로 또는 전혀 이해할수 없다고 걱정하지 마라.
    이런 '기능'을 사용하지 않고도 일반스크립트나 심지어 굉장한 스크립트를
    작성할 수 있다.
   </simpara>
  </sect1>

  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>for</literal>루프는 PHP에서 제일 복잡한 루프이다.
    C와 똑같은 방식으로 동작한다. <literal>for</literal>루프의 문법은 
    다음과 같다:
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3) statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    첫번째 표현식(<replaceable>expr1</replaceable>)은 루프의 시작에서
    바로 조건없이 평가된다 (수행된다).
   </simpara>
   <simpara>
    각 반복(iteration)의 시작부분에서 <replaceable>expr2</replaceable>이 평
    가된다. 이 표현식이 &true;이면 루프는 계속되고 내포된 구문(들)이
    수행된다. &false;이면, 루프 수행을 멈춘다.
   </simpara>
   <simpara>
    <replaceable>expr3</replaceable>표현식은 각 반복의 끝부분에서
    평가된다 (수행된다).
   </simpara>
   <simpara>
    각 표현식은 비어 있을수 있다. <replaceable>expr2</replaceable>이 비어있다는
    것은 루프가 무제한 수행되어야 한다는 것을 의미한다 (PHP는 C처럼 &true;로 인식)
    이런 기법은 생각처럼 필요없지는 않다. 왜냐 하면 종종 <literal>for</literal>문의 
    표현식 대신에 <link linkend="control-structures.break"><literal>break</literal></link>문으로
    루프를 끝낼 필요가 있기 때문이다.
   </simpara>
   <para>
    다음 예제 코드들을 보세요. 이 코드 모두 1부터 10까지의 숫자를 출력한다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* example 1 */

for ($i = 1; $i <= 10; $i++) {
    print $i;
}

/* example 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    print $i;
}

/* example 3 */

$i = 1;
for (;;) {
    if ($i > 10) {
        break;
    }
    print $i;
    $i++;
}

/* example 4 */

for ($i = 1; $i <= 10; print $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    물론, 첫번째 예제(또는 네번째) 코드가 가장 좋은 방법이다. 그러나 
    <literal>for</literal>루프에서 빈 표현식을 사용해야 하는 경우도 부딪히게
    될것이다.
   </simpara>
   <para>
    PHP는 <literal>for</literal>루프에 대한 대체 "콜른 문법"을 지원한다.
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3): statement; ...; endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
   <para>
    다른 언어에서는 배열이나 해쉬를 편리하게 사용하기위해 <literal>foreach</literal>구문도 
    지원합니다. PHP 3는 이 구조를 지원하지 않지만, PHP 4는 지원합니다.
    (<link linkend="control-structures.foreach">foreach</link>를 보세요)
    PHP 3에서는 <link linkend="control-structures.while">while</link>문과
    <function>list</function>, <function>each</function>함수를 조합하여 같은 
    효과를 볼수있습니다. 이런 예제는 위 함수에 대한 문서를 보세요.
   </para>

  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4(PHP 3는 아님)는 펄이나 다른 언어와 같이 <literal>foreach</literal>구문을 지원합니다.
    이런 구문은 간단하게 배열에 대한 작업을 수행하는 가장 쉬운 기법입니다.
    <literal>foreach</literal>는 배열에서만 작동하고 다른 데이터형을 갖는 변수나
    초기화되지 않은 변수에 대해서 이 구문을 사용하려한다면 에러 메시지를 만날것입니다.
    이 구문은 두가지 문법이 있습니다; 두번째보다는 첫번째문법이 더 유용한 사용법입니다:
    <informalexample>
     <programlisting>
<![CDATA[
foreach (array_expression as $value) statement
foreach (array_expression as $key => $value) statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    첫번째 형태는 <literal>array_expression</literal>에서 주어진 배열에
    대해 루프를 돈다. 각 루프에서 현재 배열요소(element)의 값은 <literal>$value</literal>
    로 지정되고 내부적인 배열 포인터는 하나씩 이동하게 된다 (그래서
    다음 루프에서 다음 배열 요소를 보게 될것이다)
   </simpara>
   <simpara>
    두번째 루프도 같은 일을 한다. 단 현재 배열요소의 키(key)값은
    각 루프의 <literal>$key</literal>변수로 지정된다.
   </simpara>
   <para>
    <note>
     <para>
      <literal>foreach</literal>문이 처음 실행할때, 내부적인 배열 포인터는
      자동적으로 배열의 첫번째 요소(element)로 리셋된다. 따라서 
      <literal>foreach</literal>절 이전에 <function>reset</function>함수를
      호출할 필요는 없다.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal>는 특정 배열의 복사본에 작용하는것이며 
      배열 자체를 직접 건드리지 않는다. 따라서, 배열 포인터는 <function>each</function>함수
      에 의해 변경이 되는것이 아니다. 넘어온 배열요소에 대한 변화는 원래 
      배열에는 영향을 주지 않는다. 하지만, 원래 배열의 내부적 포인터는
      배열 처리에 의해 <emphasis>이동한다</emphasis>. foreach루프는 
      완료될때까지 루프를 돌고, 배열의 내부적 포인터는 배열 끝을 가리키게된다.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal>는 '@'를 사용해서 에러메시지를 출력하지 못하도록
      할수는 없다.
     </para>
    </note>
   </para>
   <para>
    다음 예는 기능적으로 동일하다는것을 알 필요가 있다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("one", "two", "three");
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Value: $value<br>\n";
}

foreach ($arr as $value) {
    echo "Value: $value<br>\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    다음 예도 기능적으로 동일하다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Key: $key; Value: $value<br>\n";
}

foreach ($arr as $key => $value) {
    echo "Key: $key; Value: $value<br>\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    더 많은 예제 코드들이 사용법에 대해서 설명해준다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* foreach example 1: value only */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
   print "Current value of \$a: $v.\n";
}

/* foreach example 2: value (with key printed for illustration) */

$a = array (1, 2, 3, 17);

$i = 0; /* for illustrative purposes only */

foreach ($a as $v) {
    print "\$a[$i] => $v.\n";
    $i++;
}

/* foreach example 3: key and value */

$a = array (
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "seventeen" => 17
);

foreach ($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}

/* foreach example 4: multi-dimensional arrays */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* foreach example 5: dynamic arrays */

foreach (array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal>는 현재 <literal>for</literal>, <literal>foreach</literal>
    <literal>while</literal>, <literal>do..while</literal> 또는
    <literal>switch</literal>절의 수행을 멈춘다.
   </simpara>
   <simpara>
    <literal>break</literal>는 숫자 인자 옵션을 허용함으로써
    내포된 구문구조의 깊이를 표시하고 거기서 빠져나올수 있게 해준다.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array ('one', 'two', 'three', 'four', 'stop', 'five');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* You could also write 'break 1;' here. */
    }
    echo "$val<br>\n";
}

/* Using the optional argument. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5<br>\n";
        break 1;  /* Exit only the switch. */
    case 10:
        echo "At 10; quitting<br>\n";
        break 2;  /* Exit the switch and the while. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal>는 루프 구조의 절안에서 현재 루프 반복의 
    나머지부분을 건너뛰게 하고 다음 반복의 시작으로 실행을 속행시켜준다.
   </simpara>
   <note>
    <simpara>
     PHP에서 <link linkend="control-structures.switch">switch</link>구문은 
     <literal>continue</literal>에 의해 루프 구조로 사용할수 있다는것을 참고할것.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal>는 숫자 인자 옵션을 사용하여 루프의 깊이를
    표시할수 있고, 루프의 끝까지 건너뛸수 있다.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list ($key, $value) = each ($arr)) {
    if (!($key % 2)) { // skip odd members
        continue;
    }
    do_something_odd ($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Outer<br>\n";
    while (1) {
        echo "&nbsp;&nbsp;Middle<br>\n";
        while (1) {
            echo "&nbsp;&nbsp;Inner<br>\n";
            continue 3;
        }
        echo "This never gets output.<br>\n";
    }
    echo "Neither does this.<br>\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
  </sect1>

  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal>구문은 연속적인 같은 표현식을 갖는 
    연속적인 IF구문과 비슷하다. 많은 경우, 하나의 변수(또는 표현식)으로
    다른 많은 값과 비교할 필요가 있으며, 그 값이 동일한 코드의 파편들을
    수행할 필요가 생기게 된다. 정확히 이런 목적을 위해 <literal>switch</literal>구문이 
    사용된다.
   </simpara>
   <note>
    <simpara>
     다른 언어와는 달리 <link linkend="control-structures.continue">continue</link>문은 
     switch문에서 사용할수 있고, <literal>break</literal>문과 비슷하게 동작한다.
     루프 내에 switch문을 포함하고 있고 바깥 루프의 다음 반복문으로 진행하고 싶다면
     <literal>continue 2</literal>를 사용한다.
    </simpara>
   </note>
   <para>
    다음 예제 코드들은 같은 일을 서로 다르게 표현한 것이다. 하나는
    <literal>if</literal>문을 연속적으로 사용한것이고, 다른 것은
    <literal>switch</literal>문을 사용하고 있다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    print "i equals 0";
} elseif ($i == 1) {
    print "i equals 1";
} elseif ($i == 2) {
    print "i equals 2";
}

switch ($i) {
    case 0:
        print "i equals 0";
        break;
    case 1:
        print "i equals 1";
        break;
    case 2:
        print "i equals 2";
        break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    실수하지 않기 위해 <literal>switch</literal>문이 어떻게 동작하는지
    이해할 필요가 있다. <literal>switch</literal>문은 한줄씩 수행된다
    (실제는, 한구문씩). 처음에는 아무 코드도 수행되지 않는다. 오직
    값을 갖는 <literal>case</literal>문이 발견될때에만 구문을 수행하기 
    시작한다. PHP는 <literal>switch</literal>블록의 끝부분이 될때까지,
    또는 <literal>break</literal>문와 첫번째 조우를 할때까지
    구문을 계속 수행해 간다. 만약 각 case 구문 목록의 끝부분에
    <literal>break</literal>문을 쓰지않는다면 PHP는 다음 case문으로 계속
    진행하게 된다. 예를 들면 다음과 같다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
        print "i는 0과 같다";
    case 1:
        print "i는 1과 같다";
    case 2:
        print "i는 2와 같다";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    이 예제 코드에서, $i가 0과 같으면, PHP는 모든 print구문을 수행할것이다!
    $i가 1이면 밑의 두 print구문을 수행한다. $i가 2일때만 원하는 동작
    ('i는 2와 같다')을 보게 될것이다. 따라서 <literal>break</literal>문을 
    반드시 빠뜨려서는 안된다. (어떤 경우에는 일부러 빠뜨릴수 있을지 모르지만)
   </simpara>
   <simpara>
    <literal>switch</literal>구문에서, 조건문은 오직 한번만 평가되고
    각 <literal>case</literal>문에서 결과가 비교되어진다.
    <literal>elseif</literal>문에서는 조건문은 다시 평가된다. 조건문이 
    한번 이상의 비교가 필요한 복잡한 것이거나 거친(tight) 루프안에 있다면
    <literal>switch</literal>문 좀 더 빠를것이다.
   </simpara>
   <para>
    case에 대한 구문 목록은 비어있을수 있다. 이것은 단순히 다음 case문으로
    제어권을 넘겨줄 뿐이다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "i is less than 3 but not negative";
        break;
    case 3:
        print "i is 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    특별한 case가 바로 <literal>default</literal> case문이다. 이것은 다른 case문과
    모두 조건이 맞지 않을때의 경우를 위한것이고, <literal>case</literal>구문의 
    마지막에 위치해야 한다. 예제 코드는 다음과 같다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
    case 0:
        print "i는 0과 같다";
        break;
    case 1:
        print "i는 1과 같다";
        break;
    case 2:
        print "i는 2와 같다";
        break;
    default:
        print "i는 0, 1, 2 어느것도 아니다";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>case</literal>의 표현식은 정수나 부동소수점 수와 문자열같은
    단순형으로 평가되는 어던 표현식도 될수 있다. 여기에 단순형으로
    재참조(dereference)되지 않는 배열이나 객체를 사용할수는 없다.
   </para>
   <para>
    switch문을 위한 제어 구조의 대체 문법이 지원된다. 더 자세한 정보는
    <link linkend="control-structures.alternative-syntax">제어 구조의 대체 문법</link>을 참고.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
    case 0:
        print "i equals 0";
        break;
    case 1:
        print "i equals 1";
        break;
    case 2:
        print "i equals 2";
        break;
    default:
        print "i is not equal to 0, 1 or 2";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    <literal>declare</literal>구문은 코드 블록의 수행 디렉티브(directive)를
    활성화하기 위해 사용된다.
    <literal>declare</literal>문법은 다른 흐름 제어 구조의 문법과
    비슷하다:
    <informalexample>
     <programlisting>
<![CDATA[
declare (directive) statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>directive</literal>부분은 <literal>declare</literal>블록의 동작이
    활성화되도록 해준다. 현재는 오직 한 디렉티브만 인식된다:
    <literal>ticks</literal> 디렉티브. (더 자세한 정보는
    <link linkend="control-structures.declare.ticks">ticks</link> 디렉티브를 볼것)
   </para>
   <para>
    <literal>declare</literal>블록의 <literal>statement</literal>부분이 수행될것이다
    - 어떻게 수행이 되고 수행중에 어떤 사이드 이펙트가 발생할지는 
    <literal>directive</literal>블록의 디렉티브에 달려있다.
   </para>
   <para>
    <literal>declare</literal> 구문은 전역 유효영역 안에서 사용할수 있다.
    그래서 모든 코드가 그 디렉티브에 영향을 받는다. 
    <informalexample>
     <programlisting>
<![CDATA[
<?php
// these are the same:

// you can use this:
declare(ticks=1) {
    // entire script here
}

// or you can use this:
declare(ticks=1);
// entire script here
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 id="control-structures.declare.ticks">
    <title>틱(Ticks)</title>
    <para>
    틱은 <literal>declare</literal>블록에서 파서에 의해 수행되는
    <replaceable>N</replaceable> 저레벨(low-level) 구문마다 발생하는
    이벤트이다. <replaceable>N</replaceable> 값은 
    <literal>declare</literal>블록의 <literal>directive</literal>부분에서
    <literal>ticks=<replaceable>N</replaceable></literal> 으로 지정할수 있다.
   </para>
   <para>
    각 틱에서 발생하는 이벤트(들)은 <function>register_tick_function</function>함수
    를 써서 지정한다. 자세한 것은 아래 예제를 볼것. 각 틱에서는 하나 이상의
    이벤트가 발생할수 있음에 주의해야 한다.
   </para>
   <para>
    <example>
     <title>PHP 각 코드 섹션의 분석표만들기(Profile)</title>
     <programlisting role="php">
<![CDATA[
<?php
// 호출될대의 시간을 기록하는 함수
function profile ($dump = FALSE)
{
    static $profile;

    // Profile에 저장된 모든 시간 리턴하고, 삭제함
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }

    $profile[] = microtime ();
}

// 틱 핸들러 설정
register_tick_function("profile");

// declare 블록 전에 함수를 초기화
profile ();

// 코드 블록의 실행하고, 두번째 구문에 틱을 부여함
declare (ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text (md5($x), md5($x*$x)), "<br />;";
    }
}

// 분석표에 저장된 데이터를 출력
print_r (profile (TRUE));
?>
]]>
     </programlisting>
    </example>
    위 예제 코드는 실행 블록안의 두번째  저레벨(low-level) 구문의
    시간에 따라 'declare'블록 안의 PHP코드를 분석한다. 이런 정보로
    어느 코드 부분에서 느려지는지 알아볼 수 있다. 이런 처리방법은
    다른 기법으로 수행할수있다: 틱을 이용하는 것은 좀더 편하고
    좀더 구현하기 쉽다.
   </para>
   <simpara>
    틱은 디버깅, 단순한 멀티태스킹 구현, 백그라운드 I/O와 다른 많은 작업
    에 적합하게 이용할수 있다.
   </simpara>
   <simpara>
    <function>register_tick_function</function>함수와
    <function>unregister_tick_function</function>함수를 참고하세요.
   </simpara>
   </sect2>
  </sect1>

  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    <function>return</function>문이 함수안에서 호출된다면, 현재 함수의
    수행을 즉시 끝내고, 함수 호출 결과값으로 return의 인자값을 넘겨준다.
    <function>return</function>문은 <function>eval</function>함수나 
    스크립트 파일의 수행을 종료시킨다.
   </simpara>
   <simpara>
    전역 유효범위에서 호출된다면, 현재 스크립트 파일의 수행을 끝마친다.
    현재 스크립트가 <function>include</function>나 <function>require</function>되었다면,
    호출하고 있는 파일로 제어를 넘긴다. 더욱이, 현재 스크립트 파일이 
    <function>include</function>되어있는것이면, <function>return</function>에 주어지는
    값은 <function>include</function>호출에 대한 값으로 넘겨줄것이다.
    <function>return</function>이 주 스크립트 파일에서 호출되면, 스크립트의
    수행이 종료된다. 현재 스크립트 파일이 &php.ini;의 
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link>이나 
    <link linkend="ini.auto-append-file">auto_append_file</link> 옵션에 의해 
    명명되었다면, 스크립트 파일의 수행은 중단된다.
   </simpara>
   <simpara>
   좀더 자세한 정보는 <link linkend="functions.returning-values">Returning values</link>
   을 참고하세요.
   </simpara>
   <para>
    <note>
     <simpara>
      <function>return</function>은 언어 구조이지 함수가 아니라는것에 주의해야 한다.
      사실 이 인자에 괄호를 치는 것은 요구되지 <emphasis>않는다</emphasis>
      어느방법을 쓰든 별 상관이 없지만, 보통 괄호를 치지않는다.
     </simpara>
    </note>
   </para>
  </sect1>


 <sect1 id="function.require">
   <title><function>require</function></title>

   <simpara>
    <function>require</function>문은 특정 파일을 인클루드하고, 적용시킨다.
   </simpara>
   <simpara>
     <function>require</function>문은 특정 파일을 인클루드하고, 적용시킨다.
     이런 인클루드가 어떻게 동작하는지에 대한 자세한 정보는 <function>include</function>에
     대한 문서에서 설명한다.
   </simpara>
   <simpara>
     <function>require</function>와 <function>include</function> 는
     수행실패를 제어하는 방법을 제외하고 모든면에서 동일하다.
     <function>include</function>는 <link linkend="internal.e-warning">Warning</link>을
     발생시키는 반면에 <function>require</function>는 <link linkend="internal.e-error">
     Fatal Error</link>을 발생시킨다. 즉, 파일이 존재하지 않을때 페이지 처리를 중단시키
     고자 한다면 <function>require</function>를 쓰는데 주저할 필요가 없다.
     <function>include</function>는 이와같이 동작하지 않으므로 파일이 없더라도 스크립트는
     계속 실행될것이다. 또한 적절한 <link linkend="ini.include-path">include_path</link>설정인지
     확인해야 한다.
   </simpara>
   <para>
    <example>
     <title>기본적인 <function>require</function> 사용예</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    더 많은 예제 코드는 <function>include</function>문서에서 볼수있다.
   </simpara>
   <para>
    <note>
     <simpara>
      PHP 4.0.2 이전 버전에서는 다음 규칙이 적용된다: <function>require</function>는
      어떤줄도 수행되지 않는 목적 파일도 무작정 읽어 들이려 한다. 조건절에서는
      <function>require</function>가 효과적이지 않다. 하지만, <function>require</function>
      되는 어떤 줄도 수행되지 않으면 목적 파일의 어떤 코드도 수행되지 않을것이다. 
      이와 유사하게, 루프 구조에서도 <function>require</function>는 효과적이지 않다.
      목적파일내에 포함된 코드가 계속 루프를 반복한다면,
      <function>require</function>는 오직 한번만 발생한다.
     </simpara>
    </note>
   </para>
   
   &note.language-construct;
   
   &warn.no-win32-fopen-wrapper;
   
   <simpara>
    <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>, 
    <function>file</function>, <function>readfile</function>, 
    <function>virtual</function>과 <link linkend="ini.include-path">include_path</link>
    섹션도 참고할것.
   </simpara>
  </sect1>

 <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    <function>include</function>문은 특정 파일을 인클루드 하고, 적용시킨다.
   </simpara>
   <simpara>
     이하 내용은 <function>require</function>에도 적용되는 사항이다.
     두가지 구조는 수행실패를 제어하는 방법을 제외하고 모든면에서 동일하다.
     <function>include</function>는 <link linkend="internal.e-warning">Warning</link>을
     발생시키는 반면에 <function>require</function>는 <link linkend="internal.e-error">
     Fatal Error</link>을 발생시킨다. 즉, 파일이 존재하지 않을때 페이지 처리를 중단시키
     고자 한다면 <function>require</function>를 쓰는데 주저할 필요가 없다.
     <function>include</function>는 이와같이 동작하지 않으므로 파일이 없더라도 스크립트는
     계속 실행될것이다. 또한 적절한 <link linkend="ini.include-path">include_path</link>설정인지
     확인해야 한다.
   </simpara>
   <simpara>
     파일이 인클루드 되면, 그 코드를 포함하는 코드는 인클루드가 발생한 줄의
     <link linkend="language.variables.scope">변수 유효 범위</link>를 물려받는다.
     호출하는 파일의 그 줄에서 사용되는 어떤 변수도 그 줄부터는 호출된 파일안에서 
     사용이 가능하다.
   </simpara>
   <para>
     <example>
      <title>기본적인 <function>include</function> 사용예</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     인클루드가 호출하는 파일안의 함수내에서 발생한다면, 호출된 파일안의
     모든 코드가 그 함수에서 정의된것처럼 동작한다. 그래서, 그 함수의 변수
     유효범위를 따를것이다.
   </simpara>
   <para>
     <example>
     <title>함수 내에서 인클루드하기</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php is in the scope of foo() so     *
 * $fruit is NOT available outside of this  *
 * scope.  $color is because we declared it *
 * as global.                               */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     파일이 인클루드되면, 파싱은 PHP모드의 밖으로 나가서 목적 파일의 시작부분은
     HTML모드로 들어가게 되고, 끝부분에서 원래대로 회복된다. 이때문에,
     목적 파일에서 PHP코드로서 수행되어야 하는 코드는 
     <link linkend="language.basic-syntax.phpmode">유효한 PHP 시작과 마침 태그</link>
     로 막아줘야 한다.
   </simpara>
   <simpara>
     PHP에서 "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"가 
     활성화되어 있으면 (디폴트 설정임), URL(HTTP나 다른 지원 래퍼(wrapper) -
     프로토콜 목록은 <xref linkend="wrappers"/>을 참고)을 사용하여 파일을 인클루드
     할수 있다. 목적 서버가 목적 파일을 PHP코드로 해석한다면, HTTP GET으로 사용된
     URL 리퀘스트 문자열은 변수로서 넘겨지게 될것이다. 이와같은 일은 파일을 인크루드
     하고 부모 파일의 변수 유효범위를 상속하는 것과 같은 경우가 되지는 않는다.
     스크립트는 실질적으로 원격 서버에서 실행이 되고 나서 로컬 스크립트에 포함된다.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>HTTP로 <function>include</function>하기</title>
     <programlisting role="php">
<![CDATA[
<?php

/* This example assumes that www.example.com is configured to parse .php
 * files and not .txt files. Also, 'Works' here means that the variables
 * $foo and $bar are available within the included file. */

// Won't work; file.txt wasn't handled by www.example.com as PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Won't work; looks for a file named 'file.php?foo=1&bar=2' on the
// local filesystem.
include 'file.php?foo=1&bar=2';

// Works.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Works.
include 'file.php';  // Works.

?>
]]>
     </programlisting>
    </example>
    관련정보는 <link linkend="features.remote-files">Remote files</link>,
    <function>fopen</function>, <function>file</function>함수를 참고하세요.
   </para>
   <para>
     <function>include</function>와 <function>require</function>는 특별한 언어 
     구조이기 때문에, 조건절 블록안에 들어가게 된다면, 구문 블록안으로 그들을 
     완벽하게 막아줘야 한다.
   </para>
   <para>
    <example>
     <title>include()와 조건절 블록</title>
     <programlisting role="php">
<![CDATA[
<?php

// This is WRONG and will not work as desired.
if ($condition)
    include $file;
else
    include $other;


// This is CORRECT.
if ($condition) {
    include $file;
} else {
    include $other;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    리턴 핸들링: 인클루드된 파일에서 처리를 종료시키고 그것을 호출한 스크립트로 
    리턴하기 위해 인클루드된 파일 안에서 <function>return</function> 문을 수행할수 있다
    또한, 인클루드된 파일에서 값을 리턴하는것이 가능하다. 일반 함수로서 인클루드 호출의
    값을 취할수 있다.
   </simpara>
   <para>
    <note>
     <simpara>
      PHP 3에서 그 블록이 함수가 아니면 블록 안에 return이 보이지 않을것이다.
      그런 경우에는 전체 파일이 아니고 그 함수로만 <function>return</function>이 적용된다.
     </simpara>
    </note>
   </para>
   <para>
    <example>
     <title><function>include</function>와 <function>return</function>문</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // prints 'PHP'

$bar = include 'noreturn.php';

echo $bar; // prints 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    인클루드가 성공하면 <literal>$bar</literal>는 <literal>1</literal>의 값을 갖는다.
    위 두 예제의 차이점에 주의해야 한다. 첫번째 경우는 인클루드된 파일에서 
    <function>return</function>을 사용하지만 다른 예는 그렇지 않다. 변수로 파일을
    "인클루드"하는 다른 방법은 <function>fopen</function>, <function>file</function>
    을 사용하거나, <link linkend="ref.outcontrol">Output Control Functions</link>와 함께
    <function>include</function>를 쓰는것이다.
   </simpara>
   
   &note.language-construct;

   <simpara>
    <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>, 그리고
    <link linkend="ini.include-path">include_path</link>도 참고하세요.
   </simpara>
 </sect1>

 <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    <function>require_once</function>문은 스크립트 수행기간 중에 특정파일을
    인클루드하고 적용시킨다. 이것은 <function>require</function>문과 비슷하게
    동작한다. 오직 파일의 코드가 이미 인클루드되었다면 다시 인클루드되지 않을것
    이라는 차이점이 있다. 이 구문이 어떻게 작용하는지에 대한 정보를 알아보려면
    <function>require</function>함수에 대한 문서를 보세요.
   </para>
   <para>
    <function>require_once</function>는 특정 스크립트 수행기간동안 한번이상
    인클루드되고 적용될수 있는 상황에서 사용하도록 한다. 그리고 함수 중복 정의와
    변수값 중복 지정 등에 대한 문제를 회피하기 위해서는 
    정확히 한번 인클루드될 필요가 있을것이다.
   </para>
   <para>
     <function>require_once</function>과 <function>include_once</function>의
     사용예는 최신 PHP 소스코드 안에 포함된 <ulink url="&url.php.pear;">PEAR</ulink>코드를
     참고할것.
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function>는 PHP 4.0.1pl2에 추가되었다.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function>와 <function>include_once</function>은
      민감한 운영체제(윈도우 같은)에서는 기대하던대로 동작하지 않을지 모른다.
      <example>
       <title><function>require_once</function>는 대소문자를 구별</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // this will include a.php
require_once("A.php"); // this will include a.php again on Windows!
?>
]]>
        </programlisting>
      </example>
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    다음 함수를 참고할것: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    <function>virtual</function>.
   </para>
  </sect1>

 <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    <function>include_once</function>문은 스크립트 수행기간동안 특정파일을
    인클루드하고 적용시킨다. 이것은 <function>include</function>문과 비슷하게
    동작한다. 단지 파일의 특정 코드가 이미 인클루되었다면 그 코드는 다시는 인클루드
    될수 없다는 차이점만 있다. 이 이름이 제시하듯이 한번만 인클루드할것이다.
   </para>
   <para>
    <function>include_once</function>는 특정 스크립트 수행기간동안 동일한 파일이
    한번 이상 인클루드되고 적용될지도 모르는 상황에서 사용해야 할것이다.
    그리고 함수 중복정의, 변수값 중복 지정 등의 문제를 회피하려면 정확히 한번만
    인클루드할 때가 있을것이다.
   </para>
   <para>
    <function>require_once</function>와 <function>include_once</function>의 더 많은 사용예는, 
    최신 PHP소스 내의 <ulink url="&url.php.pear;">PEAR</ulink>코드를 참고할것
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function>는 PHP 4.0.1pl2에서 추가됨
     </para>
    </note>
   </para>
   <para>
   <note>
     <para>
      <function>include_once</function>와 <function>require_once</function>는
      민감한 운영체제(윈도우같은)에서 기대와 다르게 작동할수도 있다.
      <example>
       <title><function>include_once</function>는 대소문자를 구별함</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // this will include a.php
include_once("A.php"); // this will include a.php again on Windows!
?>
]]>
        </programlisting>
      </example>
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    <function>virtual</function>도 참고할것
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
