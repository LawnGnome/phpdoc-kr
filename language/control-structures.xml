<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 1.142 Maintainer: progcom Status: ready -->
<!-- CREDITS: fuzzy74 -->
 <chapter xml:id="language.control-structures" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>제어 구조</title>

  <simpara>
   모든 PHP 스크립트는 연속적인 구문으로 이루어진다. 하나의 구문은 지정문
   이 될수도 있고, 함수 호출, 반복문, 조건문이 될수 있으며 심지어는 아무
   내용이 없는 빈 문장일수도 있다. 한 구문은 보통 세미콜론(;)으로 끝난다.
   또한 여러개의 구문을 중괄호({,})를 사용하여 하나의 그룹으로 만들어 사용할
   수도 있다. 이 구문 그룹은 그 그룹의 모든 구문들이 하나의 구문인 것처럼
   인식된다. 이 장에서는 여러 가지 구문형태에 대해 알아본다.
  </simpara>

  <sect1 xml:id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    <literal>if</literal>문은 PHP를 포함해서 모든 언어에 있어서 가장
    중요한 기능(feature) 중 하나이다. 이 제어문으로 각각 다른 코드에 대해
    조건적인 수행을 가능케한다. <literal>if</literal>문의 기능은 C와 비슷하다:
    <informalexample>
     <programlisting>
<![CDATA[
if (expr)
    statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <link linkend="language.expressions">표현식에 관한 섹션</link>에서 설명된것처럼
    <replaceable>expr</replaceable>은 논리(Boolean)값으로 취급된다.
    <replaceable>expr</replaceable>이 &true;와 같다면 PHP는 
    <replaceable>statement</replaceable>를
    수행할것이고, &false;라면 무시될것이다. 무슨값이 &false;인지 알려면
    <link linkend="language.types.boolean.casting">'논리값으로 변환하기'</link>
    섹션을 참고한다.
   </simpara>
   <para>
    다음 예는 <varname>$a</varname>가 <varname>$b</varname>보다
    크다면 <computeroutput>a는 b보다 크다</computeroutput>를 출력할 것이다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    echo "a는 b보다 크다";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    종종 하나 이상의 구문을 조건적으로 수행시켜야 하는 때가 있다.
    물론 <literal>if</literal>절로 각 구문을 감싸줄 필요는 없다.
    대신, 구문 그룹안에 몇개의 구문을 그룹화할 수 있다. 예를 들면,
    이코드는 <varname>$a</varname>가 <varname>$b</varname>보다
    크다면 <computeroutput>a는 b보다 크다</computeroutput>라고 출력할것이고,
    <varname>$a</varname>의 값을 <varname>$b</varname>로
    지정하게 될것이다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a는 b보다 크다";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>If</literal>문은 다른 <literal>if</literal>문안에 무한정으로
    내포될수 있다. 이와 같은 기능은 프로그램의 여러부분을 조건적으로
    수행하기 위한 유연성을 제공한다.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    가끔은 특정 조건에 맞을때 구문을 수행하지 않고, 조건과 맞지 않을 때 
    다른 구문을 수행하게 하고 싶은 때가 있다. <literal>else</literal>
    문은 이 목적을 위한 것이다. <literal>if</literal>문 다음의
    <literal>else</literal>문은 <literal>if</literal>구문안의 표현식이
    &false;일때 수행된다. 예를 들면, 다음 코드는 <varname>$a</varname>가
    <varname>$b</varname>보다 크다면 <computeroutput>a는 b보다 크다</computeroutput> 
    를 출력할것이고, 그렇지않다면 <computeroutput>a는 b보다 크지 않다</computeroutput>를 
    출력할것이다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a는 b보다 크다";
} else {
    echo "a는 b보다 크지 않다";
}
?>
]]>
     </programlisting>
    </informalexample>
    <literal>else</literal>문은 <literal>if</literal>문이 &false;일때만
    수행이 된다. 그리고 그들 모두 &false;값이 될수있다면 <literal>elseif</literal>문
    을 쓸수 있다.
    (<link linkend="control-structures.elseif">elseif</link>를 참고)
   </para>
  </sect1>

  <sect1 xml:id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, 이 이름에서 알수 있듯이,
    <literal>if</literal>와 <literal>else</literal>의 조합이다.
    <literal>else</literal>처럼 이 구문은 <literal>if</literal>절 
    다음에 와서 원래 <literal>if</literal>표현식이 &false;와 같은 경우에
    다른 구문을 수행한다. 그러나, <literal>else</literal>와는 달리
    <literal>elseif</literal>조건 표현식이 &true;일 때만 대체 표현식을
    수행할것이다. 예를 들면 다음 코드는 <computeroutput>a는 b보다 크다</computeroutput>,
    <computeroutput>a는 b와 같다</computeroutput>나 
    <computeroutput>a는 b보다 작다</computeroutput>을 출력할것이다.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a는 b보다 크다";
} elseif ($a == $b) {
    echo "a는 b와 같다";
} else {
    echo "a는 b보다 작다";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    같은 <literal>if</literal>절 안에 몇개의 <literal>elseif</literal>절이
    존재할수 있다. 가장 먼저 &true;가 되는 <literal>elseif</literal>표현식이 
    수행될것이다. PHP에서는 'else if' (두 단어)로 쓸수 있고 'elseif' (한 단어)
    와 방식은 같다. 문장적(syntactic)으로는 다르다 (C에 익숙하다면,
    이것은 같은 방식이다) 그러나 그 둘 모두 완전히 같은 결과를 보여줄것이다.
   </simpara>
   <simpara>
    <literal>elseif</literal>절은 선행 <literal>if</literal> 표현식과
    다른 <literal>elseif</literal>표현식이 &false;이고,
    이 <literal>elseif</literal>표현식이 &true;일때만 수행된다.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.alternative-syntax">
   <title>제어 구조의 대체 문법</title>
   <para>
    PHP는 제어 구조를 위해 대체 문법을 제공한다; 즉
    <literal>if</literal>, <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal>, 그리고 <literal>switch</literal>.
    각 경우에 대체 문법의 기본형태는 괄호열기를 콜른 (:)으로 대체하고
    괄호닫기는 각각 <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal>, 또는
    <literal>endswitch;</literal>으로 대체한다.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A는 5와 같다
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    위 예에서는 대체 문법으로 쓰여진 <literal>if</literal>구문안에 "A는 5와 같다"
    HTML 블록이 포함되어있다. 이 HTML 블록은 <varname>$a</varname>가 5와 같을때만 출력될것이다.
   </simpara>
   <para>
    대체 문법은 <literal>else</literal>와 <literal>elseif</literal>문에도
    적용이 된다. 다음은 <literal>elseif</literal>와 <literal>else</literal>문
    과 같이 있는 <literal>if</literal>문 절의 대체 형태이다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    echo "a는 5와 같다";
    echo "...";
elseif ($a == 6):
    echo "a는 6과 같다";
    echo "!!!";
else:
    echo "a는 5도 아니고 6도 아니다";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    더 많은 예는<link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>와 <link
    linkend="control-structures.if">if</link>섹션에 있다.
   </para>
  </sect1>

  <sect1 xml:id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>while</literal>는 PHP에서 제일 간단한 루프형이다.
    C와 똑같은 방식으로 동작한다. <literal>while</literal>문의
    기본적인 형태는 다음과 같다:
    <informalexample>
     <programlisting>
<![CDATA[
while (expr)
    statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>while</literal>문의 의미는 단순하다. <literal>while</literal>
    표현식이 계속 &true;이면, PHP에게 내포되어있는 구문(들)을 반복 수행하도
    록 하라는것이다. 표현식의 값은 루프의 시작에서 매번 체크가 된다. 그래서
    이 표현식 값이 내포된 구문(들)의 수행동안에 바뀔지라도 반복(iteration)
    의 끝이 아니면 수행은 끝나지 않게 된다.(루프에서 PHP가 구문을 한번수행
    할때 한번 반복(iteration)이다) 시작된지 얼마안되어 <literal>while</literal>표현식이 
    &false;로 판명되면, 내포된 구문(들)은 즉시 수행을 멈출것이다.
   </simpara>
   <para>
    <literal>if</literal>문과 마찬가지로 중괄호나 대체문법을 사용하여
    구문의 그룹을 둘러쌉으로써 <literal>while</literal>루프 안에 여러
    구문을 그룹화할수 있다
    <informalexample>
     <programlisting>
<![CDATA[
while (expr):
    statement
    ...
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    다음 예는 모두 동일하다. 둘다 1부터 10까지의 숫자를 출력한다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* example 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* 출력하는 값은 증가하기
                   전의 $i입니다.
                   (post-increment) */
}

/* example 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.do.while">
   <title><literal>do-while</literal></title>
   <simpara>
    <literal>do-while</literal> 루프는 시작부분이 아니라 각 반복(iteration)의
    끝부분에서 표현식이 참인지 체크한다는것을 제외하고 <literal>while</literal>루프와
    매우 비슷하다. 일반적인 <literal>while</literal>문과의 주요한 차이점은
    <literal>do-while</literal>문의 첫번째 반복이 반드시 수행된다는것이다
    (반복의 끝부분에서 표현식이 참인지 체크한다), 이와 같은 경우는
    일반 <literal>while</literal>루프로 수행시킬수 없을것이다. (while루프에서는
    각 반복의 시작부분에서 표현식이 참인지 체크되고, 시작부터 바로 그 값이 
    &false;이면 그 루프는 즉시 수행을 멈추게 된다)
   </simpara>
   <para>
    다음에 <literal>do-while</literal>루프의 한가지 문법을 보인다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
   echo $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     위 루프는 정확히 한번 수행된다. 첫번째 반복(iteration) 이후에 표현식이
     참인지 체크할때, &false;가 되므로 ($i는 0보다 크지 않다) 루프 수행이 멈춘다. 
   </simpara>
   <para>
    고급 C 유저는 <literal>do-while</literal>루프의 다른 사용법에 익숙할것이다.
    즉, <literal>do-while</literal> (0)으로 감싸고, <link
     linkend="control-structures.break"><literal>break</literal></link>절을
    사용하여 코드 블록의 중간에서 수행을 멈출수 있습니다.
    다음 코드 예는 이런 경우를 보여준다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        echo "i는 충분히 크지 않다";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    echo "i is ok";

    /* process i */

} while (0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    이 코드를 바로 또는 전혀 이해할수 없다고 걱정하지 마라.
    이런 '기능'을 사용하지 않고도 일반스크립트나 심지어 굉장한 스크립트를
    작성할 수 있다.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>for</literal>루프는 PHP에서 제일 복잡한 루프이다.
    C와 똑같은 방식으로 동작한다. <literal>for</literal>루프의 문법은 
    다음과 같다:
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3)
    statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    첫번째 표현식(<varname>expr1</varname>)은 루프의 시작에서
    바로 조건없이 평가된다 (수행된다).
   </simpara>
   <simpara>
    각 반복(iteration)의 시작부분에서 <varname>expr2</varname>이 평
    가된다. 이 표현식이 &true;이면 루프는 계속되고 내포된 구문(들)이
    수행된다. &false;이면, 루프 수행을 멈춘다.
   </simpara>
   <simpara>
    <varname>expr3</varname>표현식은 각 반복의 끝부분에서
    평가된다 (수행된다).
   </simpara>
   <simpara>
    각 표현은 비어있거나 콤마로 구분한 여러 표현을 가질 수 있습니다. expr2에서
    콤마로 구분한 표현은 <link linkend="language.operators.logical">||
     연산자</link>처럼 동작하지만, || 보다 우선권이 낮습니다.
    <varname>expr2</varname>이 비어있다는
    것은 루프가 무제한 수행되어야 한다는 것을 의미한다 (PHP는 C처럼 &true;로 인식)
    이런 기법은 생각처럼 필요없지는 않다. 왜냐 하면 종종 <literal>for</literal>문의 
    표현식 대신에 <link linkend="control-structures.break"><literal>break</literal></link>문으로
    루프를 끝낼 필요가 있기 때문이다.
   </simpara>
   <para>
    다음 예제 코드들을 보세요. 이 코드 모두 1부터 10까지의 숫자를 출력한다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* 예제 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* 예제 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* 예제 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* 예제 4 */

for ($i = 1, $j = 0; $i <= 10; $j += 1, print $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    물론, 첫번째 예제(혹은 네번째) 코드가 가장 좋은 방법이다. 그러나 
    <literal>for</literal>루프에서 빈 표현식을 사용해야 하는 경우도 부딪히게
    될것이다.
   </simpara>
   <para>
    PHP는 <literal>for</literal>루프에 대한 대체 "콜른 문법"을 지원한다.
    <informalexample>
     <programlisting>
<![CDATA[
for (expr1; expr2; expr3):
    statement
    ...
endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4는 펄이나 다른 언어처럼 <literal>foreach</literal>구문을 지원합니다.
    이런 구문은 간단하게 배열에 대한 작업을 수행하는 가장 쉬운 기법입니다.
    <literal>foreach</literal>는 배열에서만 작동하고 다른 데이터형을 갖는 변수나
    초기화되지 않은 변수에 대해서 이 구문을 사용하려한다면 에러 메시지를 만날것입니다.
    이 구문은 두가지 문법이 있습니다; 두번째보다는 첫번째문법이 더 유용한 사용법입니다:
    <informalexample>
     <programlisting>
<![CDATA[
foreach (array_expression as $value)
    statement
foreach (array_expression as $key => $value)
    statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    첫번째 형태는 <literal>array_expression</literal>에서 주어진 배열에
    대해 루프를 돈다. 각 루프에서 현재 배열요소(element)의 값은 <literal>$value</literal>
    로 지정되고 내부적인 배열 포인터는 하나씩 이동하게 된다 (그래서
    다음 루프에서 다음 배열 요소를 보게 될것이다)
   </simpara>
   <simpara>
    두번째 루프도 같은 일을 한다. 단 현재 배열요소의 키(key)값은
    각 루프의 <literal>$key</literal>변수로 지정된다.
   </simpara>
   <simpara>
    PHP 5부터 <link linkend="language.oop5.iterations">객체 순환</link>도 할
    수 있습니다.
   </simpara>
   <para>
    <note>
     <para>
      <literal>foreach</literal>문이 처음 실행할때, 내부적인 배열 포인터는
      자동적으로 배열의 첫번째 요소(element)로 리셋된다. 따라서 
      <literal>foreach</literal>절 이전에 <function>reset</function>함수를
      호출할 필요는 없다.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      배열이 <link linkend="language.references">참조</link>되지 않는 이상,
      <literal>foreach</literal>는 지정한 배열 자체가 아닌 복사한 배열을
      대상으로 작동합니다. 그러므로, <function>each</function> 구문과 달리
      배열 포인터는 변경되지 않으며, 반환된 배열 요소의 변경은 원 배열에
      반영되지 않습니다. 그러나, 원 배열의 내부 포인터는 배열 처리에 따라
      <emphasis>증가</emphasis>됩니다. foreach 루프가 끝까지 작동하면, 배열의
      내부 포인터는 배열의 끝에 위치하게 됩니다.
     </para>
     <para>
      PHP 5부터, <literal>$value</literal> 앞에 &amp;를 붙여서 배열 원소를
      쉽게 변경할 있습니다. 값을 복사하지 않고 <link
       linkend="language.references">참조</link>합니다.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr은 이제 array(2, 4, 6, 8)입니다.
]]>
       </programlisting>
      </informalexample>
      이는 반복할 배열을 참조할 수 있을 때(즉, 변수)만 가능합니다.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal>는 '@'를 사용해서 에러메시지를 출력하지 못하도록
      할수는 없다.
     </para>
    </note>
   </para>
   <para>
    다음 예는 기능적으로 동일하다는것을 알 필요가 있다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("하나", "둘", "셋");
reset($arr);
while (list(, $value) = each($arr)) {
    echo "값: $value<br />\n";
}

foreach ($arr as $value) {
    echo "값: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    다음 예도 기능적으로 동일하다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("하나", "둘", "셋");
reset($arr);
while (list($key, $value) = each($arr)) {
    echo "키: $key; 값: $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "키: $key; 값: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    더 많은 예제 코드들이 사용법에 대해서 설명해준다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* foreach 예제 1: 값만 */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "\$a의 현재 값: $v.\n";
}

/* foreach 예제 2: 값 (키는 가상으로 출력) */

$a = array(1, 2, 3, 17);

$i = 0; /* 가상 목적으로만 사용 */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* foreach 예제 3: 키와 값 */

$a = array(
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "seventeen" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* foreach 예제 4: 다차원 배열 */

$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* foreach 예제 5: 동적 배열 */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal>는 현재 <literal>for</literal>,
    <literal>foreach</literal>,
    <literal>while</literal>, <literal>do-while</literal> 또는
    <literal>switch</literal>절의 수행을 멈춘다.
   </simpara>
   <simpara>
    <literal>break</literal>는 숫자 인자 옵션을 허용함으로써
    내포된 구문구조의 깊이를 표시하고 거기서 빠져나올수 있게 해준다.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array('one', 'two', 'three', 'four', 'stop', 'five');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* 여기서는 'break 1;'으로 슬 수 있습니다. */
    }
    echo "$val<br />\n";
}

/* 옵션 인자 사용하기. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5<br />\n";
        break 1;  /* switch만 빠져나갑니다. */
    case 10:
        echo "At 10; quitting<br />\n";
        break 2;  /* switch와 while을 빠져나갑니다. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal>는 루프 구조 내부에서 현재 루프 반복의 나머지
    부분을 생략하고 조건 평가를 한 후 다음 반복 시작에서 실행을 지속하게
    합니다.
   </simpara>
   <note>
    <simpara>
     PHP에서 <link linkend="control-structures.switch">switch</link>구문은 
     <literal>continue</literal>에 의해 루프 구조로 사용할수 있다는것을 참고할것.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal>는 숫자 인자 옵션을 사용하여 루프의 깊이를
    표시할수 있고, 루프의 끝까지 건너뛸수 있다.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list($key, $value) = each($arr)) {
    if (!($key % 2)) { // skip odd members
        continue;
    }
    do_something_odd($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Outer<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Middle<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;Inner<br/ >\n";
            continue 3;
        }
        echo "This never gets output.<br />\n";
    }
    echo "Neither does this.<br />\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
    <para>
     <literal>continue</literal> 뒤의 세미콜론을 빼먹으면 혼란스러울 것입니다.
     여기에 해서는 안되는 일의 예제입니다:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       기대했던 결과는:
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       하지만 스크립트의 출력은:
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
       <function>print</function> 호출의 반환값은
       <literal>int(1)</literal>이기 때문에, 위에서 언급한 부수적인 수 인자로
       보여집니다.
      </para>
     </informalexample>
    </para>
  </sect1>

  <sect1 xml:id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal>구문은 연속적인 같은 표현식을 갖는 
    연속적인 IF구문과 비슷하다. 많은 경우, 하나의 변수(또는 표현식)으로
    다른 많은 값과 비교할 필요가 있으며, 그 값이 동일한 코드의 파편들을
    수행할 필요가 생기게 된다. 정확히 이런 목적을 위해 <literal>switch</literal>구문이 
    사용된다.
   </simpara>
   <note>
    <simpara>
     다른 언어와는 달리 <link linkend="control-structures.continue">continue</link>문은 
     switch문에서 사용할수 있고, <literal>break</literal>문과 비슷하게 동작한다.
     루프 내에 switch문을 포함하고 있고 바깥 루프의 다음 반복문으로 진행하고 싶다면
     <literal>continue 2</literal>를 사용한다.
    </simpara>
   </note>
   <para>
    다음 예제 코드들은 같은 일을 서로 다르게 표현한 것입니다. 하나는
    <literal>if</literal>와 <literal>elseif</literal>문을 사용한 것이고, 다른
    하나는 <literal>switch</literal>문을 사용했습니다:
    <example>
     <title><literal>switch</literal> 구조</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo "i는 0";
} elseif ($i == 1) {
    echo "i는 1";
} elseif ($i == 2) {
    echo "i는 2";
}

switch ($i) {
case 0:
    echo "i는 0";
    break;
case 1:
    echo "i는 1";
    break;
case 2:
    echo "i는 2";
    break;
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>문자열을 사용하는 <literal>switch</literal> 구조</title>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case "apple":
    echo "i는 apple";
    break;
case "bar"
    echo "i는 bar";
    break;
case "cake":
    echo "i는 cake";
    break;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    실수하지 않기 위해 <literal>switch</literal>문이 어떻게 동작하는지
    이해할 필요가 있다. <literal>switch</literal>문은 한줄씩 수행된다
    (실제는, 한구문씩). 처음에는 아무 코드도 수행되지 않는다. 오직
    값을 갖는 <literal>case</literal>문이 발견될때에만 구문을 수행하기 
    시작한다. PHP는 <literal>switch</literal>블록의 끝부분이 될때까지,
    또는 <literal>break</literal>문와 첫번째 조우를 할때까지
    구문을 계속 수행해 간다. 만약 각 case 구문 목록의 끝부분에
    <literal>break</literal>문을 쓰지않는다면 PHP는 다음 case문으로 계속
    진행하게 된다. 예를 들면 다음과 같다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i는 0과 같다";
case 1:
    echo "i는 1과 같다";
case 2:
    echo "i는 2와 같다";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    여기에서, <varname>$i</varname>가 0이라면, PHP는 모든 echo문을
    실행합니다! <varname>$i</varname>가 1이라면, PHP는 마지막 두 echo문을
    실행합니다. <varname>$i</varname>가 2일 때만, 원하는 동작('i는 2와 같다'
    표시)을 합니다. 따라서, <literal>break</literal>을 잊어서는 안됩니다.
    (어떤 경우에는 일부러 빠트릴 수 있어도, 잊지 마십시오)
   </simpara>
   <simpara>
    <literal>switch</literal>구문에서, 조건문은 오직 한번만 평가되고
    각 <literal>case</literal>문에서 결과가 비교되어진다.
    <literal>elseif</literal>문에서는 조건문은 다시 평가된다. 조건문이 
    한번 이상의 비교가 필요한 복잡한 것이거나 거친(tight) 루프안에 있다면
    <literal>switch</literal>문 좀 더 빠를것이다.
   </simpara>
   <para>
    case에 대한 구문 목록은 비어있을수 있다. 이것은 단순히 다음 case문으로
    제어권을 넘겨줄 뿐이다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
case 1:
case 2:
    echo "i는 3보다 작지만 음수는 아닙니다.";
    break;
case 3:
    echo "i는 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    특별한 case가 바로 <literal>default</literal> case문이다. 이것은 다른 case문과
    모두 조건이 맞지 않을때의 경우를 위한것이고, <literal>case</literal>구문의 
    마지막에 위치해야 한다. 예제 코드는 다음과 같다:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i는 0과 같다";
    break;
case 1:
    echo "i는 1과 같다";
    break;
case 2:
    echo "i는 2와 같다";
    break;
default:
    echo "i는 0, 1, 2 어느것도 아니다";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>case</literal>의 표현식은 정수나 부동소수점 수와 문자열같은
    단순형으로 평가되는 어던 표현식도 될수 있다. 여기에 단순형으로
    재참조(dereference)되지 않는 배열이나 객체를 사용할수는 없다.
   </para>
   <para>
    switch문을 위한 제어 구조의 대체 문법이 지원된다. 더 자세한 정보는
    <link linkend="control-structures.alternative-syntax">제어 구조의 대체 문법</link>을 참고.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
case 0:
    echo "i equals 0";
    break;
case 1:
    echo "i equals 1";
    break;
case 2:
    echo "i equals 2";
    break;
default:
    echo "i is not equal to 0, 1 or 2";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    <literal>declare</literal>구문은 코드 블록의 수행 디렉티브(directive)를
    활성화하기 위해 사용된다.
    <literal>declare</literal>문법은 다른 흐름 제어 구조의 문법과
    비슷하다:
    <informalexample>
     <programlisting>
<![CDATA[
declare (directive) statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>directive</literal>부분은 <literal>declare</literal>블록의 동작이
    활성화되도록 해준다. 현재는 오직 한 디렉티브만 인식된다:
    <literal>ticks</literal> 디렉티브. (더 자세한 정보는
    <link linkend="control-structures.declare.ticks">ticks</link> 디렉티브를 볼것)
   </para>
   <para>
    <literal>declare</literal>블록의 <literal>statement</literal>부분이 수행될것이다
    - 어떻게 수행이 되고 수행중에 어떤 사이드 이펙트가 발생할지는 
    <literal>directive</literal>블록의 디렉티브에 달려있다.
   </para>
   <para>
    <literal>declare</literal> 구문은 전역 유효영역 안에서 사용할수 있다.
    그래서 모든 코드가 그 디렉티브에 영향을 받는다. 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// 이들은 동일합니다:

// 이를 사용할 수 있습니다:
declare(ticks=1) {
    // 여기에 전체 스크립트
}

// 또는 이렇게 사용할 수 있습니다:
declare(ticks=1);
// 여기에 전체 스크립트
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 xml:id="control-structures.declare.ticks">
    <title>틱(Ticks)</title>
    <para>
    틱은 <literal>declare</literal>블록에서 파서에 의해 수행되는
    <varname>N</varname> 저레벨(low-level) 구문마다 발생하는
    이벤트이다. <varname>N</varname> 값은 
    <literal>declare</literal>블록의 <literal>directive</literal>부분에서
    <code>ticks=<varname>N</varname></code> 으로 지정할수 있다.
   </para>
   <para>
    각 틱에서 발생하는 이벤트(들)은 <function>register_tick_function</function>함수
    를 써서 지정한다. 자세한 것은 아래 예제를 볼것. 각 틱에서는 하나 이상의
    이벤트가 발생할수 있음에 주의해야 한다.
   </para>
   <para>
    <example>
     <title>PHP 각 코드 섹션의 분석표만들기(Profile)</title>
     <programlisting role="php">
<![CDATA[
<?php
// 호출될대의 시간을 기록하는 함수
function profile($dump = FALSE)
{
    static $profile;

    // Profile에 저장된 모든 시간 리턴하고, 삭제함
    if ($dump) {
        $temp = $profile;
        unset($profile);
        return $temp;
    }

    $profile[] = microtime();
}

// 틱 핸들러 설정
register_tick_function("profile");

// declare 블록 전에 함수를 초기화
profile();

// 코드 블록의 실행하고, 두번째 구문에 틱을 부여함
declare(ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />;";
    }
}

// 분석표에 저장된 데이터를 출력
print_r(profile(TRUE));
?>
]]>
     </programlisting>
    </example>
    위 예제 코드는 실행 블록안의 두번째  저레벨(low-level) 구문의
    시간에 따라 'declare'블록 안의 PHP코드를 분석한다. 이런 정보로
    어느 코드 부분에서 느려지는지 알아볼 수 있다. 이런 처리방법은
    다른 기법으로 수행할수있다: 틱을 이용하는 것은 좀더 편하고
    좀더 구현하기 쉽다.
   </para>
   <simpara>
    틱은 디버깅, 단순한 멀티태스킹 구현, 백그라운드 I/O와 다른 많은 작업
    에 적합하게 이용할수 있다.
   </simpara>
   <simpara>
    <function>register_tick_function</function>함수와
    <function>unregister_tick_function</function>함수를 참고하세요.
   </simpara>
   </sect2>
  </sect1>

  <sect1 xml:id="function.return">
   <title>return</title>
   <simpara>
    <function>return</function>문이 함수안에서 호출된다면, 현재 함수의
    수행을 즉시 끝내고, 함수 호출 결과값으로 return의 인자값을 넘겨준다.
    <function>return</function>문은 <function>eval</function>함수나 
    스크립트 파일의 수행을 종료시킨다.
   </simpara>
   <simpara>
    전역 유효범위에서 호출된다면, 현재 스크립트 파일의 수행을 끝마친다.
    현재 스크립트가 <function>include</function>나 <function>require</function>되었다면,
    호출하고 있는 파일로 제어를 넘긴다. 더욱이, 현재 스크립트 파일이 
    <function>include</function>되어있는것이면, <function>return</function>에 주어지는
    값은 <function>include</function>호출에 대한 값으로 넘겨줄것이다.
    <function>return</function>이 주 스크립트 파일에서 호출되면, 스크립트의
    수행이 종료된다. 현재 스크립트 파일이 &php.ini;의 
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link>이나 
    <link linkend="ini.auto-append-file">auto_append_file</link> 옵션에 의해 
    명명되었다면, 스크립트 파일의 수행은 중단된다.
   </simpara>
   <simpara>
   좀더 자세한 정보는 <link linkend="functions.returning-values">Returning values</link>
   을 참고하세요.
   </simpara>
   <para>
    <note>
     <simpara>
      <function>return</function>은 함수가 아닌 언어 구조이기 때문에, 인자를
      괄호로 쌀 필요가 없습니다. 괄호가 없는 것이 일반적으로, PHP가 더 적은
      일을 하게 합니다.
     </simpara>
    </note>
    <note>
     <simpara>
      반환값이 참조로 반환될 때는 <emphasis>절대로</emphasis> 괄호를 사용하면
      안되며, 동작하지 않습니다. 참조는 변수만 반환할 수 있으며, 구문 결과는
      반환할 수 없습니다. <literal>return ($a);</literal>를 사용한다면, 변수를
      반환하지 않고 <literal>($a)</literal> 표현의 반환값을 반환합니다. (물론,
      <varname>$a</varname>의 값입니다)
     </simpara>
    </note>
   </para>
  </sect1>


 <sect1 xml:id="function.require">
   <title><function>require</function></title>

   <simpara>
    <function>require</function>문은 특정 파일을 인클루드하고, 적용시킨다.
   </simpara>
   <simpara>
     <function>require</function>문은 특정 파일을 인클루드하고, 적용시킨다.
     이런 인클루드가 어떻게 동작하는지에 대한 자세한 정보는 <function>include</function>에
     대한 문서에서 설명한다.
   </simpara>
   <simpara>
    <function>require</function>와 <function>include</function>는 수행 실패를
    다루는 방법을 제외하고 완전히 동일합니다. 둘 모두 <link
     linkend="errorfunc.constants.errorlevels.e-warning">Warning</link>을
    발생시키지만, <function>require</function>는 <link
     linkend="errorfunc.constants.errorlevels.e-error">Fatal Error</link>가
    나타납니다. 즉, 파일이 없을 때 페이지 처리를 멈추고 싶으면
    <function>require</function>를 사용하면 됩니다.
    <function>include</function>는 멈추지 않고 스크립트가 계속 실행됩니다.
    또한, 적합한 <link linkend="ini.include-path">include_path</link> 설정인지
    확인해야 합니다.
   </simpara>
   <para>
    <example>
     <title>기본적인 <function>require</function> 사용예</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    더 많은 예제 코드는 <function>include</function>문서에서 볼수있다.
   </simpara>
   <para>
    <note>
     <simpara>
      PHP 4.0.2 이전 버전에서는 다음 규칙이 적용된다: <function>require</function>는
      어떤줄도 수행되지 않는 목적 파일도 무작정 읽어 들이려 한다. 조건절에서는
      <function>require</function>가 효과적이지 않다. 하지만, <function>require</function>
      되는 어떤 줄도 수행되지 않으면 목적 파일의 어떤 코드도 수행되지 않을것이다. 
      이와 유사하게, 루프 구조에서도 <function>require</function>는 효과적이지 않다.
      목적파일내에 포함된 코드가 계속 루프를 반복한다면,
      <function>require</function>는 오직 한번만 발생한다.
     </simpara>
    </note>
   </para>

   &note.language-construct;

   &warn.no-win32-fopen-wrapper;

   <simpara>
    참고: <function>include</function>, <function>require_once</function>,
    <function>include_once</function>,
    <function>get_included_files</function>, <function>eval</function>,
    <function>file</function>, <function>readfile</function>,
    <function>virtual</function>, <link
     linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 xml:id="function.include">
   <title><function>include</function></title>
   <simpara>
    <function>include</function>문은 특정 파일을 인클루드 하고, 적용시킨다.
   </simpara>
   <simpara>
    아래 내용은 <function>require</function>에도 적용됩니다. 두 구조는 수행
    실패를 다루는 방법을 제외하고 완전히 동일합니다. 둘 모두 <link
     linkend="errorfunc.constants.errorlevels.e-warning">Warning</link>을
    발생시키지만, <function>require</function>는 <link
     linkend="errorfunc.constants.errorlevels.e-error">Fatal Error</link>가
    나타납니다. 즉, 파일이 없을 때 페이지 처리를 멈추고 싶으면
    <function>require</function>를 사용하면 됩니다.
    <function>include</function>는 멈추지 않고 스크립트가 계속 실행됩니다.
    또한, 적합한 <link linkend="ini.include-path">include_path</link> 설정인지
    확인해야 합니다. 
    PHP 4.3.5 이전에는 포함한 파일 안에서 해석 오류가 발생해도 수행을 멈추지
    않는 점에 주의하십시오. 이 버전부터는 멈춥니다.
   </simpara>
   <simpara>
    파일을 포함할 때는 먼저 현재 작업 디렉토리에서 상대 경로로 include_path를
    찾고, 실행중인 스크립트가 있는 디렉토리를 찾습니다. 즉, include_path가
    <literal>libraries</literal>이고, 현재 작업 디렉토리가 <filename
     class="directory">/www/</filename>이며, 포함한 파일
    <filename>include/a.php</filename>에 <literal>include
     "b.php"</literal>가 있으면, <filename>b.php</filename>는 먼저 <filename
     class="directory">/www/libraries/</filename>에서 찾고, 그 후에
    <filename class="directory">/www/include/</filename>을 찾습니다. 파일
    이름이 <literal>./</literal>이나 <literal>../</literal>로 시작하면, 현재
      작업 디렉토리에 상대적인 include_path 안에서만 찾습니다.
   </simpara>
   <simpara>
     파일이 인클루드 되면, 그 코드를 포함하는 코드는 인클루드가 발생한 줄의
     <link linkend="language.variables.scope">변수 유효 범위</link>를 물려받는다.
     호출하는 파일의 그 줄에서 사용되는 어떤 변수도 그 줄부터는 호출된 파일안에서 
     사용이 가능하다.
     그러나, 포함한 파일에서 선언한 모든 함수와 클래스는 전역 영역에
     들어갑니다.
   </simpara>
   <para>
     <example>
      <title>기본적인 <function>include</function> 사용예</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     인클루드가 호출하는 파일안의 함수내에서 발생한다면, 호출된 파일안의
     모든 코드가 그 함수에서 정의된것처럼 동작한다. 그래서, 그 함수의 변수
     유효범위를 따를것이다.
   </simpara>
   <para>
     <example>
     <title>함수 내에서 인클루드하기</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php is in the scope of foo() so     *
 * $fruit is NOT available outside of this  *
 * scope.  $color is because we declared it *
 * as global.                               */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     파일이 인클루드되면, 파싱은 PHP모드의 밖으로 나가서 목적 파일의 시작부분은
     HTML모드로 들어가게 되고, 끝부분에서 원래대로 회복된다. 이때문에,
     목적 파일에서 PHP코드로서 수행되어야 하는 코드는 
     <link linkend="language.basic-syntax.phpmode">유효한 PHP 시작과 마침 태그</link>
     로 막아줘야 한다.
   </simpara>
   <simpara>
     PHP에서 "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"가 
     활성화되어 있으면 (디폴트 설정임), URL(HTTP나 다른 지원 래퍼(wrapper) -
     프로토콜 목록은 <xref linkend="wrappers"/>을 참고)을 사용하여 파일을 인클루드
     할수 있다. 목적 서버가 목적 파일을 PHP코드로 해석한다면, HTTP GET으로 사용된
     URL 리퀘스트 문자열은 변수로서 넘겨지게 될것이다. 이와같은 일은 파일을 인크루드
     하고 부모 파일의 변수 유효범위를 상속하는 것과 같은 경우가 되지는 않는다.
     스크립트는 실질적으로 원격 서버에서 실행이 되고 나서 로컬 스크립트에 포함된다.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>HTTP로 <function>include</function>하기</title>
     <programlisting role="php">
<![CDATA[
<?php

/* This example assumes that www.example.com is configured to parse .php
 * files and not .txt files. Also, 'Works' here means that the variables
 * $foo and $bar are available within the included file. */

// Won't work; file.txt wasn't handled by www.example.com as PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Won't work; looks for a file named 'file.php?foo=1&bar=2' on the
// local filesystem.
include 'file.php?foo=1&bar=2';

// Works.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Works.
include 'file.php';  // Works.

?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <title>보안 경고</title>
    <para>
     원격 파일은 원격 서버에서 실행(파일 확장자와 원격 서버가 PHP를
     실행하는가에 따라 다릅니다)되지만, 로컬 서버에서 실행할 수 있는 유효한
     PHP 스크립트를 만들 수도 있습니다. 원격 서버에서만 실행한 결과를 그대로
     출력해야 한다면, <function>readfile</function> 함수가 더 적합합니다.
     아니라면, 원격 스크립트가 유효하고 적합한 코드를 생성하도록 특별한
     주의를 기울이십시오.
    </para>
   </warning>
   <para>
    참고: <link linkend="features.remote-files">원격 파일</link>,
    <function>fopen</function>, <function>file</function>에 관련 정보가
    있습니다.
   </para>
   <simpara>
    반환 다루기: include한 파일 안에서 그 파일의 수행을 종료하고, 호출한
    스크립트로 돌아가기 위해서 <function>return</function>문을 실행할 수
    있습니다. 또한, 값을 반환하는 일도 가능합니다. include 호출을 일반 함수를
    사용한 것처럼 값을 받을 수 있습니다. 그러나, 원격 파일을 포함하였을 때, 그
    파일의 출력이 (다른 로컬 파일처럼) <link
     linkend="language.basic-syntax.phpmode">유효한 PHP 시작과 끝
     태그</link>를 가지지 않는다면 이 값을 받을 수 없습니다. 이 태그들 안에
    필요한 값을 정의하면, include한 파일의 어떤 위치에서라도 사용할 수
    있습니다.
   </simpara>
   <para>
    <function>include</function>은 특별한 언어 구조이기 때문에, 인자를 괄호로
    쌀 필요가 없습니다. 반환값을 비교할 때는 조심하십시오.
    <example>
     <title>include의 반환값 비교하기</title>
     <programlisting role="php">
<![CDATA[
<?php
// include(('vars.php') == 'OK'), 즉 include('')로 인식하여 작동하지 않습니다.
if (include('vars.php') == 'OK') {
    echo 'OK';
}

// 작동합니다.
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <note>
     <simpara>
      PHP 3에서 그 블록이 함수가 아니면 블록 안에 return이 보이지 않을것이다.
      그런 경우에는 전체 파일이 아니고 그 함수로만 <function>return</function>이 적용된다.
     </simpara>
    </note>
   </para>
   <para>
    <example>
     <title><function>include</function>와 <function>return</function>문</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // prints 'PHP'

$bar = include 'noreturn.php';

echo $bar; // prints 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    include가 성공했기 때문에 <literal>$bar</literal>의 값은
    <literal>1</literal>입니다. 위 예제 사이의 차이에 주목하십시오. 처음 것은
    포함한 파일 안에서 <function>return</function>을 사용하였지만, 다른 것은
    하지 않았습니다. 파일을 포함할 수 없으면 &false;를 반환하고
    <literal>E_WARNING</literal>을 발생합니다.
   </simpara>
   <para>
    포함한 파일에서 함수를 정의하면, 어디서 <function>return</function>을
    했는지에 관계 없이 메인 파일에서 사용할 수 있습니다. 파일이 두번 포함되면,
    PHP 5는 함수가 이미 정의되어 있기 때문에 치명적인 오류를 발생하지만, PHP
    4는 <function>return</function> 뒤에 정의했다면 불평하지 않습니다. 이미
    포함한 파일을 확인하기 위해서는 포함한 파일 안에서 조건적으로 return하기
    보다는 <function>include_once</function>를 사용하는 것을 권합니다.
   </para>
   <simpara>
    PHP 파일을 변수로 "포함"하는 또 다른 방법은 <link
     linkend="ref.outcontrol">출력 제어 함수</link>를
    <function>include</function>와 함께 사용하여 출력을 캡쳐하는 것입니다.
    예를 들면:
   </simpara>
   <para>
    <example>
     <title>PHP 파일을 포함하여 문자열로 변환하기 위해 출력 버퍼링
      사용하기</title>
     <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_constents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    스크립트 안에 자동으로 파일을 포함하기 위해서는, &php.ini;의 <link
     linkend="ini.auto-prepend-file">auto_prepend_file</link>과 <link
     linkend="ini.auto-append-file">auto_append_file</link> 설정 옵션을
    참고하십시오.
   </para>
   
   &note.language-construct;

   <simpara>
    참고: <function>require</function>, <function>require_once</function>,
    <function>include_once</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    <function>virtual</function>, <function>virtual</function>, <link
     linkend="ini.include-path">include_path</link>.
   </simpara>
 </sect1>

 <sect1 xml:id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    <function>require_once</function>문은 스크립트 수행기간 중에 특정파일을
    인클루드하고 적용시킨다. 이것은 <function>require</function>문과 비슷하게
    동작한다. 오직 파일의 코드가 이미 인클루드되었다면 다시 인클루드되지 않을것
    이라는 차이점이 있다. 이 구문이 어떻게 작용하는지에 대한 정보를 알아보려면
    <function>require</function>함수에 대한 문서를 보세요.
   </para>
   <para>
    <function>require_once</function>는 특정 스크립트 수행기간동안 한번이상
    인클루드되고 적용될수 있는 상황에서 사용하도록 한다. 그리고 함수 중복 정의와
    변수값 중복 지정 등에 대한 문제를 회피하기 위해서는 
    정확히 한번 인클루드될 필요가 있을것이다.
   </para>
   <para>
     <function>require_once</function>과 <function>include_once</function>의
     사용예는 최신 PHP 소스코드 안에 포함된 <link xlink:href="&url.php.pear;">PEAR</link>코드를
     참고할것.
   </para>
   <para>
    반환값은 <function>include</function>와 동일합니다. 파일이 이미
    포함되었면, &true;를 반환합니다.
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function>는 PHP 4.0.1에 추가되었다.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function>와 <function>include_once</function>은
      대소문자를 구별하지 않는 운영체제(윈도우 같은)에서는 기대하던대로
      동작하지 않을지 모른다.
      <example>
       <title><function>require_once</function>는 윈도우에서 대소문자를
        구별하지 못합니다.</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // a.php를 포함합니다.
require_once("A.php"); // 윈도우에서 또다시 a.php를 포함합니다. (PHP 4만)
?>
]]>
        </programlisting>
      </example>
      이 동작은 PHP 5에서 바뀌었습니다 - 경로가 먼저 표준화되기 때문에
      <filename>C:\PROGRA~1\A.php</filename>은 <filename>C:\Program
       Files\a.php</filename>와 동일하게 인식하고, 파일은 딱 한번만 포함하게
      됩니다.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    참고: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    <function>virtual</function>.
   </para>
  </sect1>

 <sect1 xml:id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    <function>include_once</function>문은 스크립트 수행기간동안 특정파일을
    인클루드하고 적용시킨다. 이것은 <function>include</function>문과 비슷하게
    동작한다. 단지 파일의 특정 코드가 이미 인클루되었다면 그 코드는 다시는 인클루드
    될수 없다는 차이점만 있다. 이 이름이 제시하듯이 한번만 인클루드할것이다.
   </para>
   <para>
    <function>include_once</function>는 특정 스크립트 수행기간동안 동일한 파일이
    한번 이상 인클루드되고 적용될지도 모르는 상황에서 사용해야 할것이다.
    그리고 함수 중복정의, 변수값 중복 지정 등의 문제를 회피하려면 정확히 한번만
    인클루드할 때가 있을것이다.
   </para>
   <para>
    <function>require_once</function>와 <function>include_once</function>의 더 많은 사용예는, 
    최신 PHP소스 내의 <link xlink:href="&url.php.pear;">PEAR</link>코드를 참고할것
   </para>
   <para>
    반환값은 <function>include</function>와 동일합니다. 파일이 이미
    포함되었면, &true;를 반환합니다.
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function>는 PHP 4.0.1에서 추가됨
     </para>
    </note>
   </para>
   <para>
   <note>
     <para>
      <function>include_once</function>와 <function>require_once</function>는
      대소문자를 구별하지 않는 운영체제(윈도우같은)에서 기대와 다르게 작동할수도 있다.
      <example>
       <title><function>include_once</function>는 윈도우에서 대소문자를
        구별하지 못합니다.</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // a.php를 포함합니다.
include_once("A.php"); // 윈도우에서 또다시 a.php를 포함합니다. (PHP 4만)
?>
]]>
        </programlisting>
      </example>
      이 동작은 PHP 5에서 바뀌었습니다 - 경로가 먼저 표준화되기 때문에
      <filename>C:\PROGRA~1\A.php</filename>은 <filename>C:\Program
       Files\a.php</filename>와 동일하게 인식하고, 파일은 딱 한번만 포함하게
      됩니다.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    참고: <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    <function>virtual</function>.
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
