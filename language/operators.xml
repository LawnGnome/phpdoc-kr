<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.7 $ -->
<!-- EN-Revision: 1.51 -->
 <chapter id="language.operators">
  <title>연산자</title>
  <simpara>
  </simpara>
  
  <sect1 id="language.operators.precedence">
   <title>연산자 우선순위</title>
   <para>
    연산자 우선순위는 두개의 표현식을 연산자로 얼마나 더 단단하게 연결할
    것인지를 명시한다 . 예를 들면, <literal>1 + 5 * 3</literal>의 결과는 
    <literal>18</literal>이 아니라 <literal>16</literal>이 된다. 왜냐하면
    곱셈 ("*") 연산자가 덧셈 ("+") 연산자보다 우선순위가 높기 때문이다.
    필요한 경우, 괄호를 사용해서 우선순위를 높일수 있다. 예를 들면, 
    <literal>(1 + 5) * 3</literal>의 결과는 <literal>18</literal>이 된다.
   </para>
   <para>
    다음 테이블은 낮은 우선순위를 갖는 연산자부터 연산자 우선순위 목록을
    보였다.
    <table>
     <title>연산자 우선순위</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associativity</entry>
        <entry>Operators</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>left</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>! ~ ++ -- (int) (float) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <note>
    <para>
     <literal>!</literal>이 <literal>=</literal>보다 높은 우선 순위를
     갖지만, PHP는 여전히 다음과 같은 표현식을 허용한다:
     <literal>if (!$a = foo())</literal> 즉, <varname>$a</varname>에 
     입력되는 <literal>foo()</literal>의 결과에 대한 조건문
    </para>
   </note>
  </sect1>

  <sect1 id="language.operators.arithmetic">
   <title>산술 연산자</title>
   <simpara>
    학교에서 배운 기본적인 산수를 기억는가? 이 연산자들은 그런 연산자
    와 똑같이 동작한다.
   </simpara>
   <table>
    <title>산술 연산자</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>예</entry>
       <entry>이름</entry>
       <entry>결과</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>덧셈</entry>
       <entry>$a와 $b의 합</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>뺄셈</entry>
       <entry>$a와 $b의 차</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>곱셈</entry>
       <entry>$a와 $b의 곱</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>나눗셈</entry>
       <entry>$a를 $b로 나눈 몫</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>나머지</entry>
       <entry>$a를 $b로 나눈 나머지</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    두 피연산자가 정수(또는 정수로 변환되는 문자열)일지라도  
    나눗셈 연산자 ("/")는 부동소수점 값을 돌려준다.
   </simpara>
   <simpara>
    <link linkend="ref.math">수학 함수</link>의 매뉴얼 페이지를 참고.
   </simpara>

   <!--
   <simpara>
    The division operator ("/") returns an integer value (the result
    of an integer division) if the two operands are integers (or
    strings that get converted to integers) and the quotient is an
    integer. If either operand is a floating-point value, or the
    operation results in a non-integer value, a floating-point value
    is returned.
   </simpara>
   -->
  </sect1>
  
  <sect1 id="language.operators.assignment">
   <title>지정 연산자</title>
   <simpara>
    기본적인 지정 연산자는 "="이다. 이 연산자를 "같다"라고 생각할수 있느나,
    그렇지 않다. 이 연산자는 좌측 피연산자에 우측의 표현식 값을 지정한다.
    (즉, "지정한다").
   </simpara>
   <para>
    지정 표현식의 값이 지정된다. 즉, "$a = 3"의 값은 3이다. 
    이런 규칙으로 인해 몇가지의 교묘한(tricky) 일을 할수 있다.
    <informalexample>
     <programlisting role="php"> 
<![CDATA[
$a = ($b = 4) + 5; // $a is equal to 9 now, and $b has been set to 4.
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    기본적인 지정 연산자 외에 이진 산술과 문자열 연산자와 같은 "복합 연산자"
    가 지원된다. 이런 연산자는 표현식의 값을 사용하여 그 표현식의 결과를
    그 값으로 사용할수 있다. 예를 들면:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = 3;
$a += 5; // sets $a to 8, as if we had said: $a = $a + 5;
$b = "Hello ";
$b .= "There!"; // sets $b to "Hello There!", just like $b = $b . "There!";
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    지정은 원래 변수에 새로운 변수(값으로 지정된)를 복사한다. 
    그래서 어떤 변수를 변경하는것은 다른 변수에 아무 영향을 주지 못한다.
    견고한 루프안에 큰 배열같은 것을 복사한다면 이 주제와 밀접한 관련이 있다.
    PHP 4는 <computeroutput>$var = &amp;$othervar;</computeroutput>같은 문법으로
    참조에 의한 지정을 지원한다. 그러나 PHP 3에서는 지원되지 않는다.
    '참조에 의한 지정'은 두 변수가 같은 데이터를 가리키도록 하고 아무것도 복사하지
    않는다는 것을 의미한다. 참조에 관한 자세한 정보는 
    <link linkend="language.references">참조 표현</link>을 참고.
   </para>
  </sect1>

  <sect1 id="language.operators.bitwise">
   <title>비트 연산자</title>
   <simpara>
    비트 연산자는 특정 비트를 정수로 on이나 off로 전환하도록 한다.
    좌측과 우측 인자가 문자열이면, 비트 연산자는 이 문자열안의 문자에 대해
    계산하게 된다.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
    echo 12 ^ 9; // Outputs '5'

    echo "12" ^ "9"; // Outputs the Backspace character (ascii 8)
                     // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

    echo "hallo" ^ "hello"; // Outputs the ascii values #0 #4 #0 #0 #0
                            // 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </informalexample> 
   </para>

   <table>
    <title>비트 연산자</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Example</entry>
       <entry>Name</entry>
       <entry>Result</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>And</entry>
       <entry>Bits that are set in both $a and $b are set.</entry>
      </row>
      <row>
       <entry>$a | $b</entry>
       <entry>Or</entry>
       <entry>Bits that are set in either $a or $b are set.</entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>Xor</entry>
       <entry>
	Bits that are set in $a or $b but not both are set.
       </entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>Not</entry>
       <entry>
	Bits that are set in $a are not set, and vice versa.
       </entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>Shift left</entry>
       <entry>
	Shift the bits of $a $b steps to the left (each step means
	"multiply by two")
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>Shift right</entry>
       <entry>
	Shift the bits of $a $b steps to the right (each step means
	"divide by two")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect1>

  <sect1 id="language.operators.comparison">
   <title>비교 연산자</title>
   <simpara>
    비교 연산자는 그 이름에서 알수 있듯이, 두 값을 비교한다.
   </simpara>
   <table>
    <title>비교 연산자</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Example</entry>
       <entry>Name</entry>
       <entry>Result</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Equal</entry>
       <entry>&true; if $a is equal to $b.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identical</entry>
       <entry>
	&true; $a와 $b가 같으려면, 둘 모두 같은 타입이어야 함 (PHP 4에서만)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Not equal</entry>
       <entry>&true; if $a is not equal to $b.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Not equal</entry>
       <entry>&true; if $a is not equal to $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Not identical</entry>
       <entry>
	&true; $a가 $b와 같지 않다면, 둘 모두 같은 타입이 아니다 (PHP 4에서만)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Less than</entry>
       <entry>&true; if $a is strictly less than $b.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Greater than</entry>
       <entry>&true; if $a is strictly greater than $b.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Less than or equal to </entry>
       <entry>&true; if $a is less than or equal to $b.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Greater than or equal to </entry>
       <entry>&true; if $a is greater than or equal to $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    다른 조건 연산자에는 C나 다른 많은 언어와 같은 동작을 하는 
    "?:" (삼중) 연산자가 있다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Example usage for: Ternary Operator
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// The above is identical to this if/else statement
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
]]>
     </programlisting>
    </informalexample> 
    <literal>(expr1) ? (expr2) : (expr3)</literal>표현식은
    <replaceable>expr1</replaceable>가 &true;이면
    <replaceable>expr2</replaceable>이 적용되고,
    <replaceable>expr1</replaceable>가 &false;이면
    <replaceable>expr3</replaceable>으로 적용된다.
   </para>
   <para>
    <function>strcasecmp</function>, <function>strcmp</function>과
    <link linkend="language.types">타입</link>에 관한 매뉴얼 섹션을
    참고
   </para>
  </sect1>

  <sect1 id="language.operators.errorcontrol">
   <title>에러 제어 연산자</title>
   <simpara>
    PHP는 에러 제어 연산자를 지원한다: 앳 부호 (@). PHP에서 표현식의
    앞에 덧붙이면, 그 표현식에서 발생할수 있는 에러 메시지가 출력되지 않도록 한다.
    <link linkend="ini.track-errors">track_errors</link> 기능은 활성화되어있으면,
    표현식에서 발생하는 모든 에러는 
    <link linkend="reserved.variables.phperrormsg">$php_errormsg</link>변수에
    저장될것이다. 이 변수는 에러가 발생할 때마다 덮어씌어질것이고, 그래서
    이 변수를 사용하려면 바로바로 확인해야 한다.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Intentional file error */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// this works for any expression, not just functions:
$value = @$cache[$key]; 
// will not issue a notice if the index $key doesn't exist.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     @-연산자는 <link linkend="language.expressions">표현식</link>에서만 동작한다.
     단순한 규칙: 표현식의 값을 취할수 있으면, 그 표현식 앞에 @ 연산자를 덧붙일수 있다.
     예를 들면, 변수, 함수, <function>include</function>호출, 상수 등의 앞에 
     덧붙일수 있다. 그러나 함수나 클래스 선언부, <literal>if</literal>같은 조건문,
     <literal>foreach</literal> 등에 이 부호를 덧붙일수는 없다.
    </simpara>
   </note>
   <simpara>
    <function>error_reporting</function>함수와
    <link linkend="ref.errorfunc">Error Handling and Logging functions</link>에
    관한 매뉴얼 섹션을 참고.
   </simpara>
   <note>
    <para>
     "@" 에러-제어 연산자는 해석 에러로 인한 에러 메시지를 가릴수는 없을것이다.
    </para>
   </note>
   <warning>
    <para>
     현재 "@" 에러-제어 연산자는 스크립트 수행을 멈출수 있는 심각한 에러에
     대한 에러 메시지들도 보이지 않게 할것이다. 이말의 의미는 어떤 함수에서
     에러 메시지를 보이지 않게 하려하려고 "@"을 사용했고 그 함수가 가용하지
     않거나 오타를 쓴것일지라도 이 스크립트는 에러 원인에 대한 메시지 없이 
     그자리에서 즉시 멈추게 될것이다.
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.operators.execution">
   <title>실행 연산자</title>
   <para>
    PHP는 실행 연산자를 지원한다 (``). 이 연산자는 작은 따옴표가 아니라는
    것에 주의하라! PHP는 백틱(``)안에 묶인 내용을 셀 명령으로서 실행하려
    할 것이다; 출력이 돌려질것이다 (출력을 단순히 덤프하려 하지 않는다;
    출력을 변수로 지정할 수 있다) 백틱 연산자는 <function>shell_exec</function> 
    함수를 쓰는것과 동일한다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
$output = `ls -al`;
echo "<pre>$output</pre>";
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     &safemode;가 활성화되었거나
     <function>shell_exec</function>가 비활성화되어 있을때는
     백틱 연산자는 비활성화된다.
    </para>
   </note>
   <para>
    <link linkend="ref.exec">Program Execution functions</link>, 
    <function>popen</function> <function>proc_open</function>,
    <link linkend="features.commandline">Using PHP from the commandline</link>에 관한
    매뉴얼 섹션을 참고
   </para>
  </sect1>

  <sect1 id="language.operators.increment">
   <title>증가/감소 연산자</title>
   <para>
    PHP는 C-스타일의 전처리와 후처리 증가/감소 연산자를 지원한다.
   </para>
   <table>
    <title>증가/감소 연산자</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Example</entry>
       <entry>Name</entry>
       <entry>Effect</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-increment</entry>
       <entry>Increments $a by one, then returns $a.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-increment</entry>
       <entry>Returns $a, then increments $a by one.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-decrement</entry>
       <entry>Decrements $a by one, then returns $a.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-decrement</entry>
       <entry>Returns $a, then decrements $a by one.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    단순한 예제 스크립트:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Should be 5: " . $a++ . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Preincrement</h3>";
$a = 5;
echo "Should be 6: " . ++$a . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Postdecrement</h3>";
$a = 5;
echo "Should be 5: " . $a-- . "<br />\n";
echo "Should be 4: " . $a . "<br />\n";

echo "<h3>Predecrement</h3>";
$a = 5;
echo "Should be 4: " . --$a . "<br />\n";
echo "Should be 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP는 문자 변수에 관한 산술 연산을 할때 C 방식이 아니라 펄 방식을 따른다.
    예를 들면, 펄에서 'Z'+1은 'AA'를 전환되는 반면, C에서 'Z'+1은
    '[' ( ord('Z') == 90, ord('[') == 91 )으로 전환된다. 문자 변수는 증가될수는
    있으나 감소될수는 없다는 것에 주의해야 한다.
    <example>
     <title>문자 변수에 대한 산술 연산</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for($n=0; $n<6; $n++)
  echo ++$i . "\n";

/*
  Produces the output similar to the following:

X
Y
Z
AA
AB
AC

*/
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="language.operators.logical">
   <title>논리 연산자</title>

   <table>
    <title>논리 연산자</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Example</entry>
       <entry>Name</entry>
       <entry>Result</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>And</entry>
       <entry>&true; if both $a and $b are &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Or</entry>
       <entry>&true; if either $a or $b is &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Xor</entry>
       <entry>&true; if either $a or $b is &true;, but not both.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Not</entry>
       <entry>&true; if $a is not &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>And</entry>
       <entry>&true; if both $a and $b are &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Or</entry>
       <entry>&true; if either $a or $b is &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    두개의 다른 "and"와 "or" 연산자를 쓰는 이유는 그들이 다른 
    우선순위를 가지고 있기 때문이다. 
    (<link linkend="language.operators.precedence">연산자 우선순위</link>를 참고)
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>문자열 연산자</title>
   <simpara>
    두개의 <type>문자열</type> 연산자가 지원된다. 첫번째것은 결합연산자 ('.')이고
    좌측과 우측의 피연산자를 결합한 값을 돌려준다. 두번째것은 결합 지정 연산자('.=')이다.
    이런 연산자는 좌측 인자로 우측 인자를 추가한다.
    자세한 정보는 <link linkend="language.operators.assignment">지정 연산자</link>를 참고
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = "Hello ";
$b = $a . "World!"; // now $b contains "Hello World!"

$a = "Hello ";
$a .= "World!";     // now $a contains "Hello World!"
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <link linkend="language.types.string">String type</link>,
    <link linkend="ref.strings">String functions</link>에 관한 매뉴얼 섹션을 참고
   </para>
  </sect1>
  
  <sect1 id="language.operators.array">
   <title>배열 연산자</title>
   <simpara>
    PHP에서 배열 연산자는 <literal>+</literal>연산자만 지원된다. 이 연산자는
    좌측 배열에 우측 배열을 추가한다. 그리고 중복된 키는 덮어 씌어지지 않는다.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = array("a" => "apple", "b" => "banana");
$b = array("a" =>"pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b;

var_dump($c);
]]>
     </programlisting>
    </informalexample>
    위 스크립트가 수행되면, 다음과 같이 출력될것이다:
    <screen role="php">
<![CDATA[
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}

]]>
    </screen>
   </para>
   <para>
    <link linkend="language.types.array">Array type</link>과
    <link linkend="ref.array">Array functions</link> 매뉴얼 섹션을 참고
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
