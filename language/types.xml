<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.13 $ -->
<!-- EN-Revision: 1.119 -->
 <chapter id="language.types">
  <title>타입</title>

  <sect1 id="language.types.intro">
  <title>소개</title>
  
  <simpara>
   PHP는 8가지의 기본 타입을 지원한다.
  </simpara>
  
  <para>
   4가지 스칼라 타입:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>boolean</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>integer</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>float</type> (floating-point number, aka '<type>double</type>')
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>string</type>
     </simpara>
    </listitem>

   </itemizedlist>

   2가지 복합 타입:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>array</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>object</type>
     </simpara>
    </listitem>

   </itemizedlist>

   그리고 최종적으로 다음의 2가지 타입:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>resource</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>NULL</type>
     </simpara>
    </listitem>

   </itemizedlist>

   이 매뉴얼에서는 몇가지의
   <link linkend="language.pseudo-types">의사(pseudo) 타입</link>도 소개한다.
   for readability reasons:

   <itemizedlist>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">mixed</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.number">number</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">callback</link>
     </simpara>
    </listitem>

   </itemizedlist>
   "double" 타입과 비슷한 타입을 볼수 있을것이다. double은 float과
   같은 타입이다. 두개의 타입이 존재하는 이유는 역사적인 이유일뿐이다.
  </para>
  
  <simpara>
   보통은 프로그래머가 변수의 타입을 결정할수 없다.
   대신에, PHP가 변수가 사용되는 환경에 따라 실시간으로 결정하게 된다.
  </simpara>
  <note>
   <simpara>
    <link linkend="language.expressions">표현식</link>의 타입과 값을
    확인하려한다면, <function>var_dump</function>을 사용한다.
   </simpara>
   <para>
    디버깅을 위해 타입을 판독하려고 하면, <function>gettype</function>를 사용한다.
    정확히 어떠 타입을 사용하는지 확인하려면 <function>gettype</function>함수를 사용하지
    <emphasis>말고</emphasis>, <literal>is_<replaceable>type</replaceable></literal>함수를 
    사용하도록 한다. 몇가지 예제 코드를 보자:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // a boolean
$str  = "foo";  // a string
$int  = 12;     // an integer

echo gettype($bool); // prints out "boolean"
echo gettype($str);  // prints out "string"

// If this is an integer, increment it by four
if (is_int($int)) {
    $int += 4;
}

// If $bool is a string, print it out
// (does not print out anything)
if (is_string($bool)) {
    echo "String: $bool";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>
  <simpara>
   변수를 다른 타입으로 변경하려한다면 변수를 <link linkend="language.types.typecasting">캐스트</link>하거나
   <function>settype</function>함수를 사용하면 된다. 
  </simpara>
  <simpara>
   변수는 특수한 상황에서는 그 당시에 무슨 타입을 쓰는지에 따라
   다른 값으로 변경될수 있다는 것에 주의 해야 한다. 자세한 정보는
   <link linkend="language.types.type-juggling">타입 저글링</link>을 참고.
  </simpara>
 </sect1>
   
   <sect1 id="language.types.boolean">
    <title>불린</title>
    
    <simpara>
     이 타입은 가장 쉬운 타입니다.<type>boolean</type>은 논리값을
     표현한다. &true; 나 &false; 값이 될수 있다.
    </simpara>

    <note>
     <simpara>
      boolean 타입은 PHP 4부터 지원되었다.
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>문법</title>
     <para>
      boolean 을 표현하기 위해서 키워드 &true; 나 &false;를 사용한다.
      두 가지 모두 대소문자를 구별하지 않는다.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo = True; // assign the value TRUE to $foo
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      보통은 <type>boolean</type>값을 돌려주는 몇 가지 
      <link linkend="language.operators">연산자</link>를 사용해서
      그 값을 <link linkend="control-structures">제어 구조</link>로 전달한다.

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// == is an operator which test
// equality and returns a boolean
if ($action == "show_version") {
    echo "The version is 1.23";
}

// this is not necessary...
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// ...because you can simply type
if ($show_separators) {
    echo "<hr>\n";
}
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>boolean으로 변환</title>
      <simpara>
       명시적으로 <type>boolean</type> 값으로 변경하려면
       <literal>(bool)</literal>이나 <literal>(boolean)</literal> 캐스트를 사용한다.
       하지만, 대부분의 경우 이런 캐스트를 사용할 필요는 없다. 왜냐하면 그 값은
       연산자나 함수 또는 제어구조가 <type>boolean</type>인자를 요구하면 자동으로
       변환된다.
      </simpara>
      <simpara>
       <link linkend="language.types.type-juggling">타입 저글링</link>도 참고.
      </simpara>
      
      <para>
       <type>boolean</type>로 변경할때, 다음값은 &false;로 본다:
  
       <itemizedlist>
        <listitem>
         <simpara><link linkend="language.types.boolean">boolean</link> 
          &false; 자체</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.integer">integer</link
         > 0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.float">float</link> 
         0.0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>비어있는 <link linkend="language.types.string">문자열</link>과
                  <link linkend="language.types.string">문자열</link> "0"</simpara>
        </listitem>
        <listitem>
         <simpara>아무 구성요소도 갖지 않는 <link linkend="language.types.array">배열</link>
         </simpara>
        </listitem>
        <listitem>
         <simpara>아무 멤버 변수도 갖지 않는 <link linkend="language.types.object">객체</link> 
         </simpara>
        </listitem>
        <listitem>
         <simpara>특별한 타입인 <link linkend="language.types.null">NULL</link> 
                 (변수를 unset하는 것도 포함)
         </simpara>
        </listitem>
       </itemizedlist>
       
       이 외의 다른 모든 값은 &true;로 본다 
       (모든 <link linkend="language.types.resource">자원</link>이 포함됨).
       <warning>
        <simpara>
         모든 0이 아닌 (양수이든 음수이든) &true;가 되는 것처럼
         <literal>-1</literal>은 &true;로 본다, 
        </simpara>
       </warning>
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
echo gettype((bool) "");        // bool(false)
echo gettype((bool) 1);         // bool(true)
echo gettype((bool) -2);        // bool(true)
echo gettype((bool) "foo");     // bool(true)
echo gettype((bool) 2.3e5);     // bool(true)
echo gettype((bool) array(12)); // bool(true)
echo gettype((bool) array());   // bool(false)
?>
]]>
        </programlisting>
       </informalexample>
      </para>
     </sect2>
   </sect1>

   <sect1 id="language.types.integer">
    <title>정수</title>
    
    <simpara>
     <type>integer</type>는 거대한 집합
     Z = {..., -2, -1, 0, 1, 2, ...}이다.
    </simpara>
     
    <para>
     <link linkend="ref.gmp">Arbitrary length integer / GMP</link>,
     <link linkend="language.types.float">부동 소수점수</link>,
     <link linkend="ref.bc">Arbitrary precision / BCMath</link>를 참고
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>문법</title>
     <simpara>
      정수는 10진수(10-based), 16진수(16-based), 8진수(8-based) 표기법으로 표현
      될수 있다. 선택적으로 부호 (- 나 +)를 사용할수 있다.
     </simpara>
     <para>
      8진수 표기법을 사용하면, <literal>0</literal> (zero)를 숫자의 앞에
      붙여야 하며, 16진수 표기하려면 <literal>0x</literal>을 숫자 앞에
      붙이도록 한다.
      <example>
       <title>정수 리터럴</title>
       <programlisting role="php">
<![CDATA[
<?php
$a = 1234; # decimal number
$a = -123; # a negative number
$a = 0123; # octal number (equivalent to 83 decimal)
$a = 0x1A; # hexadecimal number (equivalent to 26 decimal)
?>
]]>
       </programlisting>
      </example>
      공식적으로 가능한 정수 리터럴의 구조는 다음과 같다:
      <informalexample>
       <programlisting>
<![CDATA[
<?php
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
?>
]]>
       </programlisting>
      </informalexample>
      약 20억을 최대값(부호가 있는 32비트)으로 사용할수 있을지라도, 
      정수의 크기는 플랫폼에 따라 달라지게 된다. PHP는 
      부호없는(unsigned) 정수 를 지원하지 않는다.
     </para>
    </sect2>
   
    <sect2 id="language.types.integer.overflow">
     <title>정수 오버플로우</title>
     <para>
      <type>정수</type>타입의 범위를 넘는 수를 사용하려면 그 값은 대신
      <type>float</type>타입으로 해석될 것이다. 또한, 
      결과값이 <type>integer</type>타입의 범위를 초과하게 되는 작업을 수행되면, 
      그 값은 대신 <type>float</type>으로 돌려줄것이다.
     
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// output: int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// output: float(2147483648)

// this goes also for hexadecimal specified integers:
var_dump( 0x80000000 );
// output: float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// output: float(50000000000)
?>
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        불운하게도, PHP는 버그로 인해 음수와 연계될때 정확하게 동작하지 
        않을수 있다. 예를 들면 <literal>-50000 * $million</literal>를 수행하면, 결과는
        <literal>-429496728</literal>이 될것이다. 두 피연산자가 모두 양수이면
        아무 문제가 없다.

       </simpara>
       <simpara>
        이 문제는 PHP 4.1.0에서 해결되었다.
       </simpara>
      </warning>
     </para>
     <para>
      PHP에는 정수 나누기 연산자가 없다.
      <literal>1/2</literal>는 <type>float</type> <literal>0.5</literal>가 된다.
      반올림하기 위해 정수로 값을 캐스트하거나, <function>round</function>
      함수를 쓸수 있다.

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286) 
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4) 
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>정수로 변환하기</title>
      <simpara>
       명시적으로 <type>integer</type>로 변환하려면 <literal>(int)</literal>나
       <literal>(integer)</literal> 캐스트를 사용한다.
       하지만, 대부분의 경우 이런 캐스트를 사용할 필요가 없다. 왜냐하면 연산자
       나 함수 또는 제어 구조가 <type>integer</type> 인수를 요구한다면 자동으로
       변환되기 때문이다. 또한 <function>intval</function>함수로 정수값으로 
       변환할수 있다.
      </simpara>
      <simpara>
       See also <link linkend="language.types.type-juggling">type-juggling</link>.
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title><link linkend="language.types.boolean">불린</link>에서</title>
       <simpara>
        &false;는 <literal>0</literal> (zero), 그리고
        &true;는 <literal>1</literal> (one).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title><link linkend="language.types.float">부동소수점수</link>에서</title> 
       <simpara>
        float에서 integer로 변환할때, 그 수는 <emphasis>0으로</emphasis> 깍일것이다.
       </simpara>
       
       <para>
        float이 integer범위를 초과하면 (주로 <literal>+/- 2.15e+9 = 2^31</literal>), 
        결과는 정의되지않는다. 왜냐하면 float은 정확한 정수값을 돌려주기에
        충분한 정밀도를 갖지 않기 때문이다. 이 경우에는 warning이나 notice조차도
        나타나지 않는다!
       </para>
       
       <warning><para>
        알려지지 않은 소수를 <type>integer</type>로 캐스트하지 말것, 
        왜냐하면 이렇게 하는경우에 종종 기대하지 않는 결과를 유도할수
        있기 때문이다.
        <informalexample>
         <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // echoes 7!
?>
]]>
         </programlisting>
        </informalexample>
        자세한 정보는 <link linkend="warn.float-precision">부동-정밀도에 관한 경고</link>를
        참고.
        
       </para></warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>문자열로부터</title>
       <simpara>
        <link linkend="language.types.string.conversion">문자열을 숫자로 
        변환하기</link>를 참고
       </simpara>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-other">
       <title>다른 타입으로부터</title>
       <para>
        <caution>
         <simpara>
          정수로의 변환은 다른 타입에 대해 정의되지 않는다. 현재까지는 값이 
          <link linkend="language.types.boolean.casting">불린으로 변환</link>될때와 
          동일하게 동작한다. 하지만, 경고 없이 변할수 있기 
          때문에 이 동작에 연관짓지 <emphasis>말것</emphasis>
         </simpara>
        </caution>
       </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>부동소수점</title>
   <para>
    부동소수점(AKA "floats", "doubles", "real numbers")은 다음과 같은
    문법으로 표현될수 있다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;
?>
]]>
     </programlisting>
    </informalexample>
    공식적으로:
    <informalexample>
     <programlisting role="php">
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
     </programlisting>
    </informalexample>
    float의 크기는 십진수 14자리가 일반적인 값(64비트 IEEE 포맷)이 되는
    정밀도를 갖는 ~1.8e308까지의 최대값을 갖을지라도 플랫폼에 따라 달라진다.
   </para>
 
   <warning id="warn.float-precision">
    <title>부동소수점 정밀도</title>
    <para>
     <literal>0.1</literal>이나 <literal>0.7</literal>와 같은 단순한
     십진수의 분수는 약간의 정밀도의 소실없이 내부적인 이진처리로 변환될
     수 없다. 이 사실은 혼란스런 결과를 유도할수 있다: 예를 들면,
     <literal>floor((0.1+0.7)*10)</literal>은 기대값 <literal>8</literal>이 아닌
     <literal>7</literal>을 돌려준다. 내부적인 표현이
     <literal>7.9999999999...</literal>와 같을것이기 때문이다.
    </para>
    <para>
     이와 같은 이유로 유한값의 십진표기법을 쓰는 몇몇 소수를 정확히 표현할수 
     없다는 것이다. 예를 들면, 십진표기법의 <literal>1/3</literal>은 
     <literal>0.3333333. . .</literal>이 된다.
    </para>
    <para>
     결코 부동소수점이 마지막 수를 갖을수 있을것이라고 생각하거나 부동소수점이
     동일한지 비교하도록 해서는 안된다. 더 높은 정밀도가 필요하면, 대신
     <link linkend="ref.bc">arbitrary precision math functions</link>나
     <link linkend="ref.gmp">gmp</link>함수를 사용하도록 해야 한다.
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>float으로 변환하기</title>
    
    <para>
     문자열이 언제, 어떻게 float으로 변환하는지에 대한 정보는
     <link linkend="language.types.string.conversion">문자열을 숫자로 변환하기</link>섹션을 참고하라.
     다른 타입에 대한 변환은 그 값이 integer나 float으로 변환하는 방식과 동일하다.
     더 자세한 정보는 <link linkend="language.types.integer.casting">integer로 변환하기</link>를 참고.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.string">
   <title>문자열</title>
   <para>
    <type>string</type>은 일련의 문자들이다. PHP에서 문자는 바이트와 같다. 즉
    정확히 서로다른 256개의 문자를 사용할수 있다. 또한 PHP는 기본적으로 유니코드 지원을
    갖지않는다. 유니코드에 대한 지원은 <function>utf8_encode</function>과
    <function>utf8_decode</function>함수를 참고
   </para>
   <note>
    <simpara>
     문자열이 아무 문제없이 매우 커질수 있다. PHP에서 사용되는 문자열은 
     실질적으로 범위제한을 갖지 않는다. 그래서 긴 문자열에 대해서 걱정할
     이유가 전혀 없다.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>문법</title>
    <para>
     문자열 리터럴은 3가지 다른 방식으로 표현될수 있다.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">작은 따옴표</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">큰 따옴표</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">상속 문법</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>작은 따옴표</title>
     <para>
      단순한 문자열을 표현하는 가장 간단한 방법이 작은 따옴표
      (문자 <literal>'</literal>)로 문자열을 둘러싸면 된다.
     </para>
     <para>
      작은따옴표를 리터럴로 표현하려면 역슬래쉬(<literal>\</literal>)로
      회피할 필요가 있다. 다른 많은 언어에서도 이와같은 방식을 사용한다.
      작은 따옴표 앞이나 문자열의 끝에서 역슬래쉬가 있을필요가 있으면,
      이것은 중복사용할 필요가 있다. 다른 모든 문자를 회피하려하면 역슬래쉬가
      출력되어야 할것이란 것에 주의하라! 그래서 보통은 역슬래쉬 자체를 회피할
      필요가 없다.
      <note>
       <simpara>
        PHP 3에서 이와 같은 일이 발생하면 <literal>E_NOTICE</literal>레벨의
        경고가 출력될것이다.
       </simpara>
      </note>
      <note>
       <simpara>
        이외 다른 두가지 문법과는 달리 작은 따옴표로 둘러싸인 문자열에서
        <link linkend="language.variables">변수</link>와 특별한 문자를 위한 
        회피는 전개되지 못한다. 
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in 
strings this way as it is
okay to do';

// Outputs: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// Outputs: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// Outputs: Variables do not $expand $either
echo 'Variables do not $expand $either';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>큰 따옴표</title>
     <para>
      문자열이 큰따옴표(")로 둘러싸이면, PHP는 특별한 문자의
      회피를 더 잘 이해한다.
     </para>
     <table>
      <title>회피 문자</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>sequence</entry>
         <entry>meaning</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>linefeed (LF or 0x0A (10) in ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>carriage return (CR or 0x0D (13) in ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>horizontal tab (HT or 0x09 (9) in ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>backslash</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>dollar sign</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>double-quote</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          이 정규표현식은 8진표기법의 일련의 문자이다.
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          이 정규표현식은 16진표기법의 일련의 문자이다.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      다시 얘기하면, 다른 어떤 문자를 회피하려한다면, 역슬래쉬도
      출력될것이다!
     </para>
     <para>
      그러나 큰따옴표로 둘러싸인 문자열의 가장 중요한 특징은
      변수명이 전개될것이란 사실이다. 더 자세한 사항은
      <link linkend="language.types.string.parsing">문자열 해석</link>을
      참고.
     </para>
    </sect3>
    
    <sect3 id="language.types.string.syntax.heredoc">
     <title>히어닥 문법</title>
     <simpara>
      문자열을 구분하는 다른 방법은 히어닥 문법("&lt;&lt;&lt;")을
      사용하는것이다. 
      <literal>&lt;&lt;&lt;</literal>이후에 식별자가 와야 하고
      그다음에 문자열, 그다음에 인용을 닫는 어떤 식별자가 와야 한다.
     </simpara>
     <simpara>
      닫기 식별자는 그 줄의 첫번째 컬럼에서 시작<emphasis>되어야 한다</emphasis>.
      또한, 식별자는 PHP의 다른 라벨과 같은 명명규칙을 따라야 한다:
      오직 알파벳 숫자와 밑줄을 포함하고 숫자가 아닌 문자나 밑줄로
      시작되어야 한다.
     </simpara>
     
     <warning>
      <simpara>
       닫기 식별자를 갖는 줄은 <emphasis>가능한</emphasis> 
       세미콜른(<literal>;</literal>)를 제외하고
       다른 문자를 포함하지 않는다는것에 주의해야 한다. 이말은 특별히
       식별자가 <emphasis>줄맞춤이 되지 않을 것</emphasis>이고 어떤 공백이나 탭문자도
       세미콜른의 앞이나 뒤에 있지 않을것이란 것이다. 닫기 식별자 전의
       첫 문자는 운영체제에서 정의된 새줄이 되어야 한다는 것을 인식해야 한다.
       예를 들면 매킨토시에서는 <literal>\r</literal>이 된다.
      </simpara>
      <simpara>
       이 규칙을 깨고 닫기 식별자가 "확실"하지 않으면, 닫기 식별자로
       인식되지 않으며 PHP는 다른 식별자를 계속 찾게 될것이다. 그래서 적절한
       닫기 식별자가 발견되지 않으면 스크립트 끝의 줄번호로 해석 에러가
       출력될것이다.
      </simpara>
     </warning>

     <para>
      히어닥 텍스트는 큰따옴표가 없지만 큰따옴표로 둘러싸인 문자열처럼 동작한다.
      히어닥에서는 따옴표를 회피할 필요가 없다는 의미를 갖는다. 그러나 여전히
      위에서 열거한 회피 코드를 사용할수 있다. 문자가 전개되면, 히어닥 안의
      복합 변수를 문자열로 표현할때 같은 주의가 필요하다.
      <example> 
       <title>히어닥 문자열 인용 예</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       히어닥 지원은 PHP 4에서 추가되었다.
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>변수 해석</title>
     <simpara>
      문자열이 큰따옴표나 히어닥으로 표현되면
      <link linkend="language.variables">변수</link>는 그 안에서 해석된다.
     </simpara>
     <simpara>
      두가지 형태의 문법이 존재한다:
      <link linkend="language.types.string.parsing.simple">단순</link>문법과
      <link linkend="language.types.string.parsing.complex">복합</link>문법이다.

      단순 문법은 가장 일반적이고 가장 편하다. 이 문법은 
      변수나 <type>array</type>값, <type>object</type>속성을 해석하는
      방법을 제공한다.
     </simpara>
     <simpara>
      복합 문법은 PHP 4에서부터 지원되고, 중괄호로 둘러싸는 표현으로 인식된다.
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>단순 문법</title>
      <simpara>
       달러사인(<literal>$</literal>)과 만나면, 해석기는 가능한 많은
       토큰을 취해서 유효한 변수명을 형성하게 된다. 중괄호로 변수명을
       둘러싸면 이름의 끝을 명시적으로 표시하려는 것이다. 
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // works, "'" is an invalid character for varnames
echo "He drank some $beers";   // won't work, 's' is a valid character for varnames
echo "He drank some ${beer}s"; // works
echo "He drank some {$beer}s"; // works
?>
]]>
       </programlisting>
      </informalexample>
      <simpara>
       비슷하게, <type>array</type> 인덱스나 해석된 <type>object</type>특성을 보유할수
       있다. 배열 인덱스로 닫음 대괄호 (<literal>]</literal>)는 인덱스의 끝을 표시한다.
       객체 속성은 변수를 갖는 트릭이 존재하지 않지만, 객체 특성에 대해서 단순한 변수에
       적용되는 규칙과 같다. 
       
       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// These examples are specific to using arrays inside of strings.
// When outside of a string, always quote your array string keys 
// and do not use {braces} when outside of strings either.

// Let's show all errors
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// Works but note that this works differently outside string-quotes
echo "A banana is $fruits[banana].";

// Works
echo "A banana is {$fruits['banana']}.";

// Works but PHP looks for a constant named banana first
// as described below.
echo "A banana is {$fruits[banana]}.";

// Won't work, use braces.  This results in a parse error.
echo "A banana is $fruits['banana'].";

// Works
echo "A banana is " . $fruits['banana'] . ".";

// Works
echo "This square is $square->width meters broad.";

// Won't work. For a solution, see the complex syntax.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       좀더 복잡한 변수에 대해서, 복합 문법을 사용해야 한다.
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>복합(curly) 문법</title>
      <simpara>
       이 방법은 문법이 복합적이라서 복합이라고 부르는것이 아니다.
       대신에 이 방법으로 복합 표현식을 포함할수 있기 때문이다.
     </simpara>
     <simpara>
      사실, 이 문법으로 문자열의 네임스페이스에 존재하는 어떤변수
      도 포함할수 있다. 단순히 문자열을 드러내는 방법과 동일한 표현식을
      쓸수 있다. 그리고 { 과 } 안에 그것을 포함한다. '{'를 회피할
      수 없기 때문에 이 문법은 $가 즉시 {뒤에 올때만 인식된다.
      ("{$" 리터럴을 쓰려면  "{\$" 이나 "\{$" 을 사용하라).
      몇가지 예를 보고 위 설명을 이해해보자:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Let's show all errors
error_reporting(E_ALL);

$great = 'fantastic';

// Won't work, outputs: This is { fantastic}
echo "This is { $great}";

// Works, outputs: This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Works
echo "This square is {$square->width}00 centimeters broad."; 

// Works
echo "This works: {$arr[4][3]}";

// This is wrong for the same reason as $foo[bar] is wrong 
// outside a string.  In otherwords, it will still work but
// because PHP first looks for a constant named foo, it will
// throw an error of level E_NOTICE (undefined constant).
echo "This is wrong: {$arr[foo][3]}"; 

// Works.  When using multi-dimensional arrays, always use
// braces around arrays when inside of strings
echo "This works: {$arr['foo'][3]}";

// Works.
echo "This works: " . $arr['foo'][3];

echo "You can even write {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>문자열 내의 문자에 접근하기</title>
     <para>
      문자열 내의 문자들 중 원하는 문자를 중괄호안에
      제로-베이스 오프셋을 표기하여 접근할수 있다.
     </para>
     <note>
      <simpara>
       하위버전의 호환성을 위해, 같은 목적으로 배열-중괄호를 사용할수 있다.
       하지만, 이 문법은 PHP 4에서 사용할수 없다.
       For backwards compatibility, you can still use array-braces
       for the same purpose. However, this syntax is deprecated as
       of PHP 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>몇 가지 문자열 예</title>
       <programlisting role="php">
<![CDATA[
<?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str{0};

// Get the third character of a string
$third = $str{2};

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str{strlen($str)-1}; 
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>유용한 함수와 연산자</title>
    <para>
     문자열들은 '.' (점) 연산자를 사용하여 합칠수 있다. '+' (덧셈) 연산자는
     이 목적에 부합되지 않는다는 것에 주의해야 한다. 자세한 정보는
     <link linkend="language.operators.string">문자열 연산자</link>를 참고
    </para>
    <para>
     문자열 조작을 위한 많은 유용한 함수가 지원된다.
    </para>
    <simpara>
     일반적인 기능을 대해서는 <link linkend="ref.strings">문자열 함수 섹션</link>을
     참고하고, 향상된 find&amp;replace 기능을 위해 정규표현식 함수를 참고
     (두가지 중 선택할수 있다:
     <link linkend="ref.pcre">Perl</link>과 
     <link linkend="ref.regex">POSIX extended</link>).
    </simpara>
    <simpara>
     <link linkend="ref.url">URL-문자열을 위한 함수</link>와
     문자열을 encrypt/decrypt하는 함수도 지원된다.
     (<link linkend="ref.mcrypt">mcrypt</link>과
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     그래도 원하는 기능을 찾을수 없다면,
     <link linkend="ref.ctype">문자 타입 함수</link>로 참고.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>문자열로 변환</title>
    
    <para>
     <literal>(string)</literal>이나 <function>strval</function>함수를 사용하여
     값을 문자열로 변환할수 있다. 문자열 변환은 문자열이 필요한 표현식의 유효영역
     내에서 자동적으로 이루어진다.이런 일은 <function>echo</function>나 
     <function>print</function>함수를 쓸때, 또는 변수값을 문자열과 비교할때 발생한다.
     <link linkend="language.types">타입</link>과 
     <link linkend="language.types.type-juggling">타입 저글링</link> 매뉴얼 섹션을
     읽음으로써 다음에서 설명하는 것을 더욱 명확하게 이해하게 될것이다.
     <function>settype</function>함수도 참고.
    </para>
    
    <para>
     <type>boolean</type> &true;값은 문자열 <literal>"1"</literal>로 변환된다.
     &false; 값은 <literal>""</literal> (빈 문자열)로 표현된다.
     이 원리로 불린과 문자열값 사이에서 어느 방향으로든 변환이 가능하다.
    </para>
    <para> 
     <type>integer</type>나 부동소수점(<type>float</type>)은 각 자리의 숫자를
     문자열로 변환할수 있다 (부동소수점수에 대한 지수부를 포함함).
    </para>
    <para>
     배열은 항상 문자열 <literal>"Array"</literal>로 변환된다. 그래서 
     배열 안에 무엇이 들었는지 보기 위해 <function>echo</function>나 
     <function>print</function>를 쓴다고 해서 <type>array</type>의 내용을 덤프할수 없다.
     한 요소를 보기 위해서는 <literal>echo $arr['foo']</literal>와 같이 써줘야 한다.
     전체 내용물을 덤프/보기 위한 팁을 아래글에서 볼수 있다.
    </para>
    <para>
     객체는 항상 문자열 <literal>"Object"</literal>로 변환된다. 만약 
     디버깅 목적으로 <type>object</type>의 멤버 변수를 모두 출력하고 싶으면,
     아래 단락을 보라. 특정 객체를 만들어내는 클래스명을 확인하려한다면,
     <function>get_class</function>를 사용하라.
    </para>
    <para>
     자원은 항상 구조체 <literal>"Resource id #1"</literal>를 갖는 문자열로
     변환된다. <literal>1</literal>은 실행기간동안 PHP에 의해 설정되는
     <type>resource</type>의 유일한 수이다. 자원의 타입을 얻고자 하면,
     <function>get_resource_type</function>함수를 사용하라.
    </para>
    <para>
     &null; 은 항상 빈 문자열로 변환된다.
    </para>
    
    <para>
     위글에서 볼수 있듯이, 배열, 객체 또는 자원을 출력하는 것은 배열자체에
     대한 어떤 유용한 정보도 제공해주지 않는다. 디버깅을 위해 그 값들을
     출력하는 가장 좋은 방법인 <function>print_r</function>과 
     <function>var_dump</function> 함수를 참고할것.
    </para>
    
    <para>
     PHP 값을 지속적으로 저장하기 위해 문자열로 변환할수 있다. 이런 방법을
     직렬화(serialization)라고 한다. 함수 <function>serialize</function>를
     사용하면 된다. PHP 값을 XML 구조체로 직렬화할수도 있다.
     PHP 설정시 <link linkend="ref.wddx">WDDX</link> 지원 옵션을 추가하면 된다.
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>문자열을 숫자로 변환하기</title>

    <simpara>
     문자열을 숫자값으로 취급할때, 결과값과 타입은 다음과 같이 결정된다.
    </simpara>
    <simpara>
     그 값이 '.', 'e', 'E' 중에 어느것이든 포함하고 있으면 <type>float</type>으로
     취급될것이다. 그렇지 않으면, 정수로 취급할것이다.
    </simpara>
    <para>
     그 값은 문자열의 시작부분에 의해 주어진다. 문자열이 유효한 숫자
     데이터로 시작되면, 이것이 사용되는 값이 될것이다. 그렇지 않으면
     그 값은 0(zero)로 된다. 유효한 숫자 데이터는 선택적인 부호,
     한자리 이상(선택적인 십진 포인트를 포함)의 수, 선택적인 지수가 될수있다.
     지수는 한자리 이상의 수가 'e' 이나 'E'의 뒤에 오면 된다.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo is float (11.5)
$foo = 1 + "-1.3e3";              // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo is integer (1)
$foo = 1 + "bob3";                // $foo is integer (1)
$foo = 1 + "10 Small Pigs";       // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;          // $foo is float (11)
$foo = "10.0 pigs " + 1.0;        // $foo is float (11)     
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     이런 종류의 변환에 대한 더 많은 정보는 strtod(3)의 
     유닉스 매뉴얼 페이지에서 볼수 있다.
    </simpara>
    <para>
     이 섹션의 어떤 예제를 테스트하려면, 예제를 복사해서 붙여넣으면 되고
     무슨일이 일어나는지 확인하기 위해 다음 줄을 삽입할수 있다.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     정수로 변환하여 한 문자의 코드를 얻을수 있다고 기대하지 마시오
     (예를 들면 C에서 하는 것처럼). 캐릭터코드와 문자 사이의 변환을
     위해서는 <function>ord</function>와 <function>chr</function>함수를
     사용할수 있다.
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>배열</title>

   <para>
    PHP에서 배열은 실질적으로 순서가 있는 맵이다. 한 맵은 
    <emphasis>values</emphasis>를 <emphasis>keys</emphasis>로 맵핑하는
    타입이다. 이 타입은 몇가지 목적에 의해 옵티마이징될수 있다.
    그래서 그 타입을 실제 배열이나 리스트(vector), 해쉬테이블(map의 구현),
    딕셔너리(dictionary), 컬렉션(collection), 스택(stack), 큐(queue),
    등등으로 사용할수 있다. 다른 PHP 배열을 값으로 갖을수 있기 때문에,
    트리(tree)를 아주 쉽게 시뮬레이션할수 있다.
   </para>
   <para>
    그런 데이터 구조(자료 구조)는 이 매뉴얼의 범위를 벗어난다. 그러나 
    그들 각각의 예를 최소한 하나는 발견할수 있을것이다. 자세한 정보를
    위해 이 광범위한 주제에 대한 참고서적을 제시해줄것이다.
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>문법</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title><function>array</function>함수로 명기</title>
     <para>
      <type>array</type>는 <function>array</function> 언어-구조에 의해 생성될수 있다.
      이 함수는 콤마로 구분되는 
      몇 개의 <literal><replaceable>key</replaceable> =&gt; <replaceable>value</replaceable></literal>쌍을
      취할수 있다.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> may be an <type>integer</type> or <type>string</type>
// <replaceable>value</replaceable> may be any value
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      <varname>key</varname>는 <literal>integer</literal>나 <type>string</type>타입이
      될수 있다. key가 표준적인 <type>integer</type>타입이면, 그 값으로 해석될것이다
      (즉, <literal>"8"</literal>은 <literal>8</literal>로 해석되는 반면,
      <literal>"08"</literal>은 <literal>"08"</literal>로 해석된다). PHP에서
      인덱스 배열과 연관 배열 사이는 아무 차이가 없다; 오직 하나의 배열 타입만이 있는데,
      그 배열은 정수나 문자열 인덱스를 모두 포함할수 있다.
     </para>
     <para>
      값은 모든 종류의 PHP 타입이 될수 있다.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      주어진 값에 대한 key를 표기하지 않으면, 정수 인덱스의 최대값이
      취해져서 새로운 key는 최대값 + 1이 될것이다--최대값이 음수가 아니면
      (음수 배열 인덱스를 갖는것은 가능하다). 이 경우에, 새로운 key는
      <literal>0</literal>이 될것이다. 정수 인덱스가 아직 존재하지 않으면,
      key는 <literal>0</literal> (zero)이 될것이다. 그 key가 이미 할당되어
      있는데도 지정하면, 그 key로 값이 덮어씌워질것이다.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// This array is the same as ...
array(5 => 43, 32, 56, "b" => 12);

// ...this array
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      key로 &true;를 사용하는 것은 <type>integer</type> <literal>1</literal>
      key가 될것이다. key로 &false;를 사용하면 <type>integer</type> <literal>0</literal>
      key가 될것이다. key로 <literal>NULL</literal>을 사용하면 빈 문자열로
      취급될것이다. key로 빈문자열을 사용하는 것은 빈 문자열을 갖는 key를
      만들고 그 값을 생성 (또는 덮어씀)한다; 빈 대괄호를 사용하는것과는 다르다.
     </para>
     <para>
      key로 배열이나 객체를 사용할수 없다. 그렇게 하면 다음과 같은 경고가
      발생할것이다: <literal>Illegal offset type</literal>.
     </para>
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>대괄호 문법을 사용하여 생성/변경</title>
     <para>
      그 안에 값을 명시적으로 표시함으로써 기존의 배열을 변경할수 있다.
     </para>
     <para>
      이와 같은 일은 대괄호 안에 key를 표시함으로해서 배열에 
      값을 지정하여 수행한다. key를 빼먹을수도 있고, 그 경우에
      변수명에  빈 대괄호("<literal>[]</literal>")를 추가한다.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> may be an <type>integer</type> or <type>string</type>
// <replaceable>value</replaceable> may be any value
      </synopsis>
      <varname>$arr</varname>이 아직 존재하지 않으면, 생성될것이다.
      그래서 이 방법이 배열을 표현하는 대안이 된다. 어떤 값을 변경하려면,
      그 key로 표현되는 요소에 새로운 값을 지정한다. key/value 쌍을 제거하려면,
      그것을 <function>unset</function>할 필요가 있다.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // This is the same as $arr[13] = 56;
                // at this point of the script

$arr["x"] = 42; // This adds a new element to
                // the array with key "x"
                
unset($arr[5]); // This removes the element from the array

unset($arr);    // This deletes the whole array
?>
]]> 
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       위에서 설명한바와 같이, key가 없는 대괄호를 사용한다면, 존재하는
       정수 인덱스의 최대값이 취해질것이고, 새로운 key는 최대값의 + 1이
       될것이다--최대값이 음수가 아니면(음수 배열 인덱스를 갖는것은 완벽하게
       합법이다). 그 경우에 새로운 key는 <literal>0</literal>이 된다.
       정수 인덱스가 아직 존재하지 않으면, key는 <literal>0</literal> (zero)이 될것이다.
       이미 존재하는 key로 지정하면, 그 값은 덮어씌어질것이다.
      </para>
      <para>
       이 목적을 위한 최대 정수 key는 <emphasis>현재까지는 배열 안에 
       존재할 필요가 없다</emphasis>. 단순히 배열을 마지막으로 인덱스
       한 이후 어떤 시간내에 배열 안에 존재해야 한다. 다음 예를 보면:
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Create a simple array.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Now delete every item, but leave the array itself intact:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Append an item (note that the new key is 5, instead of 0 as you
// might expect).
$array[] = 6;
print_r($array);

// Re-index:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]> 
       </programlisting>
       <para>
        위 예제 코드는 다음을 출력할것이다:
        <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
        </screen>
       </para>
      </informalexample>       

     </note>
    </sect3>
   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>유용한 함수</title>
    <para>
     배열을 위한 유용한 함수가 지원된다.
     <link linkend="ref.array">배열 함수</link> 섹션을 볼것.
    </para>
    <note>
     <para>
      <function>unset</function>함수는 항상 배열의 key를 unset한다. 배열이
      다시 인덱스되지 않을것이라는것에 주의한다. 오직 "가용한 정수 인덱스"를
      사용한다면(제로에서 시작해서, 하나씩 증가), <function>array_values</function>를
      사용하여 재인덱싱 효과를 수행할수 있다.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'one', 2 => 'two', 3 => 'three');
unset($a[2]);
/* will produce an array that would have been defined as
   $a = array(1 => 'one', 3 => 'three');
   and NOT
   $a = array(1 => 'one', 2 =>'three');
*/

$b = array_values($a);
// Now b is array(1 => 'one', 2 =>'three')
?>
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     <link linkend="control-structures.foreach">foreach</link> 제어 구조는
     배열을 위해 특별히 지원되는것이다. 배열 안을 이동하는 가장 빠른
     방법을 제공한다.
    </para>
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>배열이 하는것과 하지 않는것</title>

    <sect3 id="language.types.array.foo-bar">
     <title>왜 <literal>$foo[bar]</literal>이 잘못인가?</title>
     <para>
      항상 문자열 리터럴 배열 인덱스 주위에는 따옴표를 사용해야 한다.
      예를 들면, $foo['bar']을 사용하고 $foo[bar]은 사용하지 말라.
      그러나 왜 $foo[bar]이 잘못인가? 오래된 스크립트에서 다음 문법을
      볼수 있을것이다:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
       </programlisting>
      </informalexample>
      이것은 잘못된것이지만, 동작하다. 그렇다면, 왜 잘못인가? 그 이유는
      이 코드가 문자열('bar' - 따옴표 사용) 보다는 정의되지 않은 상수 (bar)를
      갖는다는것이다. 그리고 PHP는 미래에 상수를 정의할수 있는데, 불운하게도
      이 코드에서, 같은 이름을 갖을수도 있다. 이것은 잘 작동하는 이유는
      PHP가 자동으로 <emphasis>bare string</emphasis>(알려진 심벌과 대응되지
      않는 따옴표 없는 문자열)을 bare string을 포함하는 문자열로 변환하기
      때문이다. <constant>bar</constant>라는 이름으로 정의된 상수가 없으면,
      PHP는 그것을 <literal>'bar'</literal>로 대치시켜서 사용할것이다.
     </para>
     <note>
      <simpara>
       위 말은 <emphasis>항상</emphasis> key를 따옴표 처리하라는
       것이 아니다. <link linkend="language.constants">상수</link>나
       <link linkend="language.variables">변수</link>가 PHP에서 해석되는것을
       방지하기 위해  key에서 이들을 따옴표처리하지 않을수 있다.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Simple array:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nChecking $i: \n";
    echo "Bad: " . $array['$i'] . "\n";
    echo "Good: " . $array[$i] . "\n";
    echo "Bad: {$array['$i']}\n";
    echo "Good: {$array[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      <para>
       위 예제코드의 출력은 다음과 같다:
       <screen>
<![CDATA[
Checking 0: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad: 
Good: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad: 
Good: 1

Checking 1: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad: 
Good: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad: 
Good: 2
]]>        
       </screen>
      </para>
     </note>
     <para>
      위 사실을 설명하는 몇가지 예제 코드:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Let's show all errors
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Correct
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Incorrect.  This works but also throws a PHP error of
// level E_NOTICE because of an undefined constant named fruit
// 
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Let's define a constant to demonstrate what's going on.  We
// will assign value 'veggie' to a constant named fruit.
define('fruit', 'veggie');

// Notice the difference now
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// The following is okay as it's inside a string.  Constants are not
// looked for within strings so no E_NOTICE error here
print "Hello $arr[fruit]";      // Hello apple

// With one exception, braces surrounding arrays within strings
// allows constants to be looked for
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// This will not work, results in a parse error such as:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// This of course applies to using autoglobals in strings as well
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// Concatenation is another option
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      <constant>E_NOTICE</constant> 레벨 에러(<constant>E_ALL</constant>로 설정)
      를 보이기 위해 <function>error_reporting</function>함수를 쓸때,
      다음과 같은 에러를 보게 될것이다. 기본값으로, 
      <link linkend="ini.error-reporting">error_reporting</link>은 그들을
      보여주지 않는다.
     </para>
     <para>
      <link linkend="language.types.array.syntax">문법</link> 섹션에서
      설명한대로, 대괄호('<literal>[</literal>' 과 '<literal>]</literal>') 사이에
      표현식이 존재해야 한다. 이 말의 의미는 다음과 같은 코드를 쓸수 있다는 뜻이다:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      배열 인덱스로 값을 돌려주는 함수를 사용하는 예를 보인다. 
      전에 <literal>E_*</literal>와 같은 것을 보았듯이,
      PHP는 상수들을 알고 있다.

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      첫번째 예의<literal>bar</literal>처럼, <literal>E_ERROR</literal>는
      유효한 식별자라는것에 주의한다. 그러나 위 예는 다음과 같다:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      왜냐하면 <literal>E_ERROR</literal>는 <literal>1</literal>과 같기때문이다 etc.
     </para>
     <para>
      위 예에서 이미 설명했듯이, <literal>$foo[bar]</literal>은 작동하지만 잘못되었다.
      이 코드는 작동한다. 왜냐하면 이 문법에서 <literal>bar</literal>는
      상수 표현으로 인식될수도 있기 때문이다. 하지만, 이 경우에
      <literal>bar</literal>란 이름을 갖는 상수는 존재하지 않는다. PHP는
      문자그대로 <literal>bar</literal>를 표시했다고 인식해서
      문자열 <literal>"bar"</literal>으로 보기 때문이다.
      따옴표 쓰는것을 잊었다고 인식한다.
     </para>
     <sect4>
      <title>그래서 그것이 왜 나쁜가?</title>
      <para>
       미래의 어떤 시점에서, PHP 팀은 또다른 상수나 키워드를 추가할수도
       있거나, 애플리케이션안에 또다른 상수를 사용할수도 있다. 그러면
       이 경우에 어려움에 빠지게 된다. 예를 들면, 
       <literal>empty</literal>와 <literal>default</literal>워드는 이런 이유로
       사용할수 없다. 왜냐하면 그들은 특별한 
       <link linkend="reserved">예약 키워드</link>이기 때문이다.
      </para>
      <note>
       <simpara>
        배반복하지만, 큰따옴표로 둘러싼 <type>string</type>안에서 
        <literal>"$foo[bar]"</literal>이 유효하도록 따옴표를 배열 인덱스에
        둘러싸지 않는것이 유효한다. 그 이유에 대한 상세 설명을 위해
        위 예제코드를 보는 것은 물론
        <link linkend="language.types.string.parsing">문자열 안에서 해석되는 변수</link>에
        관한 섹션도 참고할것.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>배열로 변환</title>
    
    <para>
     다른 타입을 갖는: <type>integer</type>, <type>float</type>,
     <type>string</type>, <type>boolean</type>, <type>resource</type>,
     어떤 값을 <type>array</type>로 변환한다면, 한개의 요소를 갖는 (인덱스 0)
     배열을 얻을수 있다. 그 구성요소는 스칼라 값이다.
    </para>
    
    <para>
     <type>object</type>를 배열로 변환하면, 각 객체의 속성(멤버 변수)를 
     배열의 구성요소로서 취할수 있다. key는 멤버 변수명이 된다.
    </para>
    
    <para>
     &null;값을 배열로 변환하면, 빈 배열을 얻을수 있다.
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>예제 코드</title>
    <para>
     PHP에서 배열 타입은 다용도로 쓰인다. 그래서 여기서 배열의 완벽한
     능력을 보이기 위해 몇가지 예제 코드를 보일것이다.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// this
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // key will be 0
          );

// is completely equivalent with
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // key will be 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// will result in the array array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// or simply array('a', 'b', 'c')
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>array() 사용하기</title>
     <programlisting role="php">
<![CDATA[
<?php
// Array as (property-)map
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );
            
// strictly numerical keys
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// this is the same as array(0 => 7, 1 => 8, ...)

$switching = array(         10, // key = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // key = 6 (maximum of integer-indices was 5)
                    '8'  =>  2, // key = 8 (integer!)
                    '02' => 77, // key = '02'
                    0    => 12  // the value 10 will be overwritten by 12
                  );
                  
// empty array
$empty = array();         
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>컬렉션</title>
     <programlisting role="php">
<![CDATA[
<?php
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Do you like $color?\n";
}

/* output:
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
*/
?>
]]>
     </programlisting>
    </example>
    
    <para>
     현재까지 배열의 값을 이런 루프 안에서 직접 변경하는 것은 불가능하다는
     것에 주의해야 한다.
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &$color )
      
       See bug#3074
      -->
     다음과 같은 편법이 있다:
     <example id="language.types.array.examples.changeloop">
      <title>컬렉션</title>
      <programlisting role="php">
<![CDATA[
<?php
foreach ($colors as $key => $color) {
    // won't work:
    //$color = strtoupper($color);
    
    // works:
    $colors[$key] = strtoupper($color);
}
print_r($colors);

/* output:
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     이 예제 코드는 one-based 배열을 생성한다.
     <example>
      <title>One-based index</title>
      <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);

/* output:
Array 
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
*/
]]>   
      </programlisting>
     </example>
    </para>
    <example>
     <title>배열 채우기</title>
     <programlisting role="php">
<![CDATA[
// fill an array with all items from a directory
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle); 
?>
]]>
     </programlisting>
    </example>
    <para>
     배열은 순서가 있다. 다양한 정력함수를 사용하여 그 순서를 변경할수도 있다.
     더 자세한 정보는 <link linkend="ref.array">배열 함수</link>섹션을 참고.
     <function>count</function>함수를 사용하여  배열 내의 아이템 수를 셀수 있다.
    </para>
    <example>
     <title>배열 정렬하기</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     배열의 값은 어느것이든 될수 있기 때문에, 또한 다른 배열이 될수 있다.
     이 방식으로 재귀적이고 다차원인 배열을 만들수 있다.
    </para>
    <example>
     <title>재귀적이고 다차원인 배열</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6,
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Some examples to address values in the array above 
echo $fruits["holes"][5];    // prints "second"
echo $fruits["fruits"]["a"]; // prints "orange"
unset($fruits["holes"][0]);  // remove "first"

// Create a new multi-dimensional array
$juices["apple"]["green"] = "good"; 
?>
]]>
     </programlisting>
    </example>
    <para>
     배열 지정은 항상 값 복사에 관련되어 있다는 것을 알고 있어야 한다.
     참조에 의해 배열을 복사하려면 참조 연산자를 사용하여야 한다.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 is changed,
             // $arr1 is still array(2, 3)
             
$arr3 = &$arr1;
$arr3[] = 4; // now $arr1 and $arr3 are the same
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>객체</title>

   <sect2 id="language.types.object.init">
    <title>객체 초기화</title>

    <para>
     객체를 초기화하기 위해서는 변수로 객체를 인스턴스화하는 
     <literal>new</literal>문을 사용하라.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     더 자세한 사항은 <link linkend="language.oop">클래스와 객체</link> 섹션을
     참고한다.
    </simpara>
   </sect2>
   
   <sect2 id="language.types.object.casting">
    <title>객체로 변환하기</title>
    
    <para>
     객체가 객체로 변환되면, 그것은 변경되지 않는다. 다른 타입의 값이
     객체로 변환되면, <literal>stdClass</literal>내장 클래스의 새로운
     인스턴스가 생성된다. 그 값이 null이면, 새로운 인스턴스는 텅빌것이다.
     다른 값은 <literal>scalar</literal>라는 멤버 변수명이 포함할것이다.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // outputs 'ciao'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   
  </sect1>

  <sect1 id="language.types.resource">
   <title>자원</title>
    
    <para>
     resource는 특별한 변수이고, 특별한 자원에 대한 참조를 포함한다.
     자원은 특별한 함수에 의해 생성되고 사용된다. 이런 모든 함수의
     목록과 대응하는 자원 타입에 대해서는 
     <link linkend="resource">부록</link> 섹션을 참고한다.
    </para>
    
    <note>
     <simpara>
      resource 타입은 PHP 4에서부터 지원된다.
     </simpara>
    </note>

   <sect2 id="language.types.resource.casting">
    <title>resource로 변환하기</title>
    
    <para>
     resource 타입은 파일이나 데이터베이스 접속, 이미지 캔버스 영역 등을
     열기위한 특별한 핸들러를 보유하기 때문에, 어떤값도 resource로
     변환될수 없다.
    </para>
   </sect2>

    <sect2 id="language.types.resource.self-destruct">
     <title>Freeing resources</title>
    
    <para>
     PHP 4의 젠드 엔진에서 참조-카운팅(reference-counting) 시스템이 추가되어서,
     resource가 더이상 참조되지 않을때가 자동적으로 탐지된다(자바처럼).
     이 경우에, 이 자원을 위해 사용중인 모든 자원은 가비지 컬렉터에 
     의해 자동으로 해제된다. 이런 이유로, free_result같은 함수를
     사용하여 수동으로 메모리를 해제할 필요는 어의 없다.
     <note>
      <simpara>
       영구적인 데이터베이스 접속은 특별하다. 그것은 가비지 컬렉터에 의해
       파괴되지 <emphasis>않는다</emphasis>.
       <link linkend="features.persistent-connections">영구적인 접속</link>를 참고.
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>NULL</title>
    
   <para>
    특별한 값인 &null;은 아무 값을 갖지 않는 변수를 표현한다.
    &null;은 유일한 <type>NULL</type>타입의 값이다.
   </para>
    <note>
     <simpara>
      null 타입은 PHP 4에서 소개되었다
     </simpara>
    </note>
    <para>
     다음과 같은 경우에 변수는 &null;로 취급된다
     <itemizedlist>
      <listitem>
       <para>
        상수를 &null;로 할당했을 때.
       </para>
      </listitem>
      <listitem>
       <para>
        아직 아무 값도 할당하지 않았을 때.
       </para>
      </listitem>
      <listitem>
       <para>
        <function>unset</function>을 사용했을 때.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    
   <sect2 id="language.types.null.syntax">
    <title>문법</title>
    <para>
     타입은 유일한 값 &null;을 갖는다. 
     &null;은 대소문자를 구별하지 않는다.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;       
?>
]]>
</programlisting>
     </informalexample>
    </para>
    <para>
     <function>is_null</function>과 <function>unset</function>을 참고
    </para>
   </sect2>
  </sect1>
 
  <sect1 id="language.pseudo-types">
   <title>이 문서에서 사용되는 의사 타입</title> 

   <sect2 id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal>는 인자가 여러 타입을 허용한다는 것을 가리킨다
     (모든 타입일필요는 없다)
    </para>
    <para>
     <function>gettype</function>은 모든 PHP 타입을 다루고,
     반면에 <function>str_replace</function>은 문자열과 배열만을 다룬다.
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal>는 인자가 
     <type>integer</type>나 <type>float</type>일수 있음을 가리킨다.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>callback</title>
    <para>
     <function>call_user_func</function>나 <function>usort</function>와 같은
     함수는 인자로 사용자선언 콜백 함수를 취급한다. 콜백 함수는 단순한 함수
     뿐만 아니라 정적 클래스 메소드를 포함하는 객체 메소드가 될수 있다.
    </para>
    <para>
     PHP 함수는 단순히 그 이름을 문자열로 전달한다. 다음 함수를 제외하고
     내장 함수나 유저 선언 함수를 전달할수 있다.
     <function>array</function>, 
     <function>echo</function>, 
     <function>empty</function>, 
     <function>eval</function>, 
     <function>exit</function>, 
     <function>isset</function>, 
     <function>list</function>, 
     <function>print</function>,
     <function>unset</function>.
    </para>
    <para>
     인스턴스화된 객체의 메소드는 인덱스 0의 요소인 객체와 
     인덱스 1의 요소인 메소드명을 포함하는 배열로 전달된다.
    </para>
    <para>
     정적 클래스 메소드는 인덱스 0의 요소인 객체 대신 클래스명을
     전달함으로써 그 클래스의 객체를 인스턴스화하지 않고도 전달될수 있다.
    </para>

    <para>
     <example>
      <title>
       콜백 함수 예제코드
      </title>
      <programlisting role="php">
<![CDATA[
<?php 

// simple callback example
function foobar() {
    echo "hello world!";
}
call_user_func("foobar"); 

// method callback examples
class foo {
  function bar() {
    echo "hello world!";
  }
}

// static class method call without instantiating an object
call_user_func(array("foo", "bar")); 

$foo = new foo;

call_user_func(array($foo, "bar")); // object method call


?>
]]>
      </programlisting>
     </example>
    </para>  
   
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>타입 저글링</title>

   <simpara>
    PHP는 변수 선언부의 명시적인 타입 정의를 요구하지않는다(지원하지않는다)
    변수의 타입은 변수가 사용되는 환경에서 결정된다. 즉, 문자열 값을 
    변수 <parameter>$var</parameter>에 지정하면,<parameter>$var</parameter>는 문자열이 된다.
    integer값이 <parameter>$var</parameter>에 지정되면, integer가 된다.
   </simpara>
   <para>
    PHP의 자동적인 타입 변환의 예로는 덧셈 연산자 '+'를 들수 있다.
    피연산자 중 어느 하나가 float이라면, 모든 피연산자는 float으로 취급된다.
    그렇지 않으면, 피연산자는 정수로 해석될것이고, 결과값도 정수가 될것이다.
    이런일이 피연산자 자신의 타입을 바꾸지 않는다는 것에 주의하라;
    피연산자가 어떻게 평가되느냐에 따라서만 변환이 이루어진다.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo is string (ASCII 48)
$foo += 2;   // $foo is now an integer (2)
$foo = $foo + 1.3;  // $foo is now a float (3.3)
$foo = 5 + "10 Little Piggies"; // $foo is integer (15)
$foo = 5 + "10 Small Pigs";     // $foo is integer (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    위 예제코드중 마지막 두가지가 이상해 보인다면,
    <link linkend="language.types.string.conversion">문자열을 수로 변환</link>을
    참고.
   </simpara>
   <simpara>
    어떤 변수를 특정 타입으로 취급하고자 한다면,
    <link linkend="language.types.typecasting">타입 캐스트</link> 매뉴얼
    섹션을 참고할것. 변수의 타입을 변환하려고 하면,
    <function>settype</function>를 볼것.

   </simpara>
   <para>
    이 섹션에서 다른 에제를 테스트하기 위해
    <function>var_dump</function> 함수를 사용할수 있다.
   </para>
   <note>
    <para>
     배열의 자동적인 변환 방식은 현재까지 정의되지 않았다.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a is a string
$a[0] = "f";  // What about string offsets? What happens?
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     PHP는 배열 인덱싱과 같은 문법을 사용하여 오프셋을 통하여 문자열 안의
     인덱싱을 지원하기 때문에(역사적인이유로), 위 예제코드는 문제가 될
     소지가 있다: $a는 그 첫번째 요소가 "f"를 갖는 배열이 되는가?
     "f"가 문자열 $a 문자열의 첫번째 문자가 되는가?
    </para>
    <para>
     현재 버전 PHP는 두번째 할당문을 문자열 오프셋 인식으로 해석한다.
     그래서 $a는 "f"가 되고, 자동 변환의 결과는 정의되지 않은것으로 여겨진다.
     PHP 4는 스트링 내의 문자에 접근하기 위한 중괄호 문법을 새로이 제공한다.
     위에서 제시한것 대신 이문법을 사용하도록 한다
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a is a string
$a{1} = "f";   // $a is now "afc"
?>
]]>
      </programlisting>
     </informalexample>
     자세한 정보는 
     <link linkend="language.types.string.substr">문자열의 문자 접근하기</link>섹션을
     참고.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>타입 캐스트</title>

    <para>
     PHP에서 타입 캐스느는 C에서 동작하는 것과 유사하게 동작한다. 원하는 타입의
     이름을 변수 앞 괄호안에 사용하여 캐스트될수 있다.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo is an integer
$bar = (boolean) $foo;   // $bar is a boolean
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     허용되는 캐스트는 다음과 같다:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - cast to integer</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - cast to boolean</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - cast to float</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - cast to string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - cast to array</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - cast to object</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     탭과 빈칸이 괄호안에서 허용된다는것에 주의한다.
     그래서 다음 예는 기능적으로 동일하다:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      변수를 문자열로 캐스트하는 대신에, 큰 따옴표 안에 변수를
      넣어줄수도 있다.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo is an integer
$str = "$foo";        // $str is a string
$fst = (string) $foo; // $fst is also a string

// This prints out that "they are the same"
if ($fst === $str) {
    echo "they are the same";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>
     
    <para>
     특정 타입간의 캐스트가 될때 무슨일이 일어날지 
     여기서 명확하지 않으면 자세한 정보를 보기 위해 아래 섹션을 참고.
    
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">boolean으로 변환하기</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">정수로 변환하기</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">float으로 변환하기</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">문자열로 변환하기</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">배열로 변환하기</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">객체로 변환하기</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">resource로 변환하기</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
