<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.11 $ -->
<!-- EN-Revision: 1.119 -->
 <chapter id="language.types">
  <title>타입</title>

  <sect1 id="language.types.intro">
  <title>소개</title>
  
  <simpara>
   PHP는 8가지의 기본 타입을 지원한다.
  </simpara>
  
  <para>
   4가지 스칼라 타입:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>boolean</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>integer</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>float</type> (floating-point number, aka '<type>double</type>')
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>string</type>
     </simpara>
    </listitem>

   </itemizedlist>

   2가지 복합 타입:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>array</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>object</type>
     </simpara>
    </listitem>

   </itemizedlist>

   그리고 최종적으로 다음의 2가지 타입:

   <itemizedlist>

    <listitem>
     <simpara>
      <type>resource</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>NULL</type>
     </simpara>
    </listitem>

   </itemizedlist>

   이 매뉴얼에서는 몇가지의
   <link linkend="language.pseudo-types">의사(pseudo) 타입</link>도 소개한다.
   for readability reasons:

   <itemizedlist>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">mixed</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.number">number</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">callback</link>
     </simpara>
    </listitem>

   </itemizedlist>
   "double" 타입과 비슷한 타입을 볼수 있을것이다. double은 float과
   같은 타입이다. 두개의 타입이 존재하는 이유는 역사적인 이유일뿐이다.
  </para>
  
  <simpara>
   보통은 프로그래머가 변수의 타입을 결정할수 없다.
   대신에, PHP가 변수가 사용되는 환경에 따라 실시간으로 결정하게 된다.
  </simpara>
  <note>
   <simpara>
    <link linkend="language.expressions">표현식</link>의 타입과 값을
    확인하려한다면, <function>var_dump</function>을 사용한다.
   </simpara>
   <para>
    디버깅을 위해 타입을 판독하려고 하면, <function>gettype</function>를 사용한다.
    정확히 어떠 타입을 사용하는지 확인하려면 <function>gettype</function>함수를 사용하지
    <emphasis>말고</emphasis>, <literal>is_<replaceable>type</replaceable></literal>함수를 
    사용하도록 한다. 몇가지 예제 코드를 보자:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // a boolean
$str  = "foo";  // a string
$int  = 12;     // an integer

echo gettype($bool); // prints out "boolean"
echo gettype($str);  // prints out "string"

// If this is an integer, increment it by four
if (is_int($int)) {
    $int += 4;
}

// If $bool is a string, print it out
// (does not print out anything)
if (is_string($bool)) {
    echo "String: $bool";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>
  <simpara>
   변수를 다른 타입으로 변경하려한다면 변수를 <link linkend="language.types.typecasting">캐스트</link>하거나
   <function>settype</function>함수를 사용하면 된다. 
  </simpara>
  <simpara>
   변수는 특수한 상황에서는 그 당시에 무슨 타입을 쓰는지에 따라
   다른 값으로 변경될수 있다는 것에 주의 해야 한다. 자세한 정보는
   <link linkend="language.types.type-juggling">타입 저글링</link>을 참고.
  </simpara>
 </sect1>
   
   <sect1 id="language.types.boolean">
    <title>불린</title>
    
    <simpara>
     이 타입은 가장 쉬운 타입니다.<type>boolean</type>은 논리값을
     표현한다. &true; 나 &false; 값이 될수 있다.
    </simpara>

    <note>
     <simpara>
      boolean 타입은 PHP 4부터 지원되었다.
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>문법</title>
     <para>
      boolean 을 표현하기 위해서 키워드 &true; 나 &false;를 사용한다.
      두 가지 모두 대소문자를 구별하지 않는다.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo = True; // assign the value TRUE to $foo
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      보통은 <type>boolean</type>값을 돌려주는 몇 가지 
      <link linkend="language.operators">연산자</link>를 사용해서
      그 값을 <link linkend="control-structures">제어 구조</link>로 전달한다.

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// == is an operator which test
// equality and returns a boolean
if ($action == "show_version") {
    echo "The version is 1.23";
}

// this is not necessary...
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// ...because you can simply type
if ($show_separators) {
    echo "<hr>\n";
}
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>boolean으로 변환</title>
      <simpara>
       명시적으로 <type>boolean</type> 값으로 변경하려면
       <literal>(bool)</literal>이나 <literal>(boolean)</literal> 캐스트를 사용한다.
       하지만, 대부분의 경우 이런 캐스트를 사용할 필요는 없다. 왜냐하면 그 값은
       연산자나 함수 또는 제어구조가 <type>boolean</type>인자를 요구하면 자동으로
       변환된다.
      </simpara>
      <simpara>
       <link linkend="language.types.type-juggling">타입 저글링</link>도 참고.
      </simpara>
      
      <para>
       <type>boolean</type>로 변경할때, 다음값은 &false;로 본다:
  
       <itemizedlist>
        <listitem>
         <simpara><link linkend="language.types.boolean">boolean</link> 
          &false; 자체</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.integer">integer</link
         > 0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.float">float</link> 
         0.0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>비어있는 <link linkend="language.types.string">문자열</link>과
                  <link linkend="language.types.string">문자열</link> "0"</simpara>
        </listitem>
        <listitem>
         <simpara>아무 구성요소도 갖지 않는 <link linkend="language.types.array">배열</link>
         </simpara>
        </listitem>
        <listitem>
         <simpara>아무 멤버 변수도 갖지 않는 <link linkend="language.types.object">객체</link> 
         </simpara>
        </listitem>
        <listitem>
         <simpara>특별한 타입인 <link linkend="language.types.null">NULL</link> 
                 (변수를 unset하는 것도 포함)
         </simpara>
        </listitem>
       </itemizedlist>
       
       이 외의 다른 모든 값은 &true;로 본다 
       (모든 <link linkend="language.types.resource">자원</link>이 포함됨).
       <warning>
        <simpara>
         모든 0이 아닌 (양수이든 음수이든) &true;가 되는 것처럼
         <literal>-1</literal>은 &true;로 본다, 
        </simpara>
       </warning>
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
echo gettype((bool) "");        // bool(false)
echo gettype((bool) 1);         // bool(true)
echo gettype((bool) -2);        // bool(true)
echo gettype((bool) "foo");     // bool(true)
echo gettype((bool) 2.3e5);     // bool(true)
echo gettype((bool) array(12)); // bool(true)
echo gettype((bool) array());   // bool(false)
?>
]]>
        </programlisting>
       </informalexample>
      </para>
     </sect2>
   </sect1>

   <sect1 id="language.types.integer">
    <title>정수</title>
    
    <simpara>
     <type>integer</type>는 거대한 집합
     Z = {..., -2, -1, 0, 1, 2, ...}이다.
    </simpara>
     
    <para>
     <link linkend="ref.gmp">Arbitrary length integer / GMP</link>,
     <link linkend="language.types.float">부동 소수점수</link>,
     <link linkend="ref.bc">Arbitrary precision / BCMath</link>를 참고
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>문법</title>
     <simpara>
      정수는 10진수(10-based), 16진수(16-based), 8진수(8-based) 표기법으로 표현
      될수 있다. 선택적으로 부호 (- 나 +)를 사용할수 있다.
     </simpara>
     <para>
      8진수 표기법을 사용하면, <literal>0</literal> (zero)를 숫자의 앞에
      붙여야 하며, 16진수 표기하려면 <literal>0x</literal>을 숫자 앞에
      붙이도록 한다.
      <example>
       <title>정수 리터럴</title>
       <programlisting role="php">
<![CDATA[
<?php
$a = 1234; # decimal number
$a = -123; # a negative number
$a = 0123; # octal number (equivalent to 83 decimal)
$a = 0x1A; # hexadecimal number (equivalent to 26 decimal)
?>
]]>
       </programlisting>
      </example>
      공식적으로 가능한 정수 리터럴의 구조는 다음과 같다:
      <informalexample>
       <programlisting>
<![CDATA[
<?php
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
?>
]]>
       </programlisting>
      </informalexample>
      약 20억을 최대값(부호가 있는 32비트)으로 사용할수 있을지라도, 
      정수의 크기는 플랫폼에 따라 달라지게 된다. PHP는 
      부호없는(unsigned) 정수 를 지원하지 않는다.
     </para>
    </sect2>
   
    <sect2 id="language.types.integer.overflow">
     <title>정수 오버플로우</title>
     <para>
      <type>정수</type>타입의 범위를 넘는 수를 사용하려면 그 값은 대신
      <type>float</type>타입으로 해석될 것이다. 또한, 
      결과값이 <type>integer</type>타입의 범위를 초과하게 되는 작업을 수행되면, 
      그 값은 대신 <type>float</type>으로 돌려줄것이다.
     
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// output: int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// output: float(2147483648)

// this goes also for hexadecimal specified integers:
var_dump( 0x80000000 );
// output: float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// output: float(50000000000)
?>
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        불운하게도, PHP는 버그로 인해 음수와 연계될때 정확하게 동작하지 
        않을수 있다. 예를 들면 <literal>-50000 * $million</literal>를 수행하면, 결과는
        <literal>-429496728</literal>이 될것이다. 두 피연산자가 모두 양수이면
        아무 문제가 없다.

       </simpara>
       <simpara>
        이 문제는 PHP 4.1.0에서 해결되었다.
       </simpara>
      </warning>
     </para>
     <para>
      PHP에는 정수 나누기 연산자가 없다.
      <literal>1/2</literal>는 <type>float</type> <literal>0.5</literal>가 된다.
      반올림하기 위해 정수로 값을 캐스트하거나, <function>round</function>
      함수를 쓸수 있다.

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286) 
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4) 
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>정수로 변환하기</title>
      <simpara>
       명시적으로 <type>integer</type>로 변환하려면 <literal>(int)</literal>나
       <literal>(integer)</literal> 캐스트를 사용한다.
       하지만, 대부분의 경우 이런 캐스트를 사용할 필요가 없다. 왜냐하면 연산자
       나 함수 또는 제어 구조가 <type>integer</type> 인수를 요구한다면 자동으로
       변환되기 때문이다. 또한 <function>intval</function>함수로 정수값으로 
       변환할수 있다.
      </simpara>
      <simpara>
       See also <link linkend="language.types.type-juggling">type-juggling</link>.
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title><link linkend="language.types.boolean">불린</link>에서</title>
       <simpara>
        &false;는 <literal>0</literal> (zero), 그리고
        &true;는 <literal>1</literal> (one).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title><link linkend="language.types.float">부동소수점수</link>에서</title> 
       <simpara>
        float에서 integer로 변환할때, 그 수는 <emphasis>0으로</emphasis> 깍일것이다.
       </simpara>
       
       <para>
        float이 integer범위를 초과하면 (주로 <literal>+/- 2.15e+9 = 2^31</literal>), 
        결과는 정의되지않는다. 왜냐하면 float은 정확한 정수값을 돌려주기에
        충분한 정밀도를 갖지 않기 때문이다. 이 경우에는 warning이나 notice조차도
        나타나지 않는다!
       </para>
       
       <warning><para>
        알려지지 않은 소수를 <type>integer</type>로 캐스트하지 말것, 
        왜냐하면 이렇게 하는경우에 종종 기대하지 않는 결과를 유도할수
        있기 때문이다.
        <informalexample>
         <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // echoes 7!
?>
]]>
         </programlisting>
        </informalexample>
        자세한 정보는 <link linkend="warn.float-precision">부동-정밀도에 관한 경고</link>를
        참고.
        
       </para></warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>문자열로부터</title>
       <simpara>
        <link linkend="language.types.string.conversion">문자열을 숫자로 
        변환하기</link>를 참고
       </simpara>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-other">
       <title>다른 타입으로부터</title>
       <para>
        <caution>
         <simpara>
          정수로의 변환은 다른 타입에 대해 정의되지 않는다. 현재까지는 값이 
          <link linkend="language.types.boolean.casting">불린으로 변환</link>될때와 
          동일하게 동작한다. 하지만, 경고 없이 변할수 있기 
          때문에 이 동작에 연관짓지 <emphasis>말것</emphasis>
         </simpara>
        </caution>
       </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>부동소수점</title>
   <para>
    부동소수점(AKA "floats", "doubles", "real numbers")은 다음과 같은
    문법으로 표현될수 있다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;
?>
]]>
     </programlisting>
    </informalexample>
    공식적으로:
    <informalexample>
     <programlisting role="php">
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
     </programlisting>
    </informalexample>
    float의 크기는 십진수 14자리가 일반적인 값(64비트 IEEE 포맷)이 되는
    정밀도를 갖는 ~1.8e308까지의 최대값을 갖을지라도 플랫폼에 따라 달라진다.
   </para>
 
   <warning id="warn.float-precision">
    <title>부동소수점 정밀도</title>
    <para>
     <literal>0.1</literal>이나 <literal>0.7</literal>와 같은 단순한
     십진수의 분수는 약간의 정밀도의 소실없이 내부적인 이진처리로 변환될
     수 없다. 이 사실은 혼란스런 결과를 유도할수 있다: 예를 들면,
     <literal>floor((0.1+0.7)*10)</literal>은 기대값 <literal>8</literal>이 아닌
     <literal>7</literal>을 돌려준다. 내부적인 표현이
     <literal>7.9999999999...</literal>와 같을것이기 때문이다.
    </para>
    <para>
     이와 같은 이유로 유한값의 십진표기법을 쓰는 몇몇 소수를 정확히 표현할수 
     없다는 것이다. 예를 들면, 십진표기법의 <literal>1/3</literal>은 
     <literal>0.3333333. . .</literal>이 된다.
    </para>
    <para>
     결코 부동소수점이 마지막 수를 갖을수 있을것이라고 생각하거나 부동소수점이
     동일한지 비교하도록 해서는 안된다. 더 높은 정밀도가 필요하면, 대신
     <link linkend="ref.bc">arbitrary precision math functions</link>나
     <link linkend="ref.gmp">gmp</link>함수를 사용하도록 해야 한다.
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>float으로 변환하기</title>
    
    <para>
     문자열이 언제, 어떻게 float으로 변환하는지에 대한 정보는
     <link linkend="language.types.string.conversion">문자열을 숫자로 변환하기</link>섹션을 참고하라.
     다른 타입에 대한 변환은 그 값이 integer나 float으로 변환하는 방식과 동일하다.
     더 자세한 정보는 <link linkend="language.types.integer.casting">integer로 변환하기</link>를 참고.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.string">
   <title>문자열</title>
   <para>
    <type>string</type>은 일련의 문자들이다. PHP에서 문자는 바이트와 같다. 즉
    정확히 서로다른 256개의 문자를 사용할수 있다. 또한 PHP는 기본적으로 유니코드 지원을
    갖지않는다. 유니코드에 대한 지원은 <function>utf8_encode</function>과
    <function>utf8_decode</function>함수를 참고
   </para>
   <note>
    <simpara>
     문자열이 아무 문제없이 매우 커질수 있다. PHP에서 사용되는 문자열은 
     실질적으로 범위제한을 갖지 않는다. 그래서 긴 문자열에 대해서 걱정할
     이유가 전혀 없다.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>문법</title>
    <para>
     문자열 리터럴은 3가지 다른 방식으로 표현될수 있다.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">작은 따옴표</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">큰 따옴표</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">상속 문법</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>작은 따옴표</title>
     <para>
      단순한 문자열을 표현하는 가장 간단한 방법이 작은 따옴표
      (문자 <literal>'</literal>)로 문자열을 둘러싸면 된다.
     </para>
     <para>
      작은따옴표를 리터럴로 표현하려면 역슬래쉬(<literal>\</literal>)로
      회피할 필요가 있다. 다른 많은 언어에서도 이와같은 방식을 사용한다.
      작은 따옴표 앞이나 문자열의 끝에서 역슬래쉬가 있을필요가 있으면,
      이것은 중복사용할 필요가 있다. 다른 모든 문자를 회피하려하면 역슬래쉬가
      출력되어야 할것이란 것에 주의하라! 그래서 보통은 역슬래쉬 자체를 회피할
      필요가 없다.
      <note>
       <simpara>
        PHP 3에서 이와 같은 일이 발생하면 <literal>E_NOTICE</literal>레벨의
        경고가 출력될것이다.
       </simpara>
      </note>
      <note>
       <simpara>
        이외 다른 두가지 문법과는 달리 작은 따옴표로 둘러싸인 문자열에서
        <link linkend="language.variables">변수</link>와 특별한 문자를 위한 
        회피는 전개되지 못한다. 
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in 
strings this way as it is
okay to do';

// Outputs: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// Outputs: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// Outputs: Variables do not $expand $either
echo 'Variables do not $expand $either';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>큰 따옴표</title>
     <para>
      문자열이 큰따옴표(")로 둘러싸이면, PHP는 특별한 문자의
      회피를 더 잘 이해한다.
     </para>
     <table>
      <title>회피 문자</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>sequence</entry>
         <entry>meaning</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>linefeed (LF or 0x0A (10) in ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>carriage return (CR or 0x0D (13) in ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>horizontal tab (HT or 0x09 (9) in ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>backslash</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>dollar sign</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>double-quote</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          이 정규표현식은 8진표기법의 일련의 문자이다.
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          이 정규표현식은 16진표기법의 일련의 문자이다.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      다시 얘기하면, 다른 어떤 문자를 회피하려한다면, 역슬래쉬도
      출력될것이다!
     </para>
     <para>
      그러나 큰따옴표로 둘러싸인 문자열의 가장 중요한 특징은
      변수명이 전개될것이란 사실이다. 더 자세한 사항은
      <link linkend="language.types.string.parsing">문자열 해석</link>을
      참고.
     </para>
    </sect3>
    
    <sect3 id="language.types.string.syntax.heredoc">
     <title>히어닥 문법</title>
     <simpara>
      문자열을 구분하는 다른 방법은 히어닥 문법("&lt;&lt;&lt;")을
      사용하는것이다. 
      <literal>&lt;&lt;&lt;</literal>이후에 식별자가 와야 하고
      그다음에 문자열, 그다음에 인용을 닫는 어떤 식별자가 와야 한다.
     </simpara>
     <simpara>
      닫기 식별자는 그 줄의 첫번째 컬럼에서 시작<emphasis>되어야 한다</emphasis>.
      또한, 식별자는 PHP의 다른 라벨과 같은 명명규칙을 따라야 한다:
      오직 알파벳 숫자와 밑줄을 포함하고 숫자가 아닌 문자나 밑줄로
      시작되어야 한다.
     </simpara>
     
     <warning>
      <simpara>
       닫기 식별자를 갖는 줄은 <emphasis>가능한</emphasis> 
       세미콜른(<literal>;</literal>)를 제외하고
       다른 문자를 포함하지 않는다는것에 주의해야 한다. 이말은 특별히
       식별자가 <emphasis>줄맞춤이 되지 않을 것</emphasis>이고 어떤 공백이나 탭문자도
       세미콜른의 앞이나 뒤에 있지 않을것이란 것이다. 닫기 식별자 전의
       첫 문자는 운영체제에서 정의된 새줄이 되어야 한다는 것을 인식해야 한다.
       예를 들면 매킨토시에서는 <literal>\r</literal>이 된다.
      </simpara>
      <simpara>
       이 규칙을 깨고 닫기 식별자가 "확실"하지 않으면, 닫기 식별자로
       인식되지 않으며 PHP는 다른 식별자를 계속 찾게 될것이다. 그래서 적절한
       닫기 식별자가 발견되지 않으면 스크립트 끝의 줄번호로 해석 에러가
       출력될것이다.
      </simpara>
     </warning>

     <para>
      히어닥 텍스트는 큰따옴표가 없지만 큰따옴표로 둘러싸인 문자열처럼 동작한다.
      히어닥에서는 따옴표를 회피할 필요가 없다는 의미를 갖는다. 그러나 여전히
      위에서 열거한 회피 코드를 사용할수 있다. 문자가 전개되면, 히어닥 안의
      복합 변수를 문자열로 표현할때 같은 주의가 필요하다.
      <example> 
       <title>히어닥 문자열 인용 예</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       히어닥 지원은 PHP 4에서 추가되었다.
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>변수 해석</title>
     <simpara>
      문자열이 큰따옴표나 히어닥으로 표현되면
      <link linkend="language.variables">변수</link>는 그 안에서 해석된다.
     </simpara>
     <simpara>
      두가지 형태의 문법이 존재한다:
      <link linkend="language.types.string.parsing.simple">단순</link>문법과
      <link linkend="language.types.string.parsing.complex">복합</link>문법이다.

      단순 문법은 가장 일반적이고 가장 편하다. 이 문법은 
      변수나 <type>array</type>값, <type>object</type>속성을 해석하는
      방법을 제공한다.
     </simpara>
     <simpara>
      복합 문법은 PHP 4에서부터 지원되고, 중괄호로 둘러싸는 표현으로 인식된다.
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>단순 문법</title>
      <simpara>
       달러사인(<literal>$</literal>)과 만나면, 해석기는 가능한 많은
       토큰을 취해서 유효한 변수명을 형성하게 된다. 중괄호로 변수명을
       둘러싸면 이름의 끝을 명시적으로 표시하려는 것이다. 
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // works, "'" is an invalid character for varnames
echo "He drank some $beers";   // won't work, 's' is a valid character for varnames
echo "He drank some ${beer}s"; // works
echo "He drank some {$beer}s"; // works
?>
]]>
       </programlisting>
      </informalexample>
      <simpara>
       비슷하게, <type>array</type> 인덱스나 해석된 <type>object</type>특성을 보유할수
       있다. 배열 인덱스로 닫음 대괄호 (<literal>]</literal>)는 인덱스의 끝을 표시한다.
       객체 속성은 변수를 갖는 트릭이 존재하지 않지만, 객체 특성에 대해서 단순한 변수에
       적용되는 규칙과 같다. 
       
       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// These examples are specific to using arrays inside of strings.
// When outside of a string, always quote your array string keys 
// and do not use {braces} when outside of strings either.

// Let's show all errors
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// Works but note that this works differently outside string-quotes
echo "A banana is $fruits[banana].";

// Works
echo "A banana is {$fruits['banana']}.";

// Works but PHP looks for a constant named banana first
// as described below.
echo "A banana is {$fruits[banana]}.";

// Won't work, use braces.  This results in a parse error.
echo "A banana is $fruits['banana'].";

// Works
echo "A banana is " . $fruits['banana'] . ".";

// Works
echo "This square is $square->width meters broad.";

// Won't work. For a solution, see the complex syntax.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       좀더 복잡한 변수에 대해서, 복합 문법을 사용해야 한다.
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>복합(curly) 문법</title>
      <simpara>
       이 방법은 문법이 복합적이라서 복합이라고 부르는것이 아니다.
       대신에 이 방법으로 복합 표현식을 포함할수 있기 때문이다.
     </simpara>
     <simpara>
      사실, 이 문법으로 문자열의 네임스페이스에 존재하는 어떤변수
      도 포함할수 있다. 단순히 문자열을 드러내는 방법과 동일한 표현식을
      쓸수 있다. 그리고 { 과 } 안에 그것을 포함한다. '{'를 회피할
      수 없기 때문에 이 문법은 $가 즉시 {뒤에 올때만 인식된다.
      ("{$" 리터럴을 쓰려면  "{\$" 이나 "\{$" 을 사용하라).
      몇가지 예를 보고 위 설명을 이해해보자:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Let's show all errors
error_reporting(E_ALL);

$great = 'fantastic';

// Won't work, outputs: This is { fantastic}
echo "This is { $great}";

// Works, outputs: This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Works
echo "This square is {$square->width}00 centimeters broad."; 

// Works
echo "This works: {$arr[4][3]}";

// This is wrong for the same reason as $foo[bar] is wrong 
// outside a string.  In otherwords, it will still work but
// because PHP first looks for a constant named foo, it will
// throw an error of level E_NOTICE (undefined constant).
echo "This is wrong: {$arr[foo][3]}"; 

// Works.  When using multi-dimensional arrays, always use
// braces around arrays when inside of strings
echo "This works: {$arr['foo'][3]}";

// Works.
echo "This works: " . $arr['foo'][3];

echo "You can even write {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>String access by character</title>
     <para>
      Characters within strings may be accessed by specifying the
      zero-based offset of the desired character after the string 
      in curly braces.
     </para>
     <note>
      <simpara>
       For backwards compatibility, you can still use array-braces
       for the same purpose. However, this syntax is deprecated as
       of PHP 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Some string examples</title>
       <programlisting role="php">
<![CDATA[
<?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str{0};

// Get the third character of a string
$third = $str{2};

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str{strlen($str)-1}; 
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Useful functions and operators</title>
    <para>
     Strings may be concatenated using the '.' (dot) operator. Note
     that the '+' (addition) operator will not work for this. Please
     see <link linkend="language.operators.string">String
     operators</link> for more information.
    </para>
    <para>
     There are a lot of useful functions for string modification.
    </para>
    <simpara>
     See the <link linkend="ref.strings">string functions section</link> 
     for general functions, the regular expression functions for
     advanced find&amp;replacing (in two tastes: 
     <link linkend="ref.pcre">Perl</link> and 
     <link linkend="ref.regex">POSIX extended</link>).
    </simpara>
    <simpara>
     There are also <link linkend="ref.url">functions for URL-strings</link>,
     and functions to encrypt/decrypt strings 
     (<link linkend="ref.mcrypt">mcrypt</link> and 
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finally, if you still didn't find what you're looking for,
     see also the <link linkend="ref.ctype">character type functions</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>Converting to string</title>
    
    <para>
     You can convert a value to a string using the <literal>(string)</literal>
     cast, or the <function>strval</function> function. String conversion
     is automatically done in the scope of an expression for you where a
     string is needed. This happens when you use the <function>echo</function>
     or <function>print</function> functions, or when you compare a variable
     value to a string.  Reading the manual sections on <link
     linkend="language.types">Types</link> and <link
     linkend="language.types.type-juggling">Type Juggling</link> will make
     the following clearer.  See also <function>settype</function>.
    </para>
    
    <para>
     A <type>boolean</type> &true; value is converted to the string <literal>"1"</literal>,
     the &false; value is represented as <literal>""</literal> (empty string).
     This way you can convert back and forth between boolean and string values.
    </para>
    <para> 
     An <type>integer</type> or a floating point number (<type>float</type>) 
     is converted to a string representing the number with its digits
     (including the exponent part for floating point numbers).
    </para>
    <para>
     Arrays are always converted to the string <literal>"Array"</literal>,
     so you cannot dump out the contents of an <type>array</type> with 
     <function>echo</function> or <function>print</function> to see what is inside 
     them.  To view one element, you'd do something like <literal>
     echo $arr['foo']</literal>.  See below for tips on dumping/viewing the 
     entire contents.
    </para>
    <para>
     Objects are always converted to the string <literal>"Object"</literal>.
     If you would like to print out the member variable values of an 
     <type>object</type> for debugging reasons, read the paragraphs 
     below. If you would like to find out the class name of which an object 
     is an instance of, use <function>get_class</function>.
    </para>
    <para>
     Resources are always converted to strings with the structure
     <literal>"Resource id #1"</literal> where <literal>1</literal> is
     the unique number of the <type>resource</type> assigned by PHP during runtime.
     If you would like to get the type of the resource, use
     <function>get_resource_type</function>.
    </para>
    <para>
     &null; is always converted to an empty string.
    </para>
    
    <para>
     As you can see above, printing out the arrays, objects or resources does not
     provide you any useful information about the values themselfs. Look at the
     functions <function>print_r</function> and <function>var_dump</function>
     for better ways to print out values for debugging.
    </para>
    
    <para>
     You can also convert PHP values to strings to store them permanently. This
     method is called serialization, and can be done with the function
     <function>serialize</function>. You can also serialize PHP values to
     XML structures, if you have <link linkend="ref.wddx">WDDX</link> support
     in your PHP setup.
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>String conversion to numbers</title>

    <simpara>
     When a string is evaluated as a numeric value, the resulting
     value and type are determined as follows.
    </simpara>
    <simpara>
     The string will evaluate as a <type>float</type> if it contains any of the
     characters '.', 'e', or 'E'. Otherwise, it will evaluate as an
     integer.
    </simpara>
    <para>
     The value is given by the initial portion of the string. If the
     string starts with valid numeric data, this will be the value
     used. Otherwise, the value will be 0 (zero). Valid numeric data
     is an optional sign, followed by one or more digits (optionally
     containing a decimal point), followed by an optional
     exponent. The exponent is an 'e' or 'E' followed by one or more
     digits.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo is float (11.5)
$foo = 1 + "-1.3e3";              // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo is integer (1)
$foo = 1 + "bob3";                // $foo is integer (1)
$foo = 1 + "10 Small Pigs";       // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;          // $foo is float (11)
$foo = "10.0 pigs " + 1.0;        // $foo is float (11)     
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     For more information on this conversion, see the Unix manual page
     for strtod(3).
    </simpara>
    <para>
     If you would like to test any of the examples in this section,
     you can cut and paste the examples and insert the following line
     to see for yourself what's going on:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Do not expect to get the code of one character by converting it
     to integer (as you would do in C for example). Use the functions
     <function>ord</function> and <function>chr</function> to convert
     between charcodes and characters.
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Arrays</title>

   <para>
    An array in PHP is actually an ordered map. A map is a type that
    maps <emphasis>values</emphasis> to <emphasis>keys</emphasis>. 
    This type is optimized in several ways,
    so you can use it as a real array, or a list (vector), 
    hashtable (which is an implementation of a map), 
    dictionary, collection,
    stack, queue and probably more. Because you can have another
    PHP array as a value, you can also quite easily simulate
    trees.
   </para>
   <para>
    Explanation of those data structures is beyond the scope of this
    manual, but you'll find at least one example for each of them.
    For more information we refer you to external literature about
    this broad topic.
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>Syntax</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title>Specifying with <function>array</function></title>
     <para>
      An <type>array</type> can be created by the <function>array</function> 
      language-construct. It takes a certain number of comma-separated
      <literal><replaceable>key</replaceable> =&gt; <replaceable
      >value</replaceable></literal>
      pairs.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> may be an <type>integer</type> or <type>string</type>
// <replaceable>value</replaceable> may be any value
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      A <varname>key</varname> may be either an
      <literal>integer</literal> or a <type>string</type>. If a key is
      the standard representation of an <type>integer</type>, it will
      be interpreted as such (i.e.  <literal>"8"</literal> will be
      interpreted as <literal>8</literal>, while
      <literal>"08"</literal> will be interpreted as
      <literal>"08"</literal>). There are no different indexed and
      associative array types in PHP; there is only one array type,
      which can both contain integer and string indices.
     </para>
     <para>
      A value can be of any PHP type.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      If you do not specify a key for a given value, then the maximum
      of the integer indices is taken, and the new key will be that
      maximum value + 1--unless that maximum value is negative (is it
      perfectly legal to have negative array indices). In this case,
      the new key will be <literal>0</literal>.  If no integer indices
      exist yet, the key will be <literal>0</literal> (zero). If you
      specify a key that already has a value assigned to it, that
      value will be overwritten.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// This array is the same as ...
array(5 => 43, 32, 56, "b" => 12);

// ...this array
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Using &true; as a key will evaluate to <type>integer</type>
      <literal>1</literal> as key. Using &false; as a key will evaluate
      to <type>integer</type> <literal>0</literal> as key. Using
      <literal>NULL</literal> as a key will evaluate to the empty
      string. Using the empty string as key will create (or overwrite)
      a key with the empty string and its value; it is not the same as
      using empty brackets.
     </para>
     <para>
      You cannot use arrays or objects as keys. Doing so will result in a
      warning: <literal>Illegal offset type</literal>.
     </para>
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>Creating/modifying with square-bracket syntax</title>
     <para>
      You can also modify an existing array by explicitly setting
      values in it.
     </para>
     <para>
      This is done by assigning values to the array while specifying the 
      key in brackets. You can also omit the key, add an empty pair
      of brackets ("<literal>[]</literal>") to the variable name in that case.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> may be an <type>integer</type> or <type>string</type>
// <replaceable>value</replaceable> may be any value
      </synopsis>
      If <varname>$arr</varname> doesn't exist yet, it will be created. 
      So this is also an alternative way to specify an array.
      To change a certain value, just assign a new value
      to an element specified with its key. If you want to
      remove a key/value pair, you need to <function>unset</function> it. 
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // This is the same as $arr[13] = 56;
                // at this point of the script

$arr["x"] = 42; // This adds a new element to
                // the array with key "x"
                
unset($arr[5]); // This removes the element from the array

unset($arr);    // This deletes the whole array
?>
]]> 
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       As mentioned above, if you provide the brackets with no key
       specified, then the maximum of the existing integer indices is
       taken, and the new key will be that maximum value + 1--unless
       that maximum value is negative (is it perfectly legal to have
       negative array indices). In this case, the new key will be
       <literal>0</literal>.  If no integer indices exist yet, the key
       will be <literal>0</literal> (zero). If you specify a key that
       already has a value assigned to it, that value will be
       overwritten. 
      </para>
      <para>
       Note that the maximum integer key used for this <emphasis>need
       not currently exist in the array</emphasis>. It simply must
       have existed in the array at some time since the last time the
       array was re-indexed. The following example illustrates:
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Create a simple array.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Now delete every item, but leave the array itself intact:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Append an item (note that the new key is 5, instead of 0 as you
// might expect).
$array[] = 6;
print_r($array);

// Re-index:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]> 
       </programlisting>
       <para>
        The above example would produce the following output:
        <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
        </screen>
       </para>
      </informalexample>       

     </note>
    </sect3>
   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>Useful functions</title>
    <para>
     There are quite a few useful functions for working with arrays.
     See the <link linkend="ref.array">array functions</link> section.
    </para>
    <note>
     <para>
      The <function>unset</function> function allows unsetting keys of an 
      array. Be aware that the array will NOT be reindexed. If you only
      use "usual integer indices" (starting from zero, increasing by one),
      you can achive the reindex effect by using <function>array_values</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'one', 2 => 'two', 3 => 'three');
unset($a[2]);
/* will produce an array that would have been defined as
   $a = array(1 => 'one', 3 => 'three');
   and NOT
   $a = array(1 => 'one', 2 =>'three');
*/

$b = array_values($a);
// Now b is array(1 => 'one', 2 =>'three')
?>
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     The <link linkend="control-structures.foreach">foreach</link> 
     control structure exists specifically for arrays. It 
     provides an easy way to traverse an array.
    </para>
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>Array do's and don'ts</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Why is <literal>$foo[bar]</literal> wrong?</title>
     <para>
      You should always use quotes around a string literal
      array index.  For example, use $foo['bar'] and not
      $foo[bar]. But why is $foo[bar] wrong? You might have seen the
      following syntax in old scripts:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
       </programlisting>
      </informalexample>
      This is wrong, but it works. Then, why is it wrong? The reason
      is that this code has an undefined constant (bar) rather than a
      string ('bar' - notice the quotes), and PHP may in future define
      constants which, unfortunately for your code, have the same
      name.  It works because PHP automatically converts a
      <emphasis>bare string</emphasis> (an unquoted string which does
      not correspond to any known symbol) into a string which contains
      the bare string. For instance, if there is no defined constant
      named <constant>bar</constant>, then PHP will substitute in the
      string <literal>'bar'</literal> and use that.
     </para>
     <note>
      <simpara>
       This does not mean to <emphasis>always</emphasis> quote the
       key. You do not want to quote keys which are <link
       linkend="language.constants">constants</link> or <link
       linkend="language.variables">variables</link>, as this will
       prevent PHP from interpreting them.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Simple array:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nChecking $i: \n";
    echo "Bad: " . $array['$i'] . "\n";
    echo "Good: " . $array[$i] . "\n";
    echo "Bad: {$array['$i']}\n";
    echo "Good: {$array[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      <para>
       The output from the above is:
       <screen>
<![CDATA[
Checking 0: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad: 
Good: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad: 
Good: 1

Checking 1: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad: 
Good: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad: 
Good: 2
]]>        
       </screen>
      </para>
     </note>
     <para>
      More examples to demonstrate this fact:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Let's show all errors
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Correct
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Incorrect.  This works but also throws a PHP error of
// level E_NOTICE because of an undefined constant named fruit
// 
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Let's define a constant to demonstrate what's going on.  We
// will assign value 'veggie' to a constant named fruit.
define('fruit', 'veggie');

// Notice the difference now
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// The following is okay as it's inside a string.  Constants are not
// looked for within strings so no E_NOTICE error here
print "Hello $arr[fruit]";      // Hello apple

// With one exception, braces surrounding arrays within strings
// allows constants to be looked for
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// This will not work, results in a parse error such as:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// This of course applies to using autoglobals in strings as well
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// Concatenation is another option
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      When you turn <function>error_reporting</function> up to show
      <constant>E_NOTICE</constant> level errors (such as setting
      it to <constant>E_ALL</constant>) then you will see these
      errors.  By default, <link linkend="ini.error-reporting">
      error_reporting</link> is turned down to not show them.
     </para>
     <para>
      As stated in the <link
      linkend="language.types.array.syntax">syntax</link> section,
      there must be an expression between the square brackets
      ('<literal>[</literal>' and '<literal>]</literal>').  That means
      that you can write things like this:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      This is an example of using a function return value
      as the array index. PHP also knows about constants,
      as you may have seen the <literal>E_*</literal> ones
      before.      

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      Note that <literal>E_ERROR</literal> is also a valid identifier, 
      just like <literal>bar</literal> in the first example. But the last
      example is in fact the same as writing:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      because <literal>E_ERROR</literal> equals <literal>1</literal>, etc.
     </para>
     <para>
      As we already explained in the above examples, 
      <literal>$foo[bar]</literal> still works but is wrong.
      It works, because <literal>bar</literal> is due to its syntax
      expected to be a constant expression. However, in this case no 
      constant with the name <literal>bar</literal> exists. PHP now
      assumes that you meant <literal>bar</literal> literally, 
      as the string <literal>"bar"</literal>, but that you forgot
      to write the quotes.
     </para>
     <sect4>
      <title>So why is it bad then?</title>
      <para>
       At some point in the future, the PHP team might want to add another
       constant or keyword, or you may introduce another constant into your
       application, and then you get in trouble. For example,
       you already cannot use the words <literal>empty</literal> and 
       <literal>default</literal> this way, since they are special 
       <link linkend="reserved">reserved keywords</link>.
      </para>
      <note>
       <simpara>
        To reiterate, inside a double-quoted <type>string</type>, it's
        valid to not surround array indexes with quotes so
        <literal>"$foo[bar]"</literal> is valid.  See the above 
        examples for details on why as well as the section on
        <link linkend="language.types.string.parsing">variable parsing 
        in strings</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>Converting to array</title>
    
    <para>
     For any of the types: <type>integer</type>, <type>float</type>,
     <type>string</type>, <type>boolean</type> and <type>resource</type>,
     if you convert a value to an <type>array</type>, you get an array 
     with one element (with index 0), which is the scalar value you 
     started with.
    </para>
    
    <para>
     If you convert an <type>object</type> to an array, you get the
     properties (member variables) of that object as the array's elements. 
     The keys are the member variable names.
    </para>
    
    <para>
     If you convert a &null; value to an array, you get an empty array.
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Examples</title>
    <para>
     The array type in PHP is very versatile, so here will be some 
     examples to show you the full power of arrays.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// this
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // key will be 0
          );

// is completely equivalent with
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // key will be 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// will result in the array array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// or simply array('a', 'b', 'c')
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>Using array()</title>
     <programlisting role="php">
<![CDATA[
<?php
// Array as (property-)map
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );
            
// strictly numerical keys
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// this is the same as array(0 => 7, 1 => 8, ...)

$switching = array(         10, // key = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // key = 6 (maximum of integer-indices was 5)
                    '8'  =>  2, // key = 8 (integer!)
                    '02' => 77, // key = '02'
                    0    => 12  // the value 10 will be overwritten by 12
                  );
                  
// empty array
$empty = array();         
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Collection</title>
     <programlisting role="php">
<![CDATA[
<?php
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Do you like $color?\n";
}

/* output:
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
*/
?>
]]>
     </programlisting>
    </example>
    
    <para>
     Note that it is currently not possible to change the values of the array
     directly in such a loop. 
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &$color )
      
       See bug#3074
      -->
     A workaround is the following: 
     <example id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
<![CDATA[
<?php
foreach ($colors as $key => $color) {
    // won't work:
    //$color = strtoupper($color);
    
    // works:
    $colors[$key] = strtoupper($color);
}
print_r($colors);

/* output:
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     This example creates a one-based array.
     <example>
      <title>One-based index</title>
      <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);

/* output:
Array 
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
*/
]]>   
      </programlisting>
     </example>
    </para>
    <example>
     <title>Filling an array</title>
     <programlisting role="php">
<![CDATA[
// fill an array with all items from a directory
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle); 
?>
]]>
     </programlisting>
    </example>
    <para>
     Arrays are ordered. You can also change the order using various
     sorting functions. See the <link linkend="ref.array">array
     functions</link> section for more information. You can count
     the number of items in an array using the
     <function>count</function> function.
    </para>
    <example>
     <title>Sorting an array</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     Because the value of an array can be anything, it can also be
     another array. This way you can make recursive and
     multi-dimensional arrays.
    </para>
    <example>
     <title>Recursive and multi-dimensional arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6,
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Some examples to address values in the array above 
echo $fruits["holes"][5];    // prints "second"
echo $fruits["fruits"]["a"]; // prints "orange"
unset($fruits["holes"][0]);  // remove "first"

// Create a new multi-dimensional array
$juices["apple"]["green"] = "good"; 
?>
]]>
     </programlisting>
    </example>
    <para>
     You should be aware that array assignment always involves
     value copying. You need to use the reference operator to copy
     an array by reference.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 is changed,
             // $arr1 is still array(2, 3)
             
$arr3 = &$arr1;
$arr3[] = 4; // now $arr1 and $arr3 are the same
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objects</title>

   <sect2 id="language.types.object.init">
    <title>Object Initialization</title>

    <para>
     To initialize an object, you use the <literal>new</literal>
     statement to instantiate the object to a variable.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     For a full discussion, please read the section <link
     linkend="language.oop">Classes and Objects</link>.
    </simpara>
   </sect2>
   
   <sect2 id="language.types.object.casting">
    <title>Converting to object</title>
    
    <para>
     If an object is converted to an object, it is not modified. If a value
     of any other type is converted to an object, a new instance of the
     <literal>stdClass</literal> built in class is created. If the value
     was null, the new instance will be empty. For any other value, a
     member variable named <literal>scalar</literal> will contain the
     value.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // outputs 'ciao'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   
  </sect1>

  <sect1 id="language.types.resource">
   <title>Resource</title>
    
    <para>
     A resource is a special variable, holding
     a reference to an external resource. Resources
     are created and used by special functions.
     See the <link linkend="resource">appendix</link> 
     for a listing of all these
     functions and the corresponding resource types.
    </para>
    
    <note>
     <simpara>
      The resource type was introduced in PHP 4
     </simpara>
    </note>

   <sect2 id="language.types.resource.casting">
    <title>Converting to resource</title>
    
    <para>
     As resource types hold special handlers to opened
     files, database connections, image canvas areas and
     the like, you cannot convert any value to a resource.
    </para>
   </sect2>

    <sect2 id="language.types.resource.self-destruct">
     <title>Freeing resources</title>
    
    <para>
     Due to the reference-counting system introduced
     with PHP4's Zend-engine, it is automatically detected
     when a resource is no longer referred to (just
     like Java). When this is
     the case, all resources that were in use for this 
     resource are made free by the garbage collector.
     For this reason, it is rarely ever necessary to
     free the memory manually by using some free_result
     function.
     <note>
      <simpara>
       Persistent database links are special, they 
       are <emphasis>not</emphasis> destroyed by the 
       garbage collector. See also the section about <link 
       linkend="features.persistent-connections">persistent 
       connections</link>.
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>NULL</title>
    
   <para>
    The special &null; value represents 
    that a variable has no value. &null; is the only possible value of type
    <type>NULL</type>.
   </para>
    <note>
     <simpara>
      The null type was introduced in PHP 4
     </simpara>
    </note>
    <para>
     A variable is considered to be &null; if
     <itemizedlist>
      <listitem>
       <para>
        it has been assigned the constant &null;.
       </para>
      </listitem>
      <listitem>
       <para>
        it has not been set to any value yet.
       </para>
      </listitem>
      <listitem>
       <para>
        it has been <function>unset</function>.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    
   <sect2 id="language.types.null.syntax">
    <title>Syntax</title>
    <para>
     There is only one value of type &null;, and that is 
     the case-insensitive keyword &null;.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;       
?>
]]>
</programlisting>
     </informalexample>
    </para>
    <para>
     See also <function>is_null</function> and <function>unset</function>.
    </para>
   </sect2>
  </sect1>
 
  <sect1 id="language.pseudo-types">
   <title>Pseudo-types used in this documentation</title> 

   <sect2 id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal> indicates that a parameter may accept multiple (but not
     necesseraly all) types.
    </para>
    <para>
     <function>gettype</function> for example will accept all PHP types,
     while <function>str_replace</function> will accept strings and arrays.
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal> indicates that a parameter can be either
     <type>integer</type> or <type>float</type>.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>callback</title>
    <para>
     Some functions like <function>call_user_func</function> 
     or <function>usort</function> accept user defined 
     callback functions as a parameter. Callback functions can not only
     be simple functions but also object methods including static class
     methods. 
    </para>
    <para>
     A PHP function is simply passed by its name as a string. You can
     pass any builtin or user defined function with the exception of 
     <function>array</function>, 
     <function>echo</function>, 
     <function>empty</function>, 
     <function>eval</function>, 
     <function>exit</function>, 
     <function>isset</function>, 
     <function>list</function>, 
     <function>print</function> and 
     <function>unset</function>.
    </para>
    <para>
     A method of an instantiated object is passed as an array containing
     an object as the element with index 0 and a method name as the 
     element with index 1.
    </para>
    <para>
     Static class methods can also be passed without instantiating an
     object of that class by passing the class name instead of an 
     object as the element with index 0.
    </para>

    <para>
     <example>
      <title>
       Callback function examples
      </title>
      <programlisting role="php">
<![CDATA[
<?php 

// simple callback example
function foobar() {
    echo "hello world!";
}
call_user_func("foobar"); 

// method callback examples
class foo {
  function bar() {
    echo "hello world!";
  }
}

// static class method call without instantiating an object
call_user_func(array("foo", "bar")); 

$foo = new foo;

call_user_func(array($foo, "bar")); // object method call


?>
]]>
      </programlisting>
     </example>
    </para>  
   
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Type Juggling</title>

   <simpara>
    PHP does not require (or support) explicit type definition in
    variable declaration; a variable's type is determined by the
    context in which that variable is used. That is to say, if you
    assign a string value to variable <parameter>$var</parameter>,
    <parameter>$var</parameter> becomes a string. If you then assign an
    integer value to <parameter>$var</parameter>, it becomes an
    integer.
   </simpara>
   <para>
    An example of PHP's automatic type conversion is the addition
    operator '+'. If any of the operands is a float, then all
    operands are evaluated as floats, and the result will be a
    float. Otherwise, the operands will be interpreted as integers,
    and the result will also be an integer. Note that this does NOT
    change the types of the operands themselves; the only change is in
    how the operands are evaluated.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo is string (ASCII 48)
$foo += 2;   // $foo is now an integer (2)
$foo = $foo + 1.3;  // $foo is now a float (3.3)
$foo = 5 + "10 Little Piggies"; // $foo is integer (15)
$foo = 5 + "10 Small Pigs";     // $foo is integer (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    If the last two examples above seem odd, see <link
    linkend="language.types.string.conversion">String
    conversion to numbers</link>.
   </simpara>
   <simpara>
    If you wish to force a variable to be evaluated as a certain type,
    see the section on <link linkend="language.types.typecasting">Type
    casting</link>. If you wish to change the type of a variable, see
    <function>settype</function>.
   </simpara>
   <para>
    If you would like to test any of the examples in this section, you
    can use the <function>var_dump</function> function.
   </para>
   <note>
    <para>
     The behaviour of an automatic conversion to array is currently
     undefined.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a is a string
$a[0] = "f";  // What about string offsets? What happens?
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Since PHP (for historical reasons) supports indexing into strings
     via offsets using the same syntax as array indexing, the example
     above leads to a problem: should $a become an array with its first
     element being "f", or should "f" become the first character of the
     string $a?
    </para>
    <para>
     The current versions of PHP interpret the second assignment as
     a string offset identification, so $a becomes "f", the result
     of this automatic conversion however should be considered
     undefined. PHP 4 introduced the new curly bracket syntax to access
     characters in string, use this syntax instead of the one presented
     above: 
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a is a string
$a{1} = "f";   // $a is now "afc"
?>
]]>
      </programlisting>
     </informalexample>
     See the section titled <link linkend="language.types.string.substr">String
     access by character</link> for more informaton.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Type Casting</title>

    <para>
     Type casting in PHP works much as it does in C: the name of the
     desired type is written in parentheses before the variable which
     is to be cast.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo is an integer
$bar = (boolean) $foo;   // $bar is a boolean
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     The casts allowed are:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - cast to integer</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - cast to boolean</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - cast to float</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - cast to string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - cast to array</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - cast to object</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Note that tabs and spaces are allowed inside the parentheses, so
     the following are functionally equivalent:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Instead of casting a variable to string, you can also enclose
      the variable in double quotes.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo is an integer
$str = "$foo";        // $str is a string
$fst = (string) $foo; // $fst is also a string

// This prints out that "they are the same"
if ($fst === $str) {
    echo "they are the same";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>
     
    <para>
     It may not be obvious exactly what will happen when casting
     between certain types. For more info, see these sections:
    
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Converting to 
        boolean</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Converting to 
        integer</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">Converting to 
        float</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Converting to 
        string</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Converting to 
        array</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Converting to 
        object</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Converting to 
        resource</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
