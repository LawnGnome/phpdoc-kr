<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.13 $ -->
<!-- EN-Revision: 1.66 -->
 <chapter id="language.variables">
  <title>변수</title>
  
  <sect1 id="language.variables.basics">
   <title>기본문법</title>

   <simpara>
    PHP에서 변수는 변수명 앞에 달러사인을 덧붙여 표현된다. 변수명은 
    대소문자를 구별한다.
   </simpara>

   <para>
    PHP에서 변수명은 다음 규칙을 따른다. 유효한 변수명은 문자나 밑줄로
    시작하고, 그 뒤에 문자, 숫자, 밑줄이 붙을수 있다. 정규표현식으로 표현하면
    다음과 같다:
    '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
   </para>
   
   <note>
    <simpara>
     여기서, 문자는 a-z, A-Z, 그리고 아스키문자(ASCII) 127에서 255까지(0x7f-0xff).
    </simpara>
   </note>

   <para>
    <informalexample>
     <programlisting role="php"> 
<![CDATA[
<?php
$var = "Bob";
$Var = "Joe";
echo "$var, $Var";      // outputs "Bob, Joe"

$4site = 'not yet';     // invalid; starts with a number
$_4site = 'not yet';    // valid; starts with an underscore
$tyte = 'mansikka';    // valid; '' is (Extended) ASCII 228.
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    PHP 3에서 변수는 항상 값에 의해 지정되야 한다(assinged by value). 
    변수를 표현식으로 지정할때에 원래 표현식의 모든 값이 목표 변수로 복사된다.
    이 말의 의미는 예를 들면, 어떤 변수값을 다른 변수로 지정한 후에,
    그 변수중 어떤 하나를 변경하는것이 다른 변수에 영향을 미치지 않는다는
    의미를 갖는다.  이런 종류의 지정에 대해서 
    <link linkend="language.expressions">표현식</link>을 참고.
   </para>
   <para>
    PHP 4에서는 이와 다른 방법으로 변수에 값이 지정된다:
    <link linkend="language.references">참조에 의한 지정</link>. 
    이 용어의 의미는 새로운 변수가 원래 변수를 참조한다는 것이다.(즉,
    "원래 변수의 별명이 되는것" 이나 "가리키는 것")
    새 변수의 변경은 원래 변수에 영향을 미치고, 그 반대도 가능하다.
    이것은 복사가 수행되지 않는다는 것을 의미한다. 따라서, 지정은
    매우 신속하게 이루어진다. 하지만, 속도향상은 견고한 루프나 
    거대한 <link linkend="language.types.array">배열</link>이나
    <link linkend="language.types.object">객체</link>를 지정할때만
    효과가 있을것이다.
   </para>
   <para>
    참조에 의한 지정을 위해서는, 단순히 지정되는(소스 변수) 변수의 시작부분에
    엠퍼센트(&amp;)를 덧붙이면 된다. 예를 들면 다음 코드 예는
    'My name is Bob'이 두번 출력된다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 'Bob';              // Assign the value 'Bob' to $foo
$bar = &$foo;              // Reference $foo via $bar.
$bar = "My name is $bar";  // Alter $bar...
echo $bar;
echo $foo;                 // $foo is altered too.
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    주의할 것은 오직 이름이 부여된 변수만이 참조에 의해 지정된다는 것이다.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 25;
$bar = &$foo;      // This is a valid assignment.
$bar = &(24 * 7);  // Invalid; references an unnamed expression.

function test()
{
   return 25;
}

$bar = &test();    // Invalid.
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.variables.predefined">
   <title>미리 선언된 변수</title>
   
   <simpara>
    PHP는 실행되는 스크립트에 적용이되는 상당량의 미리 선언된 변수를 제공한다.
    하지만, 이 변수의 대부분은 운영되는 서버, 서버의 버전, 서버의 설정, 
    다른 팩터와 관련되어 있어서 완벽하게 문서화되지 않았다. 이 중 몇개의 변수는
    <link linkend="features.commandline">커맨드 라인</link>에서 실행되는 PHP에서는
    유효하지 않다. 
    <link linkend="reserved.variables">예약된 미리 선언된 변수</link>의 섹션을 참고.
   </simpara>

   <warning>
    <simpara>
     PHP 4.2.0 이후 버전부터, PHP 디렉티브 <link linkend="ini.register-globals">register_globals</link>의
     기본값은 <emphasis>off</emphasis>가 되었다.
     register_globals를 <emphasis>off</emphasis>로 놓으면, 전역 유효영역안의 미리 선언된 변수 집합들에
     영향을 미친다. 예를 들면, <varname>DOCUMENT_ROOT</varname>값을 얻기 위해서는
     <varname>$DOCUMENT_ROOT</varname> 대신에 <varname>$_SERVER['DOCUMENT_ROOT']</varname>를,
     <literal>http://www.example.com/test.php?id=3</literal>에서 <varname>$id</varname> 대신에
     <varname>$_GET['id']</varname>를, <varname>$HOME</varname> 대신에 <varname>$_ENV['HOME']</varname>을 사용해야 한다.
    </simpara>
    <simpara>
     이와 관련된 변경사항은 <link linkend="ini.register-globals">register_globals</link>의
     설정 엔트리를 읽거나, <link linkend="security.registerglobals">Using Register Globals</link>에 관한
     보안 챕터는 물론, <ulink url="&url.php.release4.1.0;">4.1.0</ulink>과
     <ulink url="&url.php.release4.2.0;">4.2.0</ulink> Release Announcements도 참고하기 바란다.
    </simpara>
    <simpara>
     <link linkend="language.variables.superglobals">superglobal arrays</link>와 같은
     가용한 PHP의 예약된 미리 선언된 변수를 사용하는 것을 추천한다.
    </simpara>
   </warning>

   <simpara>
    4.1.0 버전 이후에, pHP는 웹서버, 환경, 유저 입력과 관련된 미리 선언된 배열 
    변수 집합을 추가적으로 제공한다. 이 새로운 배열은 자동적으로 전역화되기 때문에
    더 특별해진다. 즉, 자동적으로 모든 유효영역안에서 적용이 가능하다. 이런 이유로,
    이런 변수를 '자동전역변수' 또는 '슈퍼전역변수' 이라고 불리기도 한다. (PHP에서는
    사용자-선언 슈퍼전역변수가 허용되지 않는다.) 슈퍼전역변수는 아래에 열거한다.
    하지만, 이 변수 목록과 논의는 <link linkend="reserved.variables">예약된 미리선언된 변수</link>섹션을
    참고한다. 또한 구버전의 미리선언된 변수(<varname>$HTTP_*_VARS</varname>)가 아직도
    존재한다는 것에 주의한다.

    &avail.register-long-arrays;
   </simpara>
   
   <note>
    <title>가변 변수</title>
    <para>
     슈퍼전역변수는 
     <link linkend="language.variables.variable">가변 변수</link>로는 쓰일수 없다.
    </para>
   </note>

   <para>
    <link linkend="ini.variables-order">variables_order</link>내의 특정 변수들이
    설정되어있지 않으면, 적합한 PHP의 미리선언된 배열도 비워있게 된다.
   </para>

   <variablelist id="language.variables.superglobals">
    <title>PHP 슈퍼전역변수</title>
    <varlistentry>
     <term><link linkend="reserved.variables.globals">$GLOBALS</link></term>
     <listitem>
      <simpara>
       스트립트의 전역 유효영역에서 쓸수있는 모든 변수에 대한 참조를 포함한다.
       이 배열의 key는 전역 변수들의 이름이다.
       PHP 3 이래로 <varname>$GLOBALS</varname>가 존재해왔다.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.server">$_SERVER</link></term>
     <listitem>
      <simpara>
       웹서버나, 현재 스크립트의 실행환경에 직접적으로 관련되어 설정되는
       변수이다. 구버전의 <varname>$HTTP_SERVER_VARS</varname> 배열과 동일하다.
       (이 변수는 현재 유효하지만, 추천하지는 않는다)
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.get">$_GET</link></term>
     <listitem>
      <simpara>
       HTTP GET에 의해 스크립트로 제공되는 변수이다. 
       구버전의 <varname>$HTTP_GET_VARS</varname> 배열과 동일하다.
       (이 변수는 현재 유효하지만, 추천하지는 않는다)
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.post">$_POST</link></term>
     <listitem>
      <simpara>
       HTTP POST에 의해 스크립트로 제공되는 변수이다.
       구버전의 <varname>$HTTP_POST_VARS</varname> 배열과 동일하다.
       (이 변수는 현재 유효하지만, 추천하지는 않는다)
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.cookies">$_COOKIE</link></term>
     <listitem>
      <simpara>
       HTTP 쿠키에 의해 스크립트로 제공되는 변수이다.
       구버전의 <varname>$HTTP_COOKIE_VARS</varname> 배열과 동일하다.
       (이 변수는 현재 유효하지만, 추천하지는 않는다)
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.files">$_FILES</link></term>
     <listitem>
      <simpara>
       HTTP post 파일 업로드에 의해 스크립트로 제공되는 변수이다.
       구버전의 <varname>$HTTP_POST_FILES</varname> 배열과 동일하다.
       (이 변수는 현재 유효하지만, 추천하지는 않는다). 더 자세한 정보는
       <link linkend="features.file-upload.post-method">POST 메소드 업로드</link>를
       참고하도록 한다.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.environment">$_ENV</link></term>
     <listitem>
      <simpara>
       환경에 의해 스크립트로 제공되는 변수이다.
       구버전의 <varname>$HTTP_ENV_VARS</varname> 배열과 동일하다.
       (이 변수는 현재 유효하지만, 추천하지는 않는다)
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.request">$_REQUEST</link></term>
     <listitem>
      <simpara>
       GET, POST, COOKIE 입력 메카니즘을 통해 스크립트로 제공되는 변수이다.
       이 메카니즘은 신용될수는 없다. 이 배열 안에 포함된 존재하는 변수와 변수의 나열 순서는
       PHP <link linkend="ini.variables-order">variables_order</link> 설정 디렉티브에
       의해 정의된다. 이 배열은 PHP 4.1.0 이전 버전에서 동일한 변수가 존재하지 않는다.
       <function>import_request_variables</function>도 참고.
      </simpara>
      <caution>
       <simpara>
        PHP 4.3.0이후, <varname>$_REQUEST</varname> 안에 FILE 정보를 갖는
        <varname>$_FILES</varname> 변수가 존재하지 않게 되었다.
       </simpara>
      </caution>
      <note>
       <simpara>
        <link linkend="features.commandline">커맨드 라인</link>에서 수행될때,
        이 변수는 <varname>argv</varname>와 <varname>argc</varname> 엔트리에 포함되지
        <emphasis>않는다</emphasis>; 이 변수들은 <varname>$_SERVER</varname> 배열에
        존재한다.
       </simpara>
      </note> 
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.session">$_SESSION</link></term>
     <listitem>
      <simpara>
       스크립트의 세션에 등록되는 변수이다. 
       구버전의 <varname>$HTTP_SESSION_VARS</varname> 배열과 동일하다.
       (이 변수는 현재 유효하지만, 추천하지는 않는다). 더 자세한 정보는
       <link linkend="ref.session">Session handling functions</link>섹션을 참고.
      </simpara>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect1>


  <sect1 id="language.variables.scope">
   <title>변수 유효영역</title>

   <simpara>
    변수의 유효영역은 변수가 정의된 환경을 말한다. 대부분의 경우 모든 PHP
    변수는 한군데의 유효영역만을 갖는다. 이 한군데의 유효영역은 include되거나
    require된 파일로도 확장된다. 예를 들면:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
include "b.inc";
?>
]]>
    </programlisting>
   </informalexample>
   <simpara>
    위 예제코드에서는 include된 <filename>b.inc</filename> 스크립트안에서도
    <varname>$a</varname> 변수가 사용가능하다. 하지만, 사용자-선언 함수에서는
    로컬 함수 유효영역이 적용된다. 함수내에서 사용되는 모든 변수는 기본값으로
    로컬 변수 유효영역 안으로 제한된다. 예를 들면:
   </simpara>
    
   <informalexample>
    <programlisting role="php"> 
<![CDATA[
<?php
$a = 1; /* global scope */ 

function Test()
{ 
    echo $a; /* reference to local scope variable */ 
} 

Test();
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    위 스크립트에서 echo문이 <varname>$a</varname>의 로컬 버전을 참조하고,
    이 영역 안에서 값을 지정되지 않았기 때문에 아무것도 출력되지 않는다. 
    C에서 전역변수는 특별히 로컬 선언으로 덮어쓰지 않는이상은 
    자동적으로 함수안에서 사용가능하다는 점에서 C 언어와 약간 차이가 있다는 것에
    주의해야 할것이다. 이런 생각으로 부주의하게 전역변수를 변경하려한다면
    문제가 될것이다. PHP에서 전역변수가 함수내에서 계속적으로 사용이 된다면
    함수안에서 global로 선언되어야 한다. 예를 들면:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
} 

Sum();
echo $b;
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    위 스크립느는 &quot;3&quot;를 출력할것이다. <varname>$a</varname>와
    <varname>$b</varname>를 함수내에서 global로 선언함으로써, 각 변수에 대한
    모든 참조는 전역 버전으로 참조될것이다. 함순에서 조작되는 전역변수의 수는
    제한이 없다.
   </simpara>

   <simpara>
    전역 유효영역의 변수에 접근할수 있는 두번째 방법이
    특별 PHP-선언 <varname>$GLOBALS</varname> 배열을 사용하는 것이다.
    이전 예제코드는 다음과 같이 다시 작성될수 있다.
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];
} 

Sum();
echo $b;
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    <varname>$GLOBALS</varname> 배열은 전역변수명이 key가 되는 연관배열이고
    배열의 요소 값이 그 변수의 내용이 된다.
    <varname>$GLOBALS</varname>이 어떻게 모든 유효영역에서 존재하는지 주의하라.
    이유는 $GLOBALS이 <link linkend="language.variables.superglobals">슈퍼전역변수</link>이기
    때문이다. 아래에 슈퍼전역변수의 파워를 설명하는 예제코드를 보였다:
   </simpara>
   <para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test_global()
{
    // Most predefined variables aren't "super" and require 
    // 'global' to be available to the functions local scope.
    global $HTTP_POST_VARS;
    
    print $HTTP_POST_VARS['name'];
    
    // Superglobals are available in any scope and do 
    // not require 'global'.  Superglobals are available 
    // as of PHP 4.1.0
    print $_POST['name'];
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   
   <simpara>
    변수 유효영역의 또 다른 중요한 기능이 <emphasis>static</emphasis> 변수이다.
    정적(static) 변수는 로컬 함수 영역에서만 존재한다. 그러나 프로그램이 그 영역을
    떠나지 않으면 그 값을 잃지 않는다. 다음예를 보자:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function Test ()
{
    $a = 0;
    echo $a;
    $a++;
}
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    이 함수는 매번 호출될때마다 <varname>$a</varname>를 <literal>0</literal>으로
    설정하고 &quot;0&quot;를 출력한다. <varname>$a</varname>++ 는 변수를 증가시키지만
    함수에서 빠져나가면 <varname>$a</varname> 변수는 사라지게되므로 아무 가치가 없다.
    현재 카운트 값을 잃지 않는 유용한 카운트 함수를 만들려면,
    <varname>$a</varname> 변수를 static으로 선언한다.
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function Test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    이제 Test() 함수가 호출될 때마다 <varname>$a</varname> 값이 출력되고
    그 값을 증가시킬것이다.
   </simpara>

   <simpara>
    정적 변수는 또한 재귀함수를 다루는 한 방법을 제공한다. 재귀함수는
    자기 자신을 호출하는 함수를 말한다. 재귀함수는 무한히 실행될수 있기
    때문에 재귀함수를 작성할때는 주의가 필요하다. 재귀를 벗어나는 방법을
    반드시 갖고 있어야 한다. 다음과 같은 단순 재귀함수는 10까지 카운트한다.
    정적 변수 <varname>$count</varname>는 멈춰야 할 때는 안다.
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function Test()
{
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        Test ();
    }
    $count--;
}
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    <literal>PHP4</literal>를 운용하는 The Zend Engine 1 은 참조로 
    <literal>static</literal>과 <literal>global</literal>의 
    변경자(modifier)를 구현한다. 예를 들면 함수 영역안에서 
    <literal>global</literal>절로 선언되는 전역 변수는 실제는 전역 변수의 참조를
    생성한다. 이런 구현방법은 다음 예에서 제기되는 원치 않는 동작을 유발할수 있다.
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    위 예제코드를 실행하면 다음과 같은 결과가 유도된다.
   </simpara>

   <screen>
NULL
object(stdClass)(0) {
}
   </screen>

   <simpara>
    이와 비슷한 동작이 <literal>static</literal> 절에서도 발생한다.
    참조가 정적으로 저장되지 않는것이다:
   </simpara>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function &get_instance_ref() {
    static $obj;

    echo "Static object: ";
    var_dump($obj);
    if (!isset($obj)) {
        // Assign a reference to the static variable
        $obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo "Static object: ";
    var_dump($obj);
    if (!isset($obj)) {
        // Assign the object to the static variable
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    위 예제코드를 실행하면 다음과 같은 결과가 유도된다.
   </simpara>

   <screen>
Static object: NULL
Static object: NULL

Static object: NULL
Static object: object(stdClass)(1) {
  ["property"]=>
  int(1)
}
   </screen>

   <simpara>
    위 예제 코드는 정적 변수에 대한 참조를 지정할때,
    <literal>&amp;get_instance_ref()</literal>함수가 두번째로 호출되는 때에
    <emphasis>기억</emphasis>되지 않는다는 것을 보여준다.
   </simpara>


  </sect1>

  <sect1 id="language.variables.variable">
   <title>가변 변수</title>

   <simpara>
    때때로 가변 변수명을 갖을수 있는것다는 것은 편리함을 준다. 즉,
    변수명이 유동적으로 설정되거나 사용될수 있다. 일반적인 변수는
    다음과 같은 구문에 의해 설정된다:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = "hello";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    가변변수는 변수값을 취해서 변수명으로 취급한다. 위 예제코드는,
    <emphasis>hello</emphasis>를 두개의 달러사인을 사용하여 변수명으로
    사용할수 있다.
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$$a = "world";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    이 지점에서 두 변수가 선언되었고 PHP 심볼 트리에 저장된다:
    <varname>$a</varname>는 "hello" 값을 갖고
    <varname>$hello</varname>는 "world" 값을 갖게 된다.
    따라서, 이 구문:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a ${$a}";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    다음과 완전히 똑같이 출력된다:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a $hello";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    즉, 둘다 <computeroutput>hello world</computeroutput>를 출력한다.
   </simpara>

   <simpara>
    배열을 갖는 가변변수를 사용하기 위해서는 애매한 문제를 해결해야 한다.
    즉 <varname>$$a[1]</varname>를 쓴다면 해석기는 <varname>$a[1]</varname>가
    변수를 의미하는지 알수 있어야 한다. 또는 <varname>$$a</varname>가
    변수이기를 바라고, [1]가 그 변수의 인덱스인지 알수 있어야 한다.
    이런 애매한 문제를 해결하기 위한 문법:
    첫번째 목적을 위해 <varname>${$a[1]}</varname>과
    두번째 목적을 위해 <varname>${$a}[1]</varname>을 들수 있다.
   </simpara>
   
   <warning>
    <simpara>
     가변 변수가 PHP의 <link linkend="language.variables.superglobals">슈퍼전역 배열</link>로
     사용될수 없음을 주의해야 한다. 
     <varname>${$_GET}</varname>와 같은 변수를 사용할수 없음을 의미한다. 슈퍼전역변수의
     유효성과 구버전의 <varname>HTTP_*_VARS</varname>를 제어하는 방법을 원한다면,
     그 변수들을 <link linkend="language.references">참조</link>하려 할것이다.
    </simpara>
   </warning>
  
  </sect1>

  <sect1 id="language.variables.external">
   <title>PHP 외부 출신의 변수들</title>
   
   <sect2 id="language.variables.external.form">
    <title>HTML 폼 (GET과 POST)</title>

    <simpara>
     폼이 PHP 스크립트로 전달될때, 그 폼안의 정보가 스크립트내에서
     자동적으로 유효해진다. 이 정보에 접근할 수 있는 많은 방법이 제공된다.
     예를 들면:
    </simpara>

    <para>
     <example>
      <title>단순한 HTML 폼</title>
      <programlisting role="html">
<![CDATA[
<form action="foo.php" method="POST">
    Name:  <input type="text" name="username"><br>
    Email: <input type="text" name="email"><br>
    <input type="submit" name="submit" value="Submit me!">
</form>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     특별한 설정과 개인적인 선호에 의해, HTML 폼으로부터 데이터를 접근할수 있는
     많은 방법이 존재한다. 몇가지르 예를 들면:
    </para>
    
    <para>
     <example>
      <title>단순한 POST HTML 폼으로 부터 데이터에 접근하기</title>
      <programlisting role="html">
<![CDATA[
<?php 
// Available since PHP 4.1.0

   print $_POST['username'];
   print $_REQUEST['username'];

   import_request_variables('p', 'p_');
   print $p_username;

// Available since PHP 3.  As of PHP 5.0.0, these long predefined
// variables can be disabled with the register_long_arrays directive.

   print $HTTP_POST_VARS['username'];

// Available if the PHP directive register_globals = on.  As of 
// PHP 4.2.0 the default value of register_globals = off.
// Using/relying on this method is not preferred.

   print $username;
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     GET 폼을 사용하는 것은 적절한 GET 기선언 변수를 대신 사용할때를 제외하면
     동일하다. GET은 QUERY_STRING (URL에서 '?'이후의 값)에도 적용이 된다.
     따라서, 예를 들면 <literal>http://www.example.com/test.php?id=3</literal>는
     <varname>$_GET['id']</varname>으로 접근할수 있는 GET 데이터를 포함한다.
     또한 <link linkend="reserved.variables.request">$_REQUEST</link>와
     <function>import_request_variables</function>를 참고.
    </para>

    <note>
     <para>
      <varname>$_POST</varname> 와 <varname>$_GET</varname> 같은
      <link linkend="language.variables.superglobals">슈퍼전역 배열</link>은
      PHP 4.1.0 이후버전부터 사용되기 시작했다.
     </para>
    </note>

    <para>
     전에 설명한대로, PHP 4.2.0 이전에는 
     <link linkend="ini.register-globals">register_globals</link>의 기본값이
     <emphasis>on</emphasis>이었고, PHP 3에서는 항상 on이었다. PHP 커뮤니티는
     그 디렉티브 값이 <emphasis>off</emphasis>가 되어있다고 가정하고 적절하게
     코딩하는 것을 추천하기 때문에 이 디렉티브값에 연연할 필요가 없다.
    </para>

    <note>
     <para>
      <link linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link> 설정 디렉티브는
      Get, Post, Cookie 값에 영향을 준다. 이 값이 켜져있으면, 그 값(It's "PHP!")은
      자동적으로 (It\'s \"PHP!\")이 될것이다. 이 회피는 DB 입력을 위해 필요하다.
      또한 <function>addslashes</function>, <function>stripslashes</function>과
      <link linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>를 참고한다.
     </para>
    </note>
    
    <simpara>
     PHP는 폼 변수가 쓰이는 환경안의 배열도 이해한다.
     (<link linkend="faq.html">관련 faq</link>를 참고) 예를 들면,
     관련 변수를 함께 그룹화하거나, 다중 select 입력으로부터
     값을 끄집어내기위해 이 기능을 사용할수 있다. 예로써, 자신에게 폼을
     post하고 그 데이터를 출력해보자:
    </simpara>

    <para>
     <example>
      <title>좀더 복잡해진 폼 변수들</title>
      <programlisting role="php">
<![CDATA[
<?php
if (isset($_POST['action']) && $_POST['action'] == 'submitted') {
    print '<pre>';

    print_r($_POST);
    print '<a href="'. $_SERVER['PHP_SELF'] .'">Please try again</a>';

    print '</pre>';
} else {
?>
<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="POST">
    Name:  <input type="text" name="personal[name]"><br>
    Email: <input type="text" name="personal[email]"><br>
    Beer: <br>
    <select multiple name="beer[]">
        <option value="warthog">Warthog</option>
        <option value="guinness">Guinness</option>
        <option value="stuttgarter">Stuttgarter Schwabenbru</option>
    </select><br>
    <input type="hidden" name="action" value="submitted">
    <input type="submit" name="submit" value="submit me!">
</form>
<?php
}
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     PHP 3에서, 배열 폼 변수의 사용은 1차원 배열로만 제한된다.
     PHP 4에서는 이런 제약이 적용되지 않는다.
    </para>

    <sect3 id="language.variables.external.form.submit">
     <title>변수명으로 IMAGE SUBMIT</title>

     <simpara>
      form을 전달할때, 표준적인 submit 버튼 태그 대신 다음과 같이
      image 태그를 사용할수 있다.
     </simpara>

     <informalexample>
      <programlisting role="html">
<![CDATA[
<input type="image" src="image.gif" name="sub">
]]>
      </programlisting>
     </informalexample>

     <simpara>
      유저가 image의 어느곳에서 클릭하더라도 수행 폼은 두가지 추가적인
      변수를 서버로 전송할것이다. sub_x와 sub_y. 이 변수는 image안에서
      유저가 클릭하는 좌표를 갖는다. 실제로 브라우저에 의해 보내지는
      변수명은 밑줄(_)이 아니라 마침표(.)를 포함한다. 그러나 PHP는 자동으로 
      마침표를 밑줄로 변환한다.
     </simpara>
    </sect3>

   </sect2>

   <sect2 id="language.variables.external.cookies">
    <title>HTTP 쿠키</title>

    <simpara>
     PHP는 <ulink url="&spec.cookies;">Netscape's Spec</ulink>에 의해 정의된
     HTTP 쿠키를 투명하게 지원한다. 쿠키는 원격 브라우저안에 데이터를 저장하는
     메카니즘이고 따라서 복귀하는 유저를 추적하거나 식별하게 해준다. 
     <function>setcookie</function> 함수를 사용하여 쿠키를 설정할수 있다. 쿠키는
     HTTP 헤더의 일부분이고, 그래서 SetCookie함수는 브라우저에 출력이 생기기전에
     호출되어야 한다. 이 제약은 <function>header</function> 함수에도 같이 적용된다.
     쿠키 데이터는 적절한 쿠키 데이터 배열에 존재하게 된다.
     <varname>$_COOKIE</varname>, <varname>$HTTP_COOKIE_VARS</varname>는 물론
     <varname>$_REQUEST</varname> 배열에 존재한다.
     더 자세한 정보와 예제를 보기 위해 <function>setcookie</function> 매뉴얼 페이지를
     참고.
    </simpara>

    <simpara>
     단일 쿠키 변수에 여러값을 지정하려한다면, 배열로 그 값을 지정할수 있다.
     예를 들면:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
  setcookie("MyCookie[foo]", "Testing 1", time()+3600);
  setcookie("MyCookie[bar]", "Testing 2", time()+3600);
?>
]]>
     </programlisting>
    </informalexample>
    
    <simpara>
     위 예제코드는 MyCookie가 스크립트내에서 단일 배열이 될지라도 두개의
     분리된 쿠키를 생성할수 있다. 여러값을 갖는 단일 쿠키를 설정하려면,
     첫번째로 그 값에 <function>serialize</function>나
     <function>explode</function>를 사용할것을 고려하도록 한다.
    </simpara>

    <simpara>
     쿠키는 경로나 도메인이 다르지 않으면 브라우저안에서 같은 이름을 갖는
     이전 쿠키를 교체한다는 것에 주의해야 한다. 따라서, 쇼핑 카트 애플리케이션을
     위해서는 카운터를 유지하고 이 카운터를 전달하기를 원할것이다.
    </simpara>

    <example>
     <title><function>setcookie</function>예제 코드</title>
     <programlisting role="php">
<![CDATA[
<?php
$count++;
setcookie("count", $count, time()+3600);
setcookie("Cart[$count]", $item, time()+3600);
?>
]]>
     </programlisting>
    </example>

   </sect2>

   <sect2 id="language.variables.external.dot-in-names">
    <title>유입되는 변수명에 존재하는 점(dot)</title>

    <para>
     표준적으로, PHP는 스크립트내로 변수를 전달할때 변수명을 변경하지
     않는다. 하지만, 점(마침표, full stop)은 PHP 변수명안에서 유효한
     문자가 될수 없다는것에 주의해야 할것이다. 이에 유의하여 다음 코드를 보자:
     <programlisting role="php">
<![CDATA[
<?php
$varname.ext;  /* invalid variable name */
?>
]]>
     </programlisting>
     현재, 해석기가 보게되는 것은 <varname>$varname</varname>이라는 변수와
     그 뒤에 문자열 결합 연산자, 그 뒤에 벌거벗은 문자열(barestring) 'ext'이다.
     (즉, 따옴표로 둘러싸지 않은 문자열은 key나 예약된 단어와 일치하지 않음)
     확실하게 이 결과는 원치 않은것이다.
    </para>

    <para>
     이러한 이유로, PHP는 유입되는 변수명안의 점(.)을 밑줄(_)로 변경한다는것을
     명심해야 한다.
    </para>

   </sect2>

   <sect2 id="language.variables.determining-type-of">
    <title>변수 타입 결정하기</title>

    <para>
     PHP는 변수 타입을 결정하고 변수를(보통) 필요한 타입으로 변환하기 때문에,
     어느 시간에 변수가 무슨 타입인지 알수가 없다. PHP는 변수가 무슨 타입인지
     확인할수 있는 몇가지 함수를 제공한다. 그 함수들은 다음과 같다:
     <function>gettype</function>, <function>is_array</function>,
     <function>is_float</function>, <function>is_int</function>,
     <function>is_object</function>,
     <function>is_string</function>.
     <link linkend="language.types">타입</link> 챕터를 참고.
    </para>
   </sect2>

  </sect1>
     
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
