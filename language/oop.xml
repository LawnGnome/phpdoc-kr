<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.43 -->
 <chapter id="language.oop">
  <title>클래스와 객체</title>

  <sect1 id="keyword.class">
   <title><literal>클래스</literal></title>
   <para>
    클래스는 특정 변수들과 그리고 이 변수들을 써서 동작하는 함수의 집합체이다.
    다음과 같은 문법을 사용하여 선언한다:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Cart
{
    var $items;  // Items in our shopping cart
   
    // Add $num articles of $artnr to the cart
 
    function add_item ($artnr, $num)
    {
        $this->items[$artnr] += $num;
    }
   
    // Take $num articles of $artnr out of the cart
 
    function remove_item ($artnr, $num)
    {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } else {
            return false;
        }   
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    위 코드는 카트(cart)를 위한 품목의 연관 배열과 cart에 아이템을 추가하거나
    제거하는 두 개의 함수로 구성된 Cart라는 이름을 갖는 클래스를 선언하고 있다.
   </para>

   <warning>
    <simpara>
     클래스 선언부를 여러 파일이나 여러 PHP블록으로 분리할수 <emphasis>없다</emphasis>
     다음 코드는 동작하지 않을것이다:
    </simpara>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
<?php
class test {
?>
<?php
    function test() {
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>

   <simpara>
    PHP 4에서는 다음과 같은 주의사항을 숙지해야 한다.
   </simpara>
    
   <caution>
    <simpara>
     Zend에서는 <literal>stdClass</literal>같은 명칭을 내부적으로
     사용하며 이 명칭은 예약되어있다. 따라서 PHP에서는 <literal>stdClass</literal>라는
     클래스명을 만들수 없다.
    </simpara>
   </caution>
    
   <caution>
    <simpara>
      <literal>__sleep</literal>과 <literal>__wakeup</literal>함수는
      PHP 클래스에서 중요한 역할을 수행한다. 이들과 결합된 매직 기능을 원
      하지 않는다면 이런 이름을 클래스내에서 사용할수 없다. 
      아래 글에서 자세하게 설명할것이다.
    </simpara>
   </caution>
    
   <caution>
    <simpara>
      PHP에서 __으로 시작하는 함수명은 매직 기능을 수행하도록 예약되어있다.
      문서화된 매직 기능을 원하지 않는다면 PHP에서 __를 갖는 함수명을 
      사용하지 않도록 한다.
    </simpara>
   </caution>

   <simpara>
    PHP 4에서 <literal>var</literal>로 변수를 선언할때는 상수로만 초기화될수
    있다. 상수가 아닌 값으로 초기화하려면, 클래스로부터 객체가 생성될때 자동적
    으로 호출되는 함수에서 초기화할 필요가 있다. 이런 함수를 생성자(constructor)
    라고 부른다. (아래글을 보라)
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
/* PHP 4에서 이 코드는 작동하지 않을것이다 */
class Cart
{
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    var $items = array("VCR", "TV");
}

/* 이와 같이 해야 한다 */
class Cart
{
    var $todays_date;
    var $name;
    var $owner;
    var $items;

    function Cart()
    {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* etc. . . */
    }
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    클래스는 타입이다. 즉, 실제 변수를 위한 청사진이다. <literal>new</literal>
    연산자를 사용하여 원하는 타입의 변수를 생성해야 한다.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$cart = new Cart;
$cart->add_item("10", 1);

$another_cart = new Cart;
$another_cart->add_item("0815", 3);
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    위 예제 코드는 Cart클래스의 <varname>$cart</varname>, <varname>$another_cart</varname>
    객체를 생성한다. <varname>$cart</varname>의 add_item() 함수는 <varname>$cart</varname>
    에 품목 번호가 10인 아이템 1개를 추가하고, <varname>$another_cart</varname>에
    품목 번호가 0815인 아이템 3개를 추가한다.
   </para>
   
   <para>
    <varname>$cart</varname>와 <varname>$another_cart</varname> 둘다 
    add_item(), remove_item() 함수와 items변수를 갖는다. 이들 모두 서로
    다른 함수와 변수이다. 이런 객체는 파일시스템의 디렉토리에 비유될수 있다.
    파일시스템에서는 서로 다른 디렉토리에 있으면 두개의 다른 README.TXT파일을 
    저장할수 있다. 이 파일 각각에 접근하기 위해서는 최상위 디렉토리에서
    각 파일로의 경로를 지정해 줘야 하듯이, 이런 각 함수를 호출하고자 한다면 
    각 함수의 완벽한 이름을 지정해야 한다: PHP에서 최상위 디렉토리는 전역 
    네임스페이스를 갖고, 경로 구분자로 <literal>-&gt;</literal>를 사용할수 있다. 
    따라서, <varname>$cart-&gt;items</varname>과 <varname>$another_cart-&gt;items</varname>
    은 서로 다른 변수를 지칭하는 것이다.
    변수는 <varname>$cart-&gt;$items</varname>이 아니라, <varname>$cart-&gt;items</varname>
    로 지정해야 한다는 것에 주의해야 한다. 즉, PHP에서 변수명은 오직 한개의
    달러사인($) 기호만 허용된다.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// correct, single $
$cart->items = array("10" => 1); 

// invalid, because $cart->$items becomes $cart->""
$cart->$items = array("10" => 1);

// correct, but may or may not be what was intended:
// $cart->$myvar becomes $cart->items
$myvar = 'items';
$cart->$myvar = array("10" => 1);  
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    클래스의 선언부에서는 프로그램이 객체에 접근할때 어느 객체명 밑에 속해있을지
    알수 없다: Cart 클래스가 선언된 후에 그 객체가 <varname>$cart</varname>나 
    <varname>$another_cart</varname> 객체명을 갖을지 알수 없는것이다. 따라서,
    Cart 클래스 선언부 안에서 <varname>$cart-&gt;items</varname>라고 쓸수 없다.
    대신에, 클래스내의 함수나 변수에 접근할 수 있게 하려면 '내 소유'나 '현재
    객체'라고 해석할수 있는 <varname>$this</varname>라는 의사-변수를 사용할수 있다.
    따라서, '<varname>$this-&gt;items[$artnr]</varname> += <varname>$num</varname>'
    이라는 코드는 '내 소유의 items 배열의 <varname>$artnr</varname>카운터를
    <varname>$num</varname>만큼 더하라' 또는 '현재 객체의 items 배열의 <varname>$artnr</varname>
    카운터를 <varname>$num</varname>만큼 더하라'고 해석할 수 있다.
   </para>

   <note>
    <para>
    클래스와 객체를 제어할 수 있는 몇가지의 유용한 함수가 제공된다.
    <link linkend="ref.classobj">클래스/객체 함수</link>에서 확인할수 있다.
    </para>
   </note>
  </sect1>
  
  <sect1 id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    때때로 기존의 클래스와 비슷한 변수와 함수를 갖는 클래스가 필요할때
    가 있다. 실제로, 모든 프로젝트에서 사용할수 있는 범용의 클래스를 
    선언하고, 특정 프로젝트에서 이런 클래스를 필요에 의해 변경하는 것은 
    좋은 습관이다. 이런 일을 수월하게 하기 위해서 클래스는 다른 클래스에서
    확장(extension) 될수 있다. 이렇게 확장되거나 파생된 클래스는 원래
    클래스의 모든 변수와 함수를 소유하고 (이런 경우를 아무도 죽지 않았음
    에도 불구하고 '상속'이라고 부른다) 필요로 하는 확장된 선언을 추가할수 있다.
    기존 클래스에서 기존 함수나 변수의 선언을 해제하여 뺄수는 없다.
    확장 클래스는 항상 하나의 기존 클래스에만 연관되어있다. 즉 다중 상속은
    지원되지 않는다. 클래스는 'extends'라는 키워드를 사용하여 확장된다.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Named_Cart extends Cart
{
    var $owner;
  
    function set_owner ($name)
    {
        $this->owner = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    위 코드는 Cart의 모든 변수와 함수는 물론 추가된 변수 <varname>$owner</varname>
    와 추가된 함수 set_owner()를 갖는 클래스를 선언한다. 이로써 이름이 있는 카트를 만들고
    카트의 소유자를 설정하고 얻어올수 있다. 이름이 있는 카트에서는 물론 기존의 일반 카트 함수
    도 쓸수 있다:
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$ncart = new Named_Cart;    // 이름이 있는 카트 만들기
$ncart->set_owner("kris");  // 그 카트에 소유자를 설정
print $ncart->owner;        // 소유자 이름을 출력
$ncart->add_item("10", 1);  // (기존 cart에서 상속한 함수 사용)
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    이런 경우를 "부모-자식" 관계라고 부르기도 한다. 부모 클래스를 만들고,
    부모 클래스에 <emphasis>기반한</emphasis> 새 클래스를 만들려면
    <literal>extends</literal>를 사용한다: 자식 클래스. 심지어 이런 새로운 
    자식 클래스를 사용하거나 이 자식 클래스에 기반한 다른 클래스도 만들수 있다.
   </para>
   <note>
    <para>
     클래스는 그것이 사용되기 전에 선언되어야 한다! 
     <literal>Cart</literal>클래스를 상속하는 <literal>Named_Cart</literal>클래스가
     필요하면 우선 <literal>Cart</literal>클래스를 먼저 선언해야 할것이다.
     <literal>Named_Cart</literal>클래스에 기반한 다른 클래스 <literal>Yellow_named_cart</literal>
     를 생성하고자 한다면 <literal>Named_Cart</literal>클래스를 먼저 선언해야 한다.
     짧게 말해서: 클래스가 선언되는 순서는 중요하다.
    </para>
   </note>
  </sect1>

  <sect1 id="language.oop.constructor">
   <title><literal>Constructors</literal></title>

   <caution>
    <simpara>
     PHP 3와 PHP 4에서 생성자(constructor)는 서로 다르게 동작한다.
     PHP 4의 문법이 강력히 선호된다.
    </simpara>
   </caution>

   <para>
    생성자는 <literal>new</literal>를 사용하여 클래스의 새 인스턴스를
    생성할때 자동으로 호출되는 클래스 내의 함수이다. PHP 3에서는 클래스의
    이름과 동일한 함수가 생성자가 된다. PHP 4에서는 클래스가 선언될때의
    클래스명과 동일한 이름을 갖는 함수가 생성자가 된다. - 차이는 
    미묘하지만 매우 중요하다 (아래 글을 볼것).
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// PHP 3와  PHP 4에서 작동함
class Auto_Cart extends Cart
{
    function Auto_Cart()
    {
        $this->add_item ("10", 1);
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    위 코드는 Cart와 같은 Auto_Cart 클래스를 선언하고
    "new"로 새로운 Auto_Cart가 생성될때마다 상품번호 "10"인
    아이템 하나를 갖는 카트로 초기화하는 생성자를 만든다.
    생성자는 인자를 취할수 있고 이런 인자로 인해 생성자를 더 유용하게
    만들어주지만 없을수도 있다. 인자가 없는 클래스를 사용하려면 
    생성자의 모든 인자는 기본값을 제공함으로써 선택적일수 있다.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// PHP 3와 PHP 4에서 동작함.
class Constructor_Cart extends Cart
{
    function Constructor_Cart($item = "10", $num = 1)
    {
        $this->add_item ($item, $num);
    }
}
 
// Shop the same old boring stuff.
 
$default_cart = new Constructor_Cart;
 
// Shop for real...
 
$different_cart = new Constructor_Cart("20", 17);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    생성자에서 발생할수 있는 에러 메시지를 <emphasis>보이지 않게</emphasis>
    하려면 <literal>@</literal>연산자를 사용할수 있다.즉,
    <literal>@new</literal>를 쓸수 있다.
   </para>

   <caution>
    <simpara>
     PHP 3에서 파생 클래스와 생성자는 많은 제약을 갖는다.
     다음 예제 코드는 이런 제약을 이해하기 위해 주의깊게 봐야할것이다.
    </simpara> 
   </caution>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
      echo "I am the constructor of A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "I am a regular function.<br>\n";
    }
}

// PHP 3에서는 어떤 생성자도 호출되지 않는다.
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    위 예제 코드는 PHP 3에서 어떤 생성자도 호출되지 않는다. PHP 3의
    규칙은 : '생성자는 클래스와 같은 이름을 갖는 함수이다'. 클래스명 
    이 B이고 이 클래스에서는 B()함수가 없으므로 아무일도 일어나지 않는다.
   </para>
   
   <para>
    PHP 4에서는 다른 규칙이 적용되어서 이런 규칙이 고쳐졌다: 클래스가
    생성자를 갖지 않을때, 원래 클래스에서 생성자가 존재하면 그 생성자가 
    호출된다. 위 예제 코드는 PHP 4에서 'I am the constructor of A.&lt;br>'
    를 출력할것이다.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
        echo "I am the constructor of A.<br>\n";
    }

    function B()
    {
        echo "I am a regular function named B in class A.<br>\n";
        echo "I am not a constructor in A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "I am a regular function.<br>\n";
    }
}

// This will call B() as a constructor.
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    PHP 3에서 클래스 A의 함수 B()는 의도하지 않았을지라도 즉시 
    클래스 B의 생성자가 될것이다. PHP 3의 규칙: '생성자는 클래스와 
    같은 이름을 갖는 함수이다'. PHP 3에서는 그 함수가 클래스 B에서
    선언되었는지 또는 거기서 상속되었는지는 상관하지 않는다.
   </para>
   
   <para>
    이런 규칙은 PHP 4에서 다음과 같이 고쳐졌다: '생성자는 그것이 선언
    된 클래스와 같은 이름을 갖는 함수이다'. 따라서 PHP 4는 클래스 B
    가 생성자를 갖지 않으므로 원래 클래스의 생성자가 호출되어서
    'I am the constructor of A.&lt;br>'를 출력한다.
   </para>
   
   <caution>
    <simpara>
     PHP 3와 PHP 4 모두 파생 클래스의 생성자에서 자동으로 원래
     클래스의 생성자를 호출하지 않는다. 적절한 상단의 생성자 호출을 
     전달할 책임은 당신에게 달려있다.
    </simpara>
   </caution>
   
   <note>
    <simpara>
     PHP 3나 PHP 4에서는 소멸자(destructor)를 지원하지 않는다. 대신 이런
     소멸자의 기능을 수행하기 위해 <function>register_shutdown_function</function>
     함수를 사용할수 있다.
    </simpara>
   </note>
   
   <para>
    소멸자는 객체가 파괴될때, <function>unset</function>함수로, 
    단순히 현재 영역을 벗어남으로써 자동으로 호출되는 함수이다.
    PHP에서는 소멸자가 없다.
   </para>
  </sect1>

 <sect1 id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title><literal>::</literal></title>

   <caution>
    <simpara>
     다음은 PHP 4 이후에서만 적용되는 글이다.
    </simpara>
   </caution>

   <para>
    때때로 원래 클래스의 함수와 변수를 참조하거나 아직 어떤 
    인스턴스도 갖지 않는 클래스의 함수를 참조할 필요가 있다.
    이런 목적으로 :: 연산자를 사용한다.
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function example()
    {
        echo "I am the original function A::example().<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "I am the redefined function B::example().<br>\n";
        A::example();
    }
}

// 여기서는 클래스 A의 객체가 존재하지 않는다.
// 이 코드는
//   I am the original function A::example().<br>를 출력한다.
A::example();

// B 클래스의 객체를 생성한다.
$b = new B;

// 여기서는 다음과 같이 출력할것이다.
//   I am the redefined function B::example().<br>
//   I am the original function A::example().<br>
$b->example();
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    위 예제 코드는 클래스 A의 함수 example()이 호출된다.
    그러나 클래스 A의 객체가 존재하지 않는다. 그래서 
    $a->example()와 비슷한 코드를 쓸수 없다. 대신에 
    '클래스 함수'인 example()을 호출한다. 즉, 그 클래스의
    객체가 아니라 클래스 자체의 함수를 호출하는 것이다.
   </para>
   
   <para>
    클래스 함수는 존재하지만, 클래스 변수는 존재하지 않는다. 실제로, 호출의
    모든 시간동안 전혀 객체가 없었고 따라서, 클래스 함수는 어떤 객체 변수도
    사용할수 없다 (그러나 로컬 변수와 전역 변수는 사용할수 있다) 
    그래서 <varname>$this</varname>를 전혀 사용하지 않는다.
   </para>

   <para>
    위 예제 코드에서 클래스 B는 함수 example()을 재선언한다. ::을 사용하여
    클래스 A의 example 구현에 대해 특별히 참조하지 않으면, 클래스 A의
    원래 선언은 가려지게 되고 더이상 가용하지 않다. 이와 같이 하려면
    A::example()라고 써야 한다 (다음섹션에서 설명한대로 parent::example()
    라고 써야 한다).
   </para>
   
   <para>
    이런 환경에서는 현재 객체가 있고 그 객체는 객체 변수를 갖을수도 있다.
    따라서 객체 함수 안에서 사용할때에는 <varname>$this</varname>와 
    객체 변수를 사용해야 할것이다.
   </para>

 </sect1>

 <sect1 id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   원래 클래스의 변수와 함수를 참조하는 코드를 짜야할 필요가 생길수 있다.
   파생 클래스가 세밀하게 고안되었거나 원래 클래스의 코드에서 특수화되어
   있는경우에는 더욱 그럴 필요성이 생긴다.
  </para>
  
  <para>
   코드에서 원래 클래스명을 사용하는 대신에, 특별한 이름 <literal>parent</literal>
   을 사용해야 한다. 이 용어는 현재 클래스의 <literal>extends</literal>선언
   안에 주어진 원래 클래스에 대한 참조한다는 의미를 갖는다. 이렇게 씀으로써
   여러 곳에서 원래 클래스명을 쓰는것을 피할수 있다. 구현중에 상속이 세번
   바뀌게 되면, 단순히 현재 클래스의 <literal>extends</literal>선언을
   바꾸기만 하면 된다.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class A
{
    function example()
    {
        echo "I am A::example() and provide basic functionality.<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "I am B::example() and provide additional functionality.<br>\n";
        parent::example();
    }
}

$b = new B;

// This will call B::example(), which will in turn call A::example().
$b->example();
?>
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 id="language.oop.serialization">
  <title>Serializing objects - objects in sessions</title>

  <note>
   <simpara>
    In PHP 3, objects will lose their class association
    throughout the process of serialization and unserialization. 
    The resulting variable is of type object, but has no class
    and no methods, thus it is pretty useless (it has become
    just like an array with a funny syntax).
   </simpara>
  </note>

  <caution>
   <simpara>
    The following information is valid for PHP 4 only. 
   </simpara>
  </caution>

  <para>
   <function>serialize</function> returns a string containing a
   byte-stream representation of any value that can be stored in
   PHP. <function>unserialize</function> can use this string to
   recreate the original variable values. Using serialize to
   save an object will save all variables in an object.  The
   functions in an object will not be saved, only the name of
   the class.
  </para>
  
  <para>
   In order to be able to <function>unserialize</function> an object, the
   class of that object needs to be defined. That is, if you have an object
   <varname>$a</varname> of class A on page1.php and serialize this, you'll
   get a string that refers to class A and contains all values of variabled
   contained in <varname>$a</varname>. If you want to be able to unserialize
   this on page2.php, recreating <varname>$a</varname> of class A, the
   definition of class A must be present in page2.php. This can be done for
   example by storing the class defintion of class A in an include file and
   including this file in both page1.php and page2.php.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// classa.inc:
  
  class A 
  {
      var $one = 1;
    
      function show_one()
      {
          echo $this->one;
      }
  }
  
// page1.php:

  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // store $s somewhere where page2.php can find it.
  $fp = fopen("store", "w");
  fputs($fp, $s);
  fclose($fp);

// page2.php:
  
  // this is needed for the unserialize to work properly.
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // now use the function show_one() of the $a object.  
  $a->show_one();
?>
]]>
   </programlisting>
  </informalexample>
  
  <para>
   If you are using sessions and use <function>session_register</function>
   to register objects, these objects are serialized automatically
   at the end of each PHP page, and are unserialized automatically on
   each of the following pages. This basically means that these objects
   can show up on any of your pages once they become part of your
   session.
  </para>
  
  <para>
   It is strongly recommended that you include the class
   definitions of all such registered objects on all of your
   pages, even if you do not actually use these classes on all
   of your pages. If you don't and an object is being
   unserialized without its class definition being present, it
   will lose its class association and become an object of class
   <literal>stdClass</literal> without any functions available
   at all, that is, it will become quite useless.
  </para>
  
  <para>
   So if in the example above <varname>$a</varname> became part of a session
   by running <literal>session_register("a")</literal>, you should include the
   file <literal>classa.inc</literal> on all of your pages, not only page1.php
   and page2.php.
  </para>
 </sect1>

 <sect1 id="language.oop.magic-functions">
  <title>The magic functions <literal>__sleep</literal> and <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> checks if your class has a function with
   the magic name <literal>__sleep</literal>. If so, that function is
   being run prior to any serialization. It can clean up the object
   and is supposed to return an array with the names of all variables
   of that object that should be serialized.
  </para>
  
  <para>
   The intended use of <literal>__sleep</literal> is to close any
   database connections that object may have, committing pending
   data or perform similar cleanup tasks. Also, the function is
   useful if you have very large objects which need not be
   saved completely.
  </para>
  
  <para>
   Conversely, <function>unserialize</function> checks for the
   presence of a function with the magic name 
   <literal>__wakeup</literal>. If present, this function can
   reconstruct any resources that object may have.
  </para>
  
  <para>
    The intended use of <literal>__wakeup</literal> is to
    reestablish any database connections that may have been lost
    during serialization and perform other reinitialization
    tasks.
  </para>
 </sect1>
  
 <sect1 id="language.oop.newref">
   <title>References inside the constructor</title>
   <para>
    Creating references within the constructor can lead to confusing
    results. This tutorial-like section helps you to avoid problems.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Foo($name)
    {
        // create a reference inside the global array $globalref
        global $globalref;
        $globalref[] = &$this;
        // set name to passed value
        $this->setName($name);
        // and put it out
        $this->echoName();
    }

    function echoName()
    {
        echo "<br>",$this->name;
    }
 
    function setName($name)
    {
        $this->name = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    Let us check out if there is a difference between
    <varname>$bar1</varname> which has been created using
    the copy <literal>=</literal> operator and
    <varname>$bar2</varname> which has been created using
    the reference <literal>=&amp;</literal> operator...

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar1 = new Foo('set in constructor');
$bar1->echoName();
$globalref[0]->echoName();

/* output:
set in constructor
set in constructor
set in constructor */

$bar2 =& new Foo('set in constructor');
$bar2->echoName();
$globalref[1]->echoName();

/* output:
set in constructor
set in constructor
set in constructor */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Apparently there is no difference, but in fact there is a
    very significant one: <varname>$bar1</varname> and
    <varname>$globalref[0]</varname> are _NOT_ referenced, they
    are NOT the same variable. This is because "new" does not
    return a reference by default, instead it returns a copy.
    <note>
     <simpara>
      There is no performance loss (since PHP 4 and up use reference
      counting) returning copies instead of references. On the
      contrary it is most often better to simply work with copies
      instead of references, because creating references takes some
      time where creating copies virtually takes no time (unless none
      of them is a large array or object and one of them gets changed
      and the other(s) one(s) subsequently, then it would be wise to
      use references to change them all concurrently).
     </simpara>
    </note>
    To prove what is written above let us watch the code below.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// now we will change the name. what do you expect?
// you could expect that both $bar1 and $globalref[0] change their names...
$bar1->setName('set from outside');

// as mentioned before this is not the case.
$bar1->echoName();
$globalref[0]->echoName();

/* output:
set from outside
set in constructor */

// let us see what is different with $bar2 and $globalref[1]
$bar2->setName('set from outside');

// luckily they are not only equal, they are the same variable
// thus $bar2->name and $globalref[1]->name are the same too
$bar2->echoName();
$globalref[1]->echoName();

/* output:
set from outside
set from outside */
?>
]]>
     </programlisting>
    </informalexample>   
   </para>   
   <para>
   Another final example, try to understand it.
   
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A($i)
    {
        $this->value = $i;
        // try to figure out why we do not need a reference here
        $this->b = new B($this);
    }

    function createRef()
    {
        $this->c = new B($this);
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->value;
    }
}


class B
{
    function B(&$a)
    {
        $this->a = &$a;
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->a->value;
    }
}

// try to undestand why using a simple copy here would yield
// in an undesired result in the *-marked line
$a =& new A(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

/*
output:
class A: 10
class B: 10
class B: 10
class A: 11
class B: 11
class B: 11
*/
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.oop.object-comparison-php4">
   <title>Comparing objects in PHP 4</title>
  <para>
   In PHP 4, objects are compared in a very simple manner, namely: Two object
   instances are equal if they have the same attributes and values, and are
   instances of the same class. Similar rules are applied when comparing two
   objects using the identity operator (<literal>===</literal>).
  </para>
  <para>
   If we were to execute the code in the example below:
   <example>
    <title>Example of object comparison in PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

class SwitchableFlag extends Flag {

    function turnOn() {
        $this->flag = true;
    }

    function turnOff() {
        $this->flag = false;
    }
}

$o = new Flag();
$p = new Flag(false);
$q = new Flag();

$r = new SwitchableFlag();

echo "Compare instances created with the same parameters\n";
compareObjects($o, $q);

echo "\nCompare instances created with different parameters\n";
compareObjects($o, $p);

echo "\nCompare an instance of a parent class with one from a subclass\n";
compareObjects($o, $r);
?>
]]>
    </programlisting>
   </example>
   We will see:
   <screen>
Compare instances created with the same parameters
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Compare instances created with different parameters
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Compare an instance of a parent class with one from a subclass
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
   </screen>
   Which is the output we will expect to obtain given the comparison rules
   above. Only instances with the same values for their attributes and from the same
   class are considered equal and identical.
  </para>
  <para>
   Even in the cases where we have object composition, the same comparison
   rules apply. In the example below we create a container class that stores
   an associative array of <classname>Flag</classname> objects.
   <example>
    <title>Compound object comparisons in PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
class FlagSet {
    var $set;

    function FlagSet($flagArr = array()) {
        $this->set = $flagArr;
    }

    function addFlag($name, $flag) {
        $this->set[$name] = $flag;
    }

    function removeFlag($name) {
        if (array_key_exists($name, $this->set)) {
            unset($this->set[$name]);
        }
    }
}


$u = new FlagSet();
$u->addFlag('flag1', $o);
$u->addFlag('flag2', $p);
$v = new FlagSet(array('flag1'=>$q, 'flag2'=>$p));
$w = new FlagSet(array('flag1'=>$q));

echo "\nComposite objects u(o,p) and v(q,p)\n";
compareObjects($u, $v);

echo "\nu(o,p) and w(q)\n";
compareObjects($u, $w);
?>     
]]>
    </programlisting>
   </example>
   Which gives the expected output:
   <screen>
Composite objects u(o,p) and v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) and w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
   </screen>
  </para>
 </sect1>

  <sect1 id="language.oop.object-comparison-php5">
   <title>Comparing objects in PHP 5</title>
   &warn.experimental;
   <para>
    In PHP 5, object comparison is a more complicated than in PHP 4 and more
    in accordance to what one will expect from an Object Oriented Language
    (not that PHP 5 is such a language).
   </para>
   <para>
    When using the comparison operator (<literal>==</literal>), 
    object variables are compared in a simple manner, namely: Two object
    instances are equal if they have the same attributes and values, and are
    instances of the same class, defined in the same namespace.
   </para>
   <para>
    On the other hand, when using the identity operator (<literal>===</literal>),
    object variables are identical if and only if they refer to the same
    instance of the same class (in a particular namespace).
   </para>
   <para>
    An example will clarify these rules.
    <example>
     <title>Example of object comparison in PHP 5</title>
     <programlisting role='php'>
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

namespace Other {

    class Flag {
        var $flag;

        function Flag($flag=true) {
                $this->flag = $flag;
        }
    }

}

$o = new Flag();
$p = new Flag();
$q = $o;
$r = new Other::Flag();

echo "Two instances of the same class\n";
compareObjects($o, $p);

echo "\nTwo references to the same instance\n";
compareObjects($o, $q);

echo "\nInstances of similarly named classes in different namespaces\n";
compareObjects($o, $r);
?>
]]>
     </programlisting>
    </example>
    This example will output:
    <screen>
Two instances of the same class
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Two references to the same instance
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Instances of similarly named classes in different namespaces
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
    </screen>
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
