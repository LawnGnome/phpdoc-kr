<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.13 $ -->
<!-- EN-Revision: 1.43 Maintainer: fuzzy74 Status: ready -->
 <chapter xml:id="language.oop" xmlns="http://docbook.org/ns/docbook">
  <title>클래스와 객체</title>

  <sect1 xml:id="keyword.class">
   <title><literal>class</literal></title>
   <para>
    클래스(class)는 특정 변수들 그리고 이 변수들과 같이 동작하는 함수의 집합체이다.
    다음 예제코드처럼 클래스를 선언할수 있다:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Cart
{
    var $items;  // Items in our shopping cart
   
    // Add $num articles of $artnr to the cart
 
    function add_item ($artnr, $num)
    {
        $this->items[$artnr] += $num;
    }
   
    // Take $num articles of $artnr out of the cart
 
    function remove_item ($artnr, $num)
    {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } else {
            return false;
        }   
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    위 코드에서 Cart라는 이름을 갖는 클래스는 카트(cart)를 위한 품목의 연관 배열,
    그리고 카트에 아이템을 추가하거나 제거하는 두 개의 함수로 구성되어있다. 
   </para>

   <warning>
    <simpara>
     클래스 선언부를 여러 파일이나 여러 PHP블록으로 분리할수 <emphasis>없다</emphasis>
     다음 코드는 작동하지 않을것이다:
    </simpara>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
<?php
class test {
?>
<?php
    function test() {
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>

   <simpara>
    PHP 4에서는 다음 사항에 주의해야 한다.
   </simpara>
    
   <caution>
    <simpara>
     Zend에서는 <literal>stdClass</literal>같은 명칭을 내부적으로 사용하며 
     이 명칭은 예약되어있다. 따라서 PHP에서 <literal>stdClass</literal>라는
     클래스명을 만들수 없다.
    </simpara>
   </caution>
    
   <caution>
    <simpara>
      <literal>__sleep</literal>과 <literal>__wakeup</literal>함수는
      PHP 클래스에서 중요한 역할을 수행한다. 이들과 결합된 매직 기능을 원
      하지 않는다면 이런 이름을 클래스내에서 사용할수 없다. 
      다음 글에서 자세하게 설명할것이다.
    </simpara>
   </caution>
    
   <caution>
    <simpara>
      PHP에서 __으로 시작하는 함수명은 매직 기능을 수행하도록 예약되어있다.
      문서화된 매직 기능을 원하지 않는다면 PHP에서 __를 갖는 함수명을 
      사용하지 않도록 한다.
    </simpara>
   </caution>

   <simpara>
    PHP 4에서 <literal>var</literal>로 변수를 선언할때는 상수로만 초기화될수
    있다. 상수가 아닌 값으로 초기화하려면, 클래스로부터 객체를 생성할때 자동적
    으로 호출되는 함수에서 초기화할 필요가 있다. 이런 함수를 생성자(constructor)
    라고 부른다. (다음글을 보세요)
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
/* PHP 4에서 이 코드는 작동하지 않을것이다 */
class Cart
{
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    var $items = array("VCR", "TV");
}

/* 이와 같이 해야 한다 */
class Cart
{
    var $todays_date;
    var $name;
    var $owner;
    var $items;

    function Cart()
    {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* etc. . . */
    }
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    class는 타입이다. 즉, 실제 변수를 위한 청사진이다. <literal>new</literal>
    연산자를 사용하여 원하는 이런 타입의 변수를 생성할 수 있다.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$cart = new Cart;
$cart->add_item("10", 1);

$another_cart = new Cart;
$another_cart->add_item("0815", 3);
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    위 예제 코드는 Cart클래스의 <varname>$cart</varname>, <varname>$another_cart</varname>
    객체를 생성한다. <varname>$cart</varname>의 add_item() 함수는 <varname>$cart</varname>
    에 품목 번호가 10인 아이템 1개를 추가하고, <varname>$another_cart</varname>에
    품목 번호가 0815인 아이템 3개를 추가한다.
   </para>
   
   <para>
    <varname>$cart</varname>와 <varname>$another_cart</varname> 둘다 
    add_item(), remove_item() 함수와 items변수를 갖는다. 이들 모두 서로
    다른 함수와 변수들이다. 이런 객체는 파일시스템의 디렉토리에 비유될수 있다.
    파일시스템에서는 서로 다른 디렉토리에 있으면 두개의 다른 README.TXT파일을 
    저장할수 있다. 이 파일 각각에 접근하기 위해서는 최상위 디렉토리에서
    각 파일로의 경로를 지정해 줘야 하듯이, 이런 각 함수를 호출하고자 한다면 
    각 함수의 완전한 이름을 지정해야 한다: PHP에서 최상위 디렉토리는 전역 
    네임스페이스를 갖고, 경로 구분자로 <literal>-&gt;</literal>를 사용할수 있다. 
    따라서, <varname>$cart-&gt;items</varname>과 <varname>$another_cart-&gt;items</varname>
    은 서로 다른 변수를 지칭하는 것이다.
    변수는 <varname>$cart-&gt;$items</varname>이 아니라, <varname>$cart-&gt;items</varname>
    로 지정해야 한다는 것에 주의해야 한다. 즉, PHP에서 변수명은 오직 한개의
    달러사인($) 기호만 허용된다.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// correct, single $
$cart->items = array("10" => 1); 

// invalid, because $cart->$items becomes $cart->""
$cart->$items = array("10" => 1);

// correct, but may or may not be what was intended:
// $cart->$myvar becomes $cart->items
$myvar = 'items';
$cart->$myvar = array("10" => 1);  
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    클래스의 선언부에서는 프로그램이 객체에 접근할때 어느 객체명 밑에 속해있을지
    알수 없다: Cart 클래스가 선언된 후에 그 객체가 <varname>$cart</varname>나 
    <varname>$another_cart</varname> 객체명을 갖을지 알수 없는것이다. 따라서,
    Cart 클래스 선언부 안에서 <varname>$cart-&gt;items</varname>라고 쓸수 없다.
    대신에, 클래스내의 함수나 변수에 접근할 수 있게 하려면 '내 소유'나 '현재
    객체'라고 해석할수 있는 <varname>$this</varname>라는 의사-변수를 사용할수 있다.
    따라서, '<varname>$this-&gt;items[$artnr]</varname> += <varname>$num</varname>'
    이라는 코드는 '내 소유의 items 배열의 <varname>$artnr</varname>카운터를
    <varname>$num</varname>만큼 더하라' 또는 '현재 객체의 items 배열의 <varname>$artnr</varname>
    카운터를 <varname>$num</varname>만큼 더하라'고 해석할 수 있다.
   </para>

   <note>
    <para>
    클래스와 객체를 제어할 수 있는 몇가지의 유용한 함수가 제공된다.
    <link linkend="ref.classobj">클래스/객체 함수</link>에서 확인할수 있다.
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    때때로 기존의 클래스와 비슷한 변수와 함수를 갖는 클래스가 필요할때
    가 있다. 실제로, 모든 프로젝트에서 사용할수 있는 범용의 클래스를 
    선언하고, 특정 프로젝트에서 이런 클래스를 필요에 의해 변경하는 것은 
    좋은 습관이다. 이런 일을 수월하게 하기 위해서 클래스는 다른 클래스에서
    확장(extension) 될수 있다. 이렇게 확장되거나 파생된 클래스는 원래
    클래스의 모든 변수와 함수를 소유하고 (이런 경우를 아무도 죽지 않았음
    에도 불구하고 '상속'이라고 부른다) 필요로 하는 확장된 선언을 추가할수 있다.
    기존 클래스에서 기존 함수나 변수의 선언을 해제하여 뺄수는 없다.
    확장 클래스는 항상 하나의 기존 클래스에만 연관되어있다. 즉 다중 상속은
    지원되지 않는다. 클래스는 'extends'라는 키워드를 사용하여 확장된다.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Named_Cart extends Cart
{
    var $owner;
  
    function set_owner ($name)
    {
        $this->owner = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    위 코드는 Cart의 모든 변수와 함수는 물론 추가된 변수 <varname>$owner</varname>
    와 추가된 함수 set_owner()를 갖는 클래스를 선언한다. 이로써 이름이 있는 카트를 만들고
    카트의 소유자를 설정하고 얻어올수 있다. 이름이 있는 카트에서는 물론 기존의 일반 카트 함수
    도 쓸수 있다:
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$ncart = new Named_Cart;    // 이름이 있는 카트 만들기
$ncart->set_owner("kris");  // 그 카트에 소유자를 설정
print $ncart->owner;        // 소유자 이름을 출력
$ncart->add_item("10", 1);  // (기존 cart에서 상속한 함수 사용)
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    이런 경우를 "부모-자식" 관계라고 부르기도 한다. 부모 클래스를 만들고,
    부모 클래스에 <emphasis>기반한</emphasis> 새 클래스를 만들려면
    <literal>extends</literal>를 사용한다: 자식 클래스. 심지어 이런 새로운 
    자식 클래스를 사용하거나 이 자식 클래스에 기반한 다른 클래스도 만들수 있다.
   </para>
   <note>
    <para>
     클래스는 그것이 사용되기 전에 이미 선언되어 있어야 한다! 
     <literal>Cart</literal>클래스를 상속하는 <literal>Named_Cart</literal>클래스가
     필요하면 우선 <literal>Cart</literal>클래스를 먼저 선언해야 할것이다.
     <literal>Named_Cart</literal>클래스에 기반한 다른 클래스 <literal>Yellow_named_cart</literal>
     를 생성하고자 한다면 <literal>Named_Cart</literal>클래스를 먼저 선언해야 한다.
     짧게 말해서: 클래스가 선언되는 순서는 중요하다.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.oop.constructor">
   <title><literal>생성자</literal></title>

   <caution>
    <simpara>
     PHP 3와 PHP 4에서 생성자(constructor)는 서로 다르게 동작한다.
     PHP 4의 문법이 강력히 추천하는 바이다.
    </simpara>
   </caution>

   <para>
    생성자는 <literal>new</literal>를 사용하여 클래스의 새 인스턴스를
    생성할때 자동으로 호출되는 클래스 내의 함수를 말한다. PHP 3에서는
    클래스의 이름과 동일한 함수가 생성자가 된다. PHP 4에서는 클래스가
    선언될때의 클래스명과 동일한 이름을 갖는 함수가 생성자가 된다. - 
    차이는 미묘하지만 매우 중요하다 (다음 글을 보세요).
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// PHP 3와  PHP 4에서 작동함
class Auto_Cart extends Cart
{
    function Auto_Cart()
    {
        $this->add_item ("10", 1);
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    위 코드는 Cart와 같은 Auto_Cart 클래스를 선언하고
    "new"로 새로운 Auto_Cart가 생성될때마다 상품번호 "10"인
    아이템 하나를 갖는 카트로 초기화하는 생성자를 만든다.
    생성자는 인수를 취할수 있고 이런 인수로 인해 생성자를 더 유용하게
    만들어주지만 없을수도 있다. 인수가 없는 클래스를 사용하려면 
    생성자의 모든 인수는 기본값을 제공해 줄수 있다.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// PHP 3와 PHP 4에서 동작함.
class Constructor_Cart extends Cart
{
    function Constructor_Cart($item = "10", $num = 1)
    {
        $this->add_item ($item, $num);
    }
}
 
// Shop the same old boring stuff.
 
$default_cart = new Constructor_Cart;
 
// Shop for real...
 
$different_cart = new Constructor_Cart("20", 17);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    생성자에서 발생할수 있는 에러 메시지를 <emphasis>보이지 않게</emphasis>
    하려면 <literal>@</literal>연산자를 사용할수 있다.즉,
    <literal>@new</literal>를 쓸수 있다.
   </para>

   <caution>
    <simpara>
     PHP 3에서 파생 클래스와 생성자는 많은 제약을 갖는다.
     다음 예제 코드는 이런 제약을 이해하기 위해 주의깊게 살펴봐야할것이다.
    </simpara> 
   </caution>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
      echo "I am the constructor of A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "I am a regular function.<br>\n";
    }
}

// PHP 3에서는 어떤 생성자도 호출되지 않는다.
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    위 예제 코드는 PHP 3에서는 어떤 생성자도 호출되지 않는다. PHP 3의
    규칙은 : '생성자는 클래스와 같은 이름을 갖는 함수이다'. 클래스명 
    이 B이고 이 클래스에서는 B()함수가 없으므로 아무일도 일어나지 않는다.
   </para>
   
   <para>
    PHP 4에서는 다른 규칙이 적용되어서 이런 규칙의 문제가 해결되었다: 클래스가
    생성자를 갖지 않을때, 원래 클래스에서 생성자가 존재하면 그 생성자가 
    호출된다. 위 예제 코드는 PHP 4에서 'I am the constructor of A.&lt;br>'
    를 출력할것이다.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
        echo "I am the constructor of A.<br>\n";
    }

    function B()
    {
        echo "I am a regular function named B in class A.<br>\n";
        echo "I am not a constructor in A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "I am a regular function.<br>\n";
    }
}

// This will call B() as a constructor.
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    PHP 3에서 클래스 A의 함수 B()는 의도하지 않았을지라도 즉시 
    클래스 B의 생성자가 될것이다. PHP 3의 규칙: '생성자는 클래스와 
    같은 이름을 갖는 함수이다'. PHP 3에서는 그 함수가 클래스 B에서
    선언되었는지 또는 거기서 상속되었는지는 상관하지 않는다.
   </para>
   
   <para>
    위 규칙의 문제점을 PHP 4에서는 다음과 같은 규칙으로 해결했다 : 
    '생성자는 그것이 선언된 클래스와 같은 이름을 갖는 함수이다'. 
    따라서 PHP 4는 클래스 B가 생성자를 갖지 않으므로 원래 클래스의
    생성자가 호출되어서 'I am the constructor of A.&lt;br>'를 출력한다.
   </para>
   
   <caution>
    <simpara>
     PHP 3와 PHP 4 모두 파생 클래스의 생성자에서 자동으로 원래
     클래스의 생성자를 호출하지 않는다. 적절하게 상단에 생성자 호출을 
     전달할 책임은 당신에게 달려있다.
    </simpara>
   </caution>
   
   <note>
    <simpara>
     PHP 3나 PHP 4에서는 소멸자(destructor)를 지원하지 않는다. 대신에 이런
     소멸자의 기능을 수행하기 위해 <function>register_shutdown_function</function>
     함수를 사용할수 있다.
    </simpara>
   </note>
   
   <para>
    소멸자는 객체가 파괴될때, <function>unset</function>함수나, 
    단순히 현재 영역을 벗어남으로써 자동으로 호출되는 함수이다.
    PHP에서는 소멸자가 없다.
   </para>
  </sect1>

 <sect1 xml:id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title><literal>::</literal></title>

   <caution>
    <simpara>
     다음은 PHP 4 이후에서만 적용되는 글이다.
    </simpara>
   </caution>

   <para>
    때때로 원래 클래스의 함수와 변수를 참조하거나 아직 어떤 
    인스턴스도 갖지 않는 클래스의 함수를 참조할 필요가 있다.
    이런 목적으로 :: 연산자를 사용한다.
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function example()
    {
        echo "I am the original function A::example().<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "I am the redefined function B::example().<br>\n";
        A::example();
    }
}

// 여기서는 클래스 A의 객체가 존재하지 않는다.
// 이 코드는
//   I am the original function A::example().<br>를 출력한다.
A::example();

// B 클래스의 객체를 생성한다.
$b = new B;

// 여기서는 다음과 같이 출력할것이다.
//   I am the redefined function B::example().<br>
//   I am the original function A::example().<br>
$b->example();
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    위 예제 코드는 클래스 A의 함수 example()이 호출된다.
    그러나 클래스 A의 객체가 존재하지 않는다. 그래서 
    $a->example()와 비슷한 코드를 쓸수 없다. 대신에 
    '클래스 함수'인 example()을 호출한다. 즉, 그 클래스의
    객체가 아니라 클래스 자체의 함수를 호출하는 것이다.
   </para>
   
   <para>
    클래스 함수는 존재하지만, 클래스 변수는 존재하지 않는다. 실제로, 호출의
    모든 시간동안 전혀 객체가 없었고 따라서, 클래스 함수는 어떤 객체 변수도
    사용할수 없다 (그러나 로컬 변수와 전역 변수는 사용할수 있다) 
    그래서 <varname>$this</varname>를 전혀 사용하지 않는다.
   </para>

   <para>
    위 예제 코드에서 클래스 B는 함수 example()을 재선언한다. ::을 사용하여
    클래스 A의 example 구현에 대해 특별히 참조하지 않으면, 클래스 A의
    원래 선언은 가려지게 되고 더이상 가용하지 않다. 이와 같이 하려면
    A::example()라고 써야 한다 (다음섹션에서 설명한대로 parent::example()
    라고 써야 한다).
   </para>
   
   <para>
    이런 환경에서는 현재 객체가 있고 그 객체는 객체 변수를 갖을수도 있다.
    따라서 객체 함수 안에서 사용할때에는 <varname>$this</varname>와 
    객체 변수를 사용해야 할것이다.
   </para>

 </sect1>

 <sect1 xml:id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   원래 클래스의 변수와 함수를 참조하는 코드를 짜야할 필요가 생길수 있다.
   파생 클래스가 세분화되어 고안되었거나 원래 클래스의 코드에서 특수화되어
   있는경우에는 더욱 그럴 필요성이 생긴다.
  </para>
  
  <para>
   코드에서 원래 클래스명을 사용하는 대신에, 특별한 이름 <literal>parent</literal>
   을 사용해야 한다. 이 용어는 현재 클래스의 <literal>extends</literal>선언
   안에 주어진 원래 클래스를 참조한다는 의미를 갖는다. 이렇게 씀으로써
   여러 곳에서 원래 클래스명을 쓰는것을 피할수 있다. 구현중에 상속이 세번
   바뀌게 되면, 단순히 현재 클래스의 <literal>extends</literal>선언을
   바꾸기만 하면 된다.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class A
{
    function example()
    {
        echo "I am A::example() and provide basic functionality.<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "I am B::example() and provide additional functionality.<br>\n";
        parent::example();
    }
}

$b = new B;

// This will call B::example(), which will in turn call A::example().
$b->example();
?>
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 xml:id="language.oop.serialization">
  <title>객체 일렬화 - 세션 내의 객체</title>

  <note>
   <simpara>
    PHP 3에서 객체는 일렬화(serialization)와 비일렬화(unserialization)처리 
    과정에서 클래스의 구성요소를 잃게 된다. 처리후 이 변수는 더이상 객체 타입 
    이 아니다. 그래서 클래스와 메소드를 갖지 않는다. 결국은 거의 쓸모 없게 
    되는것이다 (웃기는 문법을 갖는 배열처럼 바뀌게 된다)
   </simpara>
  </note>

  <caution>
   <simpara>
    다음 설명은 PHP 4로만 한정되는 내용이다.
   </simpara>
  </caution>

  <para>
   <function>serialize</function>함수는 PHP에 저장할수 있는 값은 뭐든지 
   바이트-스트림(byte-stream) 대표성을 내포하는 문자열로 돌려준다.
   <function>unserialize</function>함수는 이런 문자열을 원래 변수값으로
   되돌려준다. serialize를 사용하여 객체를 저장하면 객체 내의 모든 변수
   를 저장할 수 있다. 객체 내의 함수들을 저장할 수는 없고, 오직 클래스의 
   이름만 저장될것이다.
  </para>
  
  <para>
   객체를 <function>unserialize</function>하기 위해서는, 그 객체의 클래스가
   선언되어 있어야 한다. 즉, page1.php에서 클래스 A의 객체 <varname>$a</varname>
   가 있고 이것을 일렬화하면, 클래스 A를 참조하는 문자열을 얻게 되고, 이 
   문자열은 <varname>$a</varname>에 속해있는 모든 변수값을 포함하게 될것이다.
   Page2.php에서 이 문자열을 비일렬화하려면, 클래스 A의 <varname>$a</varname>를
   재생성하고, 클래스 A의 선언이 page2.php에 존재해야 한다. 예를 들면
   인클루드 파일 안에 클래스 A의 클래스 선언부를 저장하고 page1.php와 page2.php
   에서 이 파일을 인클루드 하면 된다.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// classa.inc:
  
  class A 
  {
      var $one = 1;
    
      function show_one()
      {
          echo $this->one;
      }
  }
  
// page1.php:

  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // store $s somewhere where page2.php can find it.
  $fp = fopen("store", "w");
  fputs($fp, $s);
  fclose($fp);

// page2.php:
  
  // this is needed for the unserialize to work properly.
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // now use the function show_one() of the $a object.  
  $a->show_one();
?>
]]>
   </programlisting>
  </informalexample>
  
  <para>
   세션을 사용해서 객체를 등록하기 위해 <function>session_register</function>함수를
   사용한다면, 이 객체들은 각 PHP 페이지의 끝에서 자동으로 일렬화되고, 
   다음 페이지들 각각에서 자동으로 비일렬화된다. 이 객체들이 일단 세션의
   일부분이 되면 페이지의 어느 부분에서도 이런 객체가 나타날 수 있다는것을
   의미한다.
  </para>
  
  <para>
   모든 페이지에서 실제로 이런 클래스를 사용하지 않더라도, 모든 페이지에 
   등록된 모든 객체의 클래스 선언을 인클루드하도록 한다. 이렇게 하지 않고,
   존재하는 클래스 선언부없이 객체가 일렬화되면, 그 객체는 클래스 구성원을
   잃게 될것이고 어떤 함수도 갖지 않는 <literal>stdClass</literal>클래스의
   객체가 될것이다. 즉, 그 객체는 쓸모없게 될것이다.
  </para>
  
  <para>
   그래서 위 예제코드에서 <varname>$a</varname>가 <literal>session_register("a")</literal>
   수행하여 세션의 일부분이 되면, page1.php와 page2.php뿐만 아니라 사용중인 모든
   페이지에 <literal>classa.inc</literal>파일을 인클루드해야 한다.
  </para>
 </sect1>

 <sect1 xml:id="language.oop.magic-functions">
  <title>매직함수 <literal>__sleep</literal>와 <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function>는 클래스가 <literal>__sleep</literal>라는 
   매직 이름을 갖는 함수를 갖는지 체크한다. 이 함수를 갖고있다면, 
   일렬화되기 전에 이 함수가 수행된다. 이 함수는 객체를 깨끗하게 비울수 있고,
   일렬화되어야 하는 그 객체의 모든 변수명을 갖는 배열을 돌려준다.
  </para>
  
  <para>
   <literal>__sleep</literal>의 의도된 사용은 그 객체가 소유할지도 모르는
   모든 데이터베이스의 접속을 종료하고, 아직 수행되지 않은 커밋(commit)
   을 수행하거나 청소작업을 수행한다. 또한, 완전히 저장할 필요가 없는
   매우 거대한 객체를 갖고 있다면 이 함수를 유용하게 쓸수 있다.
  </para>
  
  <para>
   반대로, <function>unserialize</function>는 <literal>__wakeup</literal>라는
   매직 이름을 갖는 함수의 존재를 체크한다. 이 함수가 존재하면, 객체가
   갖고 있을지도 모르는 모든 자원을 해제할수 있다.
  </para>
  
  <para>
    <literal>__wakeup</literal>의 의도된 사용은 일렬화동안에 소실될수
    있는 모든 데이터베이스 접속을 재구축하고 다른 재초기화 작업을 수행
    한다.
  </para>
 </sect1>
  
 <sect1 xml:id="language.oop.newref">
   <title>생성자의 재참조</title>
   <para>
    생성자 내로 참조를 만드는 것은 혼란스런 결과를 유도할수 있다. 이런
    튜토리얼같은 섹션이 문제를 회피하도록 도와준다.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Foo($name)
    {
        // 전역 배열 $globalref 안에 참조를 만든다
        global $globalref;
        $globalref[] = &$this;
        // 값을 전달하기 위해 이름을 부여한다
        $this->setName($name);
        // 그리고 그것을 출력한다
        $this->echoName();
    }

    function echoName()
    {
        echo "<br>",$this->name;
    }
 
    function setName($name)
    {
        $this->name = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    <literal>=</literal> 복사 연산자를 사용하여 만들어지는 <varname>$bar1</varname>과 
    <literal>=&amp;</literal> 참조 연산자를 사용하여 만들어지는 <varname>$bar2</varname>
    사이에 차이점이 있는지 확인해보자...
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar1 = new Foo('set in constructor');
$bar1->echoName();
$globalref[0]->echoName();

/* output:
set in constructor
set in constructor
set in constructor */

$bar2 =& new Foo('set in constructor');
$bar2->echoName();
$globalref[1]->echoName();

/* output:
set in constructor
set in constructor
set in constructor */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    외관상으로 둘 사이에는 아무 차이점도 없다. 그러나 실제로
    매우 중요한 사실이 하나 있다: <varname>$bar1</varname>과 
    <varname>$globalref[0]</varname>은 참조되지 않는다. 그들은 
    같은 변수가 아니다. 이것은 "new"가 기본적으로 참조를 돌려주지
    않기 때문이다. 대신 그것은 복사본을 돌려준다.

    <note>
     <simpara>
      참조 대신 복사본을 돌려주는것 (PHP 4이상의 버전은 참조 카운팅을
      사용한다) 때문에 퍼포먼스가 나빠지지는 않는다. 반대로 참조
      대신에 복사본을 사용하는 것이 대부분 더 낫다. 왜냐하면 참조를
      생성하는 것은 가상적으로 복사본을 만드는 데 약간의 시간이 걸리기
      때문이다 (그것들이 거대한 배열이나 객체이고 그들 중 하나만 바뀌고
      다른것들이 연속적으로 존재한다면, 그리고 동시에 그들 모두를 변경하려한다면
      참조를 쓰는것이 더 현명할것이다)
     </simpara>
    </note>
    위에서 서술한 것을 검증하기 위해 아래 예제 코드를 보자.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// now we will change the name. what do you expect?
// you could expect that both $bar1 and $globalref[0] change their names...
$bar1->setName('set from outside');

// as mentioned before this is not the case.
$bar1->echoName();
$globalref[0]->echoName();

/* output:
set from outside
set in constructor */

// let us see what is different with $bar2 and $globalref[1]
$bar2->setName('set from outside');

// luckily they are not only equal, they are the same variable
// thus $bar2->name and $globalref[1]->name are the same too
$bar2->echoName();
$globalref[1]->echoName();

/* output:
set from outside
set from outside */
?>
]]>
     </programlisting>
    </informalexample>   
   </para>   
   <para>
   마지막으로 다음 예제를 보고 이해하도록 하자.
   
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A($i)
    {
        $this->value = $i;
        // try to figure out why we do not need a reference here
        $this->b = new B($this);
    }

    function createRef()
    {
        $this->c = new B($this);
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->value;
    }
}


class B
{
    function B(&$a)
    {
        $this->a = &$a;
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->a->value;
    }
}

// try to undestand why using a simple copy here would yield
// in an undesired result in the *-marked line
$a =& new A(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

/*
output:
class A: 10
class B: 10
class B: 10
class A: 11
class B: 11
class B: 11
*/
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="language.oop.object-comparison-php4">
   <title>PHP 4에서 객체 비교</title>
  <para>
   PHP 4에서 객체는 매우 단순한 방식으로 비교된다. 즉: 두 객체 인스턴스
   가 같은 속성과 값을 갖고, 같은 클래스의 인스턴스라면 두 객체는 동일하다.
   식별 연산자 (<literal>===</literal>)를 사용하여 두 객체를 비교할때에도
   비슷한 규칙이 적용된다.
  </para>
  <para>
   아래 예제 코드를 실행해보면:
   <example>
    <title>PHP 4에서 객체 비교를 위한 예제코드</title>
    <programlisting role='php'>
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

class SwitchableFlag extends Flag {

    function turnOn() {
        $this->flag = true;
    }

    function turnOff() {
        $this->flag = false;
    }
}

$o = new Flag();
$p = new Flag(false);
$q = new Flag();

$r = new SwitchableFlag();

echo "Compare instances created with the same parameters\n";
compareObjects($o, $q);

echo "\nCompare instances created with different parameters\n";
compareObjects($o, $p);

echo "\nCompare an instance of a parent class with one from a subclass\n";
compareObjects($o, $r);
?>
]]>
    </programlisting>
   </example>
   결과는 다음과 같다:
   <screen>
Compare instances created with the same parameters
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Compare instances created with different parameters
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Compare an instance of a parent class with one from a subclass
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
   </screen>
   위 출력중 어떤것은 위에서 설명한 비교 규칙이 적용된다는 것을 알수 있다.
   같은 속성에 대해 같은 값을 갖고, 같은 클래스에서 파생된 인스턴스만 동일
   하고 동치로 판단한다. 
  </para>
  <para>
   복합 객체를 갖는 경우에도 같은 비교 규칙이 적용된다. 아래 예제 코드에서는
   컨테이너 클래스를 만들어서 <classname>Flag</classname> 객체의 결합 배열을
   저장한다. 
   <example>
    <title>PHP 4에서 복합 객체 비교</title>
    <programlisting role='php'>
<![CDATA[
<?php
class FlagSet {
    var $set;

    function FlagSet($flagArr = array()) {
        $this->set = $flagArr;
    }

    function addFlag($name, $flag) {
        $this->set[$name] = $flag;
    }

    function removeFlag($name) {
        if (array_key_exists($name, $this->set)) {
            unset($this->set[$name]);
        }
    }
}


$u = new FlagSet();
$u->addFlag('flag1', $o);
$u->addFlag('flag2', $p);
$v = new FlagSet(array('flag1'=>$q, 'flag2'=>$p));
$w = new FlagSet(array('flag1'=>$q));

echo "\nComposite objects u(o,p) and v(q,p)\n";
compareObjects($u, $v);

echo "\nu(o,p) and w(q)\n";
compareObjects($u, $w);
?>     
]]>
    </programlisting>
   </example>
   이 코드의 결과는 다음과 같은 출력이 기대된다:
   <screen>
Composite objects u(o,p) and v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) and w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
   </screen>
  </para>
 </sect1>

  <sect1 xml:id="language.oop.object-comparison-php5">
   <title>PHP 5에서 객체 비교</title>
   &warn.experimental;
   <para>
    PHP 5에서 객체 비교는 PHP 4보다 좀더 복잡하고 객체 지향 언어
    (PHP 5는 그런 언어가 아니다)에서 기대할수 있는 특성에 더 가깝다. 
   </para>
   <para>
    비교 연산자 (<literal>==</literal>)를 사용할 때에는 객체 변수는 단순
    한 방식으로 비교된다. 즉: 두 객체 인스턴스가 같은 속성과 값을 갖고, 
    같은 클래스에서 파생된 인스턴스이고, 같은 네임스페이스에서 선언되었
    다면 동일한 객체라고 본다.
   </para>
   <para>
    하지만, 식별 연산자 (<literal>===</literal>)를 사용하면 객체 변수는 오직 
    같은 클래스(특별한 네임스페이스에서)의 같은 인스턴스로 참조될때만 
    동일한 객체라고 본다.
   </para>
   <para>
    다음 예제 코드를 보고 이런 규칙을 음미해보자.
    <example>
     <title>PHP 5에서의 객체 비교에 대한 예제 코드</title>
     <programlisting role='php'>
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

namespace Other {

    class Flag {
        var $flag;

        function Flag($flag=true) {
                $this->flag = $flag;
        }
    }

}

$o = new Flag();
$p = new Flag();
$q = $o;
$r = new Other::Flag();

echo "Two instances of the same class\n";
compareObjects($o, $p);

echo "\nTwo references to the same instance\n";
compareObjects($o, $q);

echo "\nInstances of similarly named classes in different namespaces\n";
compareObjects($o, $r);
?>
]]>
     </programlisting>
    </example>
    이 예제 코드는 다음과 같이 출력한다:
    <screen>
Two instances of the same class
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Two references to the same instance
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Instances of similarly named classes in different namespaces
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
    </screen>
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
